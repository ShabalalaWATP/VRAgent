import React, { useState, useEffect } from "react";
import LearnPageLayout from "../components/LearnPageLayout";
import QuizSection, { QuizQuestion } from "../components/QuizSection";
import {
  Box,
  Container,
  Typography,
  Paper,
  Chip,
  Button,
  Grid,
  List,
  ListItem,
  ListItemIcon,
  ListItemText,
  alpha,
  useTheme,
  Divider,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  Accordion,
  AccordionSummary,
  AccordionDetails,
  Alert,
  AlertTitle,
  Drawer,
  IconButton,
  Tooltip,
  LinearProgress,
  useMediaQuery,
} from "@mui/material";
import ArrowBackIcon from "@mui/icons-material/ArrowBack";
import MemoryIcon from "@mui/icons-material/Memory";
import BugReportIcon from "@mui/icons-material/BugReport";
import BuildIcon from "@mui/icons-material/Build";
import WarningIcon from "@mui/icons-material/Warning";
import CheckCircleIcon from "@mui/icons-material/CheckCircle";
import QuizIcon from "@mui/icons-material/Quiz";
import InfoIcon from "@mui/icons-material/Info";
import SecurityIcon from "@mui/icons-material/Security";
import CodeIcon from "@mui/icons-material/Code";
import StorageIcon from "@mui/icons-material/Storage";
import TipsAndUpdatesIcon from "@mui/icons-material/TipsAndUpdates";
import LayersIcon from "@mui/icons-material/Layers";
import AccountTreeIcon from "@mui/icons-material/AccountTree";
import ListAltIcon from "@mui/icons-material/ListAlt";
import CloseIcon from "@mui/icons-material/Close";
import KeyboardArrowUpIcon from "@mui/icons-material/KeyboardArrowUp";
import ExpandMoreIcon from "@mui/icons-material/ExpandMore";
import SchoolIcon from "@mui/icons-material/School";
import SpeedIcon from "@mui/icons-material/Speed";
import { Link, useNavigate } from "react-router-dom";

// Heap allocators by platform
const heapAllocators = [
  {
    allocator: "ptmalloc2",
    platform: "glibc (Linux)",
    description: "Default allocator for GNU C Library",
    features: "Bins, fastbins, tcache (2.26+), safe-linking (2.32+)",
    security: "Progressive hardening over versions",
  },
  {
    allocator: "jemalloc",
    platform: "FreeBSD, Firefox, Rust",
    description: "Scalable multi-threaded allocator",
    features: "Thread-local arenas, size classes, chunk splitting",
    security: "Randomization, guard pages",
  },
  {
    allocator: "tcmalloc",
    platform: "Google (Chrome, etc.)",
    description: "Thread-caching malloc",
    features: "Per-thread and central caches, span management",
    security: "Guard pages, random sampling",
  },
  {
    allocator: "Windows Heap",
    platform: "Windows (NT Heap)",
    description: "Windows native heap manager",
    features: "LFH (Low Fragmentation Heap), Segment Heap (Win10+)",
    security: "Guard pages, encode/decode, CFG integration",
  },
  {
    allocator: "mimalloc",
    platform: "Cross-platform",
    description: "Compact, high-performance allocator",
    features: "Free-list sharding, delayed freeing",
    security: "Guard pages, secure mode",
  },
  {
    allocator: "Scudo",
    platform: "Android (Bionic)",
    description: "Hardened allocator for security-critical systems",
    features: "Checksums, randomization, delayed free",
    security: "Enhanced protection against heap exploits",
  },
];

// Heap metadata structures
const heapMetadata = [
  {
    field: "size",
    description: "Total size of chunk including header",
    bits: "Lower 3 bits used for flags (prev_inuse, is_mmapped, non_main_arena)",
    notes: "Aligned to 16 bytes on 64-bit",
  },
  {
    field: "prev_size",
    description: "Size of previous chunk (if free)",
    bits: "Only valid when previous chunk is free",
    notes: "Used during consolidation",
  },
  {
    field: "fd (forward)",
    description: "Pointer to next free chunk in bin",
    bits: "Only present in freed chunks",
    notes: "Safe-linking XORs this pointer (glibc 2.32+)",
  },
  {
    field: "bk (backward)",
    description: "Pointer to previous free chunk in bin",
    bits: "Only present in freed chunks (not fastbins/tcache)",
    notes: "Used in doubly-linked bins",
  },
  {
    field: "fd_nextsize",
    description: "Pointer to next chunk of different size (large bins)",
    bits: "Only in large bins",
    notes: "Enables efficient best-fit search",
  },
  {
    field: "bk_nextsize",
    description: "Pointer to previous chunk of different size (large bins)",
    bits: "Only in large bins",
    notes: "Maintains sorted order",
  },
];

// Exploitation techniques with details
const exploitTechniques = [
  {
    name: "Use-After-Free (UAF)",
    color: "#ef4444",
    description: "Access or modify memory after it has been freed, exploiting dangling pointers",
    prerequisites: ["Ability to free an object", "Ability to use the dangling pointer", "Control over reallocation"],
    steps: [
      "Free an object but retain a pointer to it",
      "Trigger allocation of attacker-controlled data",
      "Reallocate freed memory with controlled content",
      "Use dangling pointer to access/modify controlled data",
      "Achieve type confusion or control flow hijack",
    ],
    mitigations: ["Nullify pointers after free", "ASan/MSan", "Reference counting", "Garbage collection"],
  },
  {
    name: "Double Free",
    color: "#f59e0b",
    description: "Free the same memory chunk twice, corrupting allocator metadata and freelist integrity",
    prerequisites: ["Ability to free same pointer twice", "Lack of double-free detection"],
    steps: [
      "Allocate a chunk and save the pointer",
      "Free the chunk (enters freelist)",
      "Free the same chunk again",
      "Freelist now contains duplicate entries",
      "Allocate to get overlapping chunks",
    ],
    mitigations: ["Double-free checks (modern glibc)", "Tcache duplicate detection", "ASan"],
  },
  {
    name: "Heap Overflow",
    color: "#8b5cf6",
    description: "Write beyond allocated chunk boundaries to corrupt adjacent chunk metadata or data",
    prerequisites: ["Vulnerable write operation", "Adjacent target chunk", "Knowledge of heap layout"],
    steps: [
      "Groom heap to position target adjacent to source",
      "Overflow source buffer into target chunk",
      "Corrupt size field, fd/bk pointers, or data",
      "Trigger allocation/free to exploit corruption",
      "Achieve arbitrary write or control flow hijack",
    ],
    mitigations: ["Bounds checking", "Guard pages", "Canaries between chunks", "ASan"],
  },
  {
    name: "Fastbin Attack",
    color: "#3b82f6",
    description: "Manipulate fastbin freelist to achieve arbitrary allocation at a chosen address",
    prerequisites: ["Ability to corrupt fastbin fd pointer", "Target address with valid size field"],
    steps: [
      "Free chunks into fastbin",
      "Corrupt fd pointer of fastbin chunk",
      "Point fd to target address with fake size",
      "Allocate from fastbin twice",
      "Second allocation returns target address",
    ],
    mitigations: ["Safe-linking (glibc 2.32+)", "Fastbin checks", "Size validation"],
  },
  {
    name: "Tcache Poisoning",
    color: "#10b981",
    description: "Corrupt tcache freelist pointers to redirect allocations to arbitrary addresses",
    prerequisites: ["Tcache-sized allocation", "Ability to corrupt freed chunk", "Target address"],
    steps: [
      "Free chunk into tcache",
      "Corrupt tcache fd pointer (next pointer)",
      "Point to target address",
      "Allocate from tcache",
      "Next allocation returns target address",
    ],
    mitigations: ["Safe-linking (glibc 2.32+)", "Tcache key checks (2.29+)", "Pointer encryption"],
  },
  {
    name: "Heap Spray",
    color: "#ec4899",
    description: "Fill heap with controlled data to increase predictability and success rate",
    prerequisites: ["Ability to trigger many allocations", "Control over allocation content"],
    steps: [
      "Allocate many chunks with controlled data",
      "Fill large portions of heap space",
      "Increase probability of hitting controlled region",
      "Use with other primitives for reliable exploitation",
    ],
    mitigations: ["ASLR with high entropy", "Allocation limits", "Heap randomization"],
  },
];

// House of techniques
const houseOfTechniques = [
  {
    name: "House of Force",
    description: "Overflow top chunk size to enable arbitrary allocation placement",
    targetAllocator: "ptmalloc2 (glibc)",
    prerequisites: ["Overflow into top chunk", "Ability to request large allocation"],
    technique: "Overwrite top chunk size with -1 (0xffffffff...), then request allocation of calculated size to position remainder at target address. Next allocation returns target.",
    status: "Largely mitigated by top chunk size validation in modern glibc",
    difficulty: "Medium (mitigated)",
  },
  {
    name: "House of Spirit",
    description: "Free a fake chunk to gain allocation at a controlled address",
    targetAllocator: "ptmalloc2 (glibc)",
    prerequisites: ["Ability to craft fake chunk", "Ability to free fake chunk pointer"],
    technique: "Create fake chunk header on stack or controlled region with valid size field. Free this fake chunk to insert into fastbin. Subsequent allocation returns fake chunk address.",
    status: "Still viable with careful chunk crafting",
    difficulty: "Medium",
  },
  {
    name: "House of Lore",
    description: "Corrupt smallbin to achieve arbitrary allocation",
    targetAllocator: "ptmalloc2 (glibc)",
    prerequisites: ["Ability to corrupt smallbin chunk", "Fake chunk at target"],
    technique: "Corrupt smallbin bk pointer to point to fake chunk. Fake chunk's bk must point back. Allocation from smallbin can return fake chunk.",
    status: "Mitigated by safe unlinking checks",
    difficulty: "High (mostly mitigated)",
  },
  {
    name: "House of Orange",
    description: "Trigger malloc error to call _IO_flush_all_lockp and hijack FILE stream",
    targetAllocator: "ptmalloc2 (glibc)",
    prerequisites: ["Heap overflow", "Ability to corrupt _IO_list_all"],
    technique: "Overflow top chunk to make it invalid. Trigger malloc to call sysmalloc, which creates new heap. Corrupt unsorted bin to write to _IO_list_all. Craft fake FILE structure for code execution.",
    status: "Complex but still viable on older systems",
    difficulty: "Very High",
  },
  {
    name: "House of Einherjar",
    description: "Use null byte overflow to consolidate chunks backwards",
    targetAllocator: "ptmalloc2 (glibc)",
    prerequisites: ["Off-by-one null byte overflow", "Ability to trigger consolidation"],
    technique: "Null byte overflow clears prev_inuse flag of next chunk. Craft fake prev_size to consolidate backwards over intermediate chunk, creating overlap.",
    status: "Still viable with careful heap grooming",
    difficulty: "High",
  },
  {
    name: "House of Rabbit",
    description: "Abuse fastbin to create overlapping chunks",
    targetAllocator: "ptmalloc2 (glibc)",
    prerequisites: ["Fastbin corruption", "Ability to allocate/free fastbin chunks"],
    technique: "Corrupt fastbin fd to create loops or point to existing allocated chunks. Subsequent allocations create overlaps.",
    status: "Mitigated by safe-linking",
    difficulty: "Medium (mitigated)",
  },
];

// Mitigations and hardening techniques
const mitigationsList = [
  {
    category: "Allocator Hardening",
    color: "#10b981",
    items: [
      { name: "Safe-linking", description: "XOR-mask freelist pointers with heap-derived value (glibc 2.32+)", effectiveness: "High" },
      { name: "Tcache key", description: "Detect double-free by storing key in freed tcache chunks (glibc 2.29+)", effectiveness: "Medium" },
      { name: "Safe unlinking", description: "Validate fd->bk == chunk && bk->fd == chunk before unlinking", effectiveness: "High" },
      { name: "Top chunk checks", description: "Validate top chunk size is reasonable", effectiveness: "Medium" },
      { name: "Chunk alignment", description: "Verify chunk addresses are properly aligned", effectiveness: "Low" },
    ],
  },
  {
    category: "System Mitigations",
    color: "#3b82f6",
    items: [
      { name: "ASLR", description: "Randomize heap base address", effectiveness: "High" },
      { name: "PIE", description: "Position-independent executable for code randomization", effectiveness: "High" },
      { name: "NX/DEP", description: "Prevent execution from heap pages", effectiveness: "High" },
      { name: "RELRO", description: "Make GOT read-only (Full RELRO)", effectiveness: "Medium" },
      { name: "Stack canaries", description: "Detect stack corruption (limited heap relevance)", effectiveness: "Low for heap" },
    ],
  },
  {
    category: "Hardened Allocators",
    color: "#8b5cf6",
    items: [
      { name: "Scudo", description: "Android hardened allocator with checksums and delayed free", effectiveness: "Very High" },
      { name: "Hardened Malloc", description: "Security-focused allocator with extensive checks", effectiveness: "Very High" },
      { name: "PartitionAlloc", description: "Chrome's partitioned allocator isolating objects by type", effectiveness: "High" },
      { name: "GuardMalloc", description: "macOS debugging allocator with guard pages", effectiveness: "High" },
    ],
  },
  {
    category: "Development Practices",
    color: "#f59e0b",
    items: [
      { name: "ASan/MSan", description: "Sanitizers detect heap bugs during testing", effectiveness: "Very High" },
      { name: "Null after free", description: "Set pointers to NULL after freeing", effectiveness: "Medium" },
      { name: "Bounds checking", description: "Validate array/buffer accesses", effectiveness: "High" },
      { name: "Smart pointers", description: "Use RAII and reference counting (C++/Rust)", effectiveness: "High" },
      { name: "Fuzzing", description: "Automated testing to find heap bugs", effectiveness: "Very High" },
    ],
  },
];

// Tools for heap exploitation
const heapTools = [
  {
    name: "GDB + pwndbg",
    category: "Debugger",
    description: "GDB with pwndbg plugin for heap visualization and analysis",
    keyFeatures: ["heap command shows all chunks", "bins command displays freelist state", "vis_heap_chunks visual layout"],
    platform: "Linux",
  },
  {
    name: "GDB + GEF",
    category: "Debugger",
    description: "GDB Enhanced Features - alternative to pwndbg",
    keyFeatures: ["heap chunks visualization", "heap bins analysis", "Pattern generation/search"],
    platform: "Linux",
  },
  {
    name: "pwntools",
    category: "Exploitation Framework",
    description: "Python framework for exploit development",
    keyFeatures: ["ELF/shellcode utilities", "ROP chain building", "Remote/process interaction"],
    platform: "Cross-platform",
  },
  {
    name: "how2heap",
    category: "Reference",
    description: "Educational repository of heap exploitation techniques",
    keyFeatures: ["Working PoCs for techniques", "Version-specific examples", "Detailed explanations"],
    platform: "Linux",
  },
  {
    name: "Villoc",
    category: "Visualization",
    description: "Heap visualization tool for understanding allocator behavior",
    keyFeatures: ["Visual heap state", "Allocation tracking", "Freelist visualization"],
    platform: "Web-based",
  },
  {
    name: "ltrace/strace",
    category: "Tracing",
    description: "System/library call tracers",
    keyFeatures: ["malloc/free call tracking", "Argument inspection", "Return value monitoring"],
    platform: "Linux",
  },
  {
    name: "Valgrind",
    category: "Analysis",
    description: "Memory debugging and profiling",
    keyFeatures: ["memcheck for heap bugs", "Leak detection", "Invalid access detection"],
    platform: "Linux",
  },
  {
    name: "heapinfo",
    category: "Analysis",
    description: "Heap state inspection utility",
    keyFeatures: ["Chunk enumeration", "Bin analysis", "Corruption detection"],
    platform: "Linux",
  },
];

// Workflow steps
const exploitWorkflow = [
  {
    step: "1",
    phase: "Reconnaissance",
    description: "Identify heap vulnerability (UAF, overflow, double-free)",
    details: [
      "Analyze source code or binary",
      "Identify malloc/free patterns",
      "Find controllable inputs",
      "Determine vulnerability type",
    ],
  },
  {
    step: "2",
    phase: "Environment Analysis",
    description: "Determine allocator version and mitigations",
    details: [
      "Check glibc version (ldd --version)",
      "Identify enabled mitigations (checksec)",
      "Test tcache availability",
      "Determine ASLR entropy",
    ],
  },
  {
    step: "3",
    phase: "Heap Grooming",
    description: "Shape heap layout to position chunks favorably",
    details: [
      "Allocate chunks to control adjacency",
      "Free chunks to populate freelists",
      "Create holes for target allocation",
      "Ensure predictable layout",
    ],
  },
  {
    step: "4",
    phase: "Information Leak",
    description: "Leak heap and/or libc addresses to defeat ASLR",
    details: [
      "Use UAF to read freed chunk metadata",
      "Leak unsorted bin fd/bk (point to libc)",
      "Calculate heap base and libc base",
      "Identify target addresses",
    ],
  },
  {
    step: "5",
    phase: "Primitive Development",
    description: "Develop write-what-where or arbitrary allocation",
    details: [
      "Corrupt freelist pointers (tcache/fastbin)",
      "Point to target address",
      "Bypass safe-linking if present",
      "Test allocation reliability",
    ],
  },
  {
    step: "6",
    phase: "Code Execution",
    description: "Hijack control flow and execute payload",
    details: [
      "Overwrite function pointer (__free_hook, __malloc_hook)",
      "Corrupt GOT entry (if writable)",
      "Overwrite vtable pointer (C++)",
      "Chain with ROP for complex payloads",
    ],
  },
];

const QUIZ_QUESTION_COUNT = 10;
const QUIZ_ACCENT_COLOR = "#8b5cf6";
const quizQuestions: QuizQuestion[] = [
  {
    id: 1,
    topic: "Fundamentals",
    question: "The heap is primarily used for:",
    options: ["Dynamic allocations", "Only return addresses", "Kernel modules", "CPU registers"],
    correctAnswer: 0,
    explanation: "The heap stores dynamically allocated memory.",
  },
  {
    id: 2,
    topic: "Fundamentals",
    question: "malloc returns:",
    options: ["A pointer to heap memory", "A file descriptor", "A syscall number", "A stack frame"],
    correctAnswer: 0,
    explanation: "malloc returns a pointer to an allocated chunk.",
  },
  {
    id: 3,
    topic: "Fundamentals",
    question: "free typically:",
    options: ["Does not zero memory", "Zeroes memory by default", "Encrypts the heap", "Moves data to disk"],
    correctAnswer: 0,
    explanation: "free usually leaves memory contents intact.",
  },
  {
    id: 4,
    topic: "Metadata",
    question: "A heap chunk header usually contains:",
    options: ["Size and flags", "Only the user data", "CPU registers", "Network buffers"],
    correctAnswer: 0,
    explanation: "Chunk headers track size and state flags.",
  },
  {
    id: 5,
    topic: "Metadata",
    question: "The prev_inuse flag indicates:",
    options: ["Whether the previous chunk is in use", "Whether ASLR is enabled", "Whether NX is disabled", "Whether tcache is full"],
    correctAnswer: 0,
    explanation: "prev_inuse shows if the previous chunk is allocated.",
  },
  {
    id: 6,
    topic: "Bins",
    question: "Fastbins are used for:",
    options: ["Small, fast allocations", "Large sorted allocations", "Only mmap allocations", "Only top chunk"],
    correctAnswer: 0,
    explanation: "Fastbins hold small freed chunks for quick reuse.",
  },
  {
    id: 7,
    topic: "Bins",
    question: "tcache was introduced to:",
    options: ["Speed up small allocations", "Disable ASLR", "Remove metadata", "Encrypt heap pointers"],
    correctAnswer: 0,
    explanation: "tcache caches small chunks per thread.",
  },
  {
    id: 8,
    topic: "Bugs",
    question: "A double free occurs when:",
    options: ["The same chunk is freed twice", "Two different chunks are freed", "free is never called", "malloc fails"],
    correctAnswer: 0,
    explanation: "Double free corrupts allocator state.",
  },
  {
    id: 9,
    topic: "Bugs",
    question: "A use-after-free occurs when:",
    options: ["Memory is accessed after being freed", "Memory is allocated twice", "A pointer is null", "A size check fails"],
    correctAnswer: 0,
    explanation: "Dangling pointers can be reused after free.",
  },
  {
    id: 10,
    topic: "Bugs",
    question: "A heap overflow often corrupts:",
    options: ["Adjacent chunk data or metadata", "Only the stack", "Only registers", "Only the heap base address"],
    correctAnswer: 0,
    explanation: "Overflows can smash neighboring chunks.",
  },
  {
    id: 11,
    topic: "Techniques",
    question: "Tcache poisoning means:",
    options: ["Corrupting tcache freelist pointers", "Encrypting heap chunks", "Disabling tcache", "Clearing the heap"],
    correctAnswer: 0,
    explanation: "Poisoning tcache can redirect allocations.",
  },
  {
    id: 12,
    topic: "Techniques",
    question: "Fastbin dup refers to:",
    options: ["Getting the same chunk twice from fastbins", "Allocating in large bins", "Merging chunks", "Freeing the top chunk"],
    correctAnswer: 0,
    explanation: "Fastbin dup can yield duplicate allocations.",
  },
  {
    id: 13,
    topic: "Bins",
    question: "Unsorted bins are used to:",
    options: ["Hold recently freed chunks before sorting", "Store only large chunks", "Store only fastbins", "Disable tcache"],
    correctAnswer: 0,
    explanation: "Freed chunks first go to the unsorted bin.",
  },
  {
    id: 14,
    topic: "Bins",
    question: "Small and large bins are:",
    options: ["Size-based bins for freed chunks", "Registers used by malloc", "Kernel queues", "Stack frames"],
    correctAnswer: 0,
    explanation: "Bins organize free chunks by size class.",
  },
  {
    id: 15,
    topic: "Allocator",
    question: "The top chunk (wilderness) is:",
    options: ["The remainder chunk used for new allocations", "The smallest fastbin chunk", "A stack segment", "A thread cache"],
    correctAnswer: 0,
    explanation: "The top chunk is the allocator's remaining heap space.",
  },
  {
    id: 16,
    topic: "Allocator",
    question: "Consolidation means:",
    options: ["Merging adjacent free chunks", "Encrypting heap data", "Allocating huge pages", "Clearing tcache"],
    correctAnswer: 0,
    explanation: "Consolidation reduces fragmentation.",
  },
  {
    id: 17,
    topic: "Workflow",
    question: "Heap grooming (feng shui) is used to:",
    options: ["Arrange allocations for predictable layout", "Disable ASLR", "Strip symbols", "Remove canaries"],
    correctAnswer: 0,
    explanation: "Grooming shapes heap layout to aid exploitation.",
  },
  {
    id: 18,
    topic: "Goals",
    question: "An information leak is used to:",
    options: ["Reveal heap or libc addresses", "Encrypt pointers", "Disable logging", "Increase ASLR entropy"],
    correctAnswer: 0,
    explanation: "Leaks provide addresses for bypassing ASLR.",
  },
  {
    id: 19,
    topic: "Goals",
    question: "A write-what-where primitive means:",
    options: ["Ability to write attacker-controlled data to a chosen address", "Only read memory", "Only crash the program", "Only allocate memory"],
    correctAnswer: 0,
    explanation: "Write-what-where is a powerful exploitation primitive.",
  },
  {
    id: 20,
    topic: "Goals",
    question: "Control flow hijack can be achieved by:",
    options: ["Overwriting function pointers or vtables", "Only leaking addresses", "Only reading memory", "Only filling tcache"],
    correctAnswer: 0,
    explanation: "Corrupting control pointers redirects execution.",
  },
  {
    id: 21,
    topic: "Hooks",
    question: "glibc hooks are:",
    options: ["Function pointers used by malloc/free internals", "Kernel syscalls", "CPU registers", "Network handlers"],
    correctAnswer: 0,
    explanation: "Hooks are internal function pointers in libc.",
  },
  {
    id: 22,
    topic: "Hardening",
    question: "Safe-linking protects:",
    options: ["Freelist pointers from easy corruption", "Stack canaries", "GOT entries", "ASLR entropy"],
    correctAnswer: 0,
    explanation: "Safe-linking XOR-masks freelist pointers.",
  },
  {
    id: 23,
    topic: "Hardening",
    question: "Safe-linking uses:",
    options: ["XOR with a heap-derived value", "AES encryption", "RSA signatures", "Random file names"],
    correctAnswer: 0,
    explanation: "Pointers are masked with a heap-based value.",
  },
  {
    id: 24,
    topic: "tcache",
    question: "Tcache freelists are typically:",
    options: ["Singly linked lists", "Doubly linked lists", "Trees", "Hash tables"],
    correctAnswer: 0,
    explanation: "tcache uses singly linked lists per size.",
  },
  {
    id: 25,
    topic: "Fastbins",
    question: "Fastbins are typically:",
    options: ["Singly linked lists", "Only arrays", "Trees", "Stacks of pages"],
    correctAnswer: 0,
    explanation: "Fastbins are singly linked for speed.",
  },
  {
    id: 26,
    topic: "Bins",
    question: "Large bins are usually:",
    options: ["Sorted by size", "Unsorted only", "FIFO only", "Randomized"],
    correctAnswer: 0,
    explanation: "Large bins maintain size ordering.",
  },
  {
    id: 27,
    topic: "Alignment",
    question: "Chunk sizes are aligned to:",
    options: ["Allocator alignment (often 16 bytes on 64-bit)", "1 byte only", "3 bytes", "64 bytes only"],
    correctAnswer: 0,
    explanation: "Alignment affects size classes and layout.",
  },
  {
    id: 28,
    topic: "Metadata",
    question: "Chunk size fields typically include:",
    options: ["Flag bits in the low bits", "Only raw size", "Only pointer values", "Only checksum data"],
    correctAnswer: 0,
    explanation: "Low bits store flags like prev_inuse.",
  },
  {
    id: 29,
    topic: "Allocator",
    question: "The unsorted bin can leak:",
    options: ["libc pointers", "TLS keys", "Kernel secrets", "BIOS settings"],
    correctAnswer: 0,
    explanation: "Unsorted bin metadata often points into libc.",
  },
  {
    id: 30,
    topic: "Allocator",
    question: "Large allocations are often served by:",
    options: ["mmap", "tcache", "fastbins", "small bins only"],
    correctAnswer: 0,
    explanation: "Very large chunks are typically mmap-ed.",
  },
  {
    id: 31,
    topic: "Techniques",
    question: "Overlapping chunks allow:",
    options: ["Corruption across two views of memory", "Only read access", "Only heap growth", "Only faster allocation"],
    correctAnswer: 0,
    explanation: "Overlaps can enable controlled overwrites.",
  },
  {
    id: 32,
    topic: "House of",
    question: "House of Force aims to:",
    options: ["Overwrite top chunk size for arbitrary allocation", "Disable ASLR", "Create a new stack", "Patch the kernel"],
    correctAnswer: 0,
    explanation: "House of Force abuses the top chunk size.",
  },
  {
    id: 33,
    topic: "House of",
    question: "House of Spirit involves:",
    options: ["Freeing a fake chunk to get a controlled allocation", "Leaking stack data", "Breaking canaries", "Disabling NX"],
    correctAnswer: 0,
    explanation: "A fake chunk can be inserted into bins.",
  },
  {
    id: 34,
    topic: "House of",
    question: "House of Einherjar uses:",
    options: ["A null byte overflow to clear prev_inuse", "A format string", "A ROP chain", "A sysctl tweak"],
    correctAnswer: 0,
    explanation: "Clearing prev_inuse can force consolidation.",
  },
  {
    id: 35,
    topic: "Primitives",
    question: "Tcache poisoning requires the ability to:",
    options: ["Write into freed chunk metadata", "Read only memory", "Control only stack", "Disable PIE"],
    correctAnswer: 0,
    explanation: "You must corrupt freelist pointers.",
  },
  {
    id: 36,
    topic: "Primitives",
    question: "A UAF can become exploitable when:",
    options: ["The freed chunk is reallocated with attacker data", "The pointer is null", "ASLR is enabled", "NX is disabled"],
    correctAnswer: 0,
    explanation: "Reallocation lets the attacker control data.",
  },
  {
    id: 37,
    topic: "Primitives",
    question: "Heap spraying is used to:",
    options: ["Increase predictability of heap layout", "Reduce heap size", "Disable allocators", "Stop crashes"],
    correctAnswer: 0,
    explanation: "Spraying fills memory with controlled data.",
  },
  {
    id: 38,
    topic: "Mitigations",
    question: "ASLR helps by:",
    options: ["Randomizing heap and libc addresses", "Disabling heap", "Encrypting pointers", "Removing bins"],
    correctAnswer: 0,
    explanation: "Randomization makes addresses harder to guess.",
  },
  {
    id: 39,
    topic: "Mitigations",
    question: "RELRO helps by:",
    options: ["Protecting GOT from overwrites", "Disabling heap", "Encrypting stack", "Adding tcache"],
    correctAnswer: 0,
    explanation: "RELRO hardens relocation tables.",
  },
  {
    id: 40,
    topic: "Mitigations",
    question: "NX helps by:",
    options: ["Preventing execution from data pages", "Doubling heap size", "Removing free", "Enabling fastbins"],
    correctAnswer: 0,
    explanation: "NX blocks executing injected payloads.",
  },
  {
    id: 41,
    topic: "Mitigations",
    question: "Hardened allocators include:",
    options: ["Scudo and Hardened Malloc", "Only ptmalloc2", "Only dlmalloc", "Only jemalloc"],
    correctAnswer: 0,
    explanation: "Hardened allocators add security checks.",
  },
  {
    id: 42,
    topic: "Mitigations",
    question: "ASan is useful because it:",
    options: ["Detects heap overflows and UAFs", "Disables tcache", "Removes symbols", "Adds gadgets"],
    correctAnswer: 0,
    explanation: "ASan detects many heap bugs at runtime.",
  },
  {
    id: 43,
    topic: "Allocator",
    question: "ptmalloc is the allocator used by:",
    options: ["glibc", "Python only", "Windows only", "Java only"],
    correctAnswer: 0,
    explanation: "glibc uses ptmalloc2.",
  },
  {
    id: 44,
    topic: "Allocator",
    question: "Allocator behavior matters because:",
    options: ["Exploitation depends on version and hardening", "It never changes", "It only affects speed", "It removes bugs"],
    correctAnswer: 0,
    explanation: "Different versions change exploitability.",
  },
  {
    id: 45,
    topic: "Metadata",
    question: "The prev_size field is meaningful when:",
    options: ["The previous chunk is free", "The previous chunk is in use", "ASLR is disabled", "tcache is full"],
    correctAnswer: 0,
    explanation: "prev_size is used during consolidation.",
  },
  {
    id: 46,
    topic: "Metadata",
    question: "The unlink attack abuses:",
    options: ["Doubly linked bin pointers", "TLS keys", "CPU registers", "Syscall numbers"],
    correctAnswer: 0,
    explanation: "Unlink uses fd/bk pointer manipulation.",
  },
  {
    id: 47,
    topic: "Hardening",
    question: "Safe unlink checks are used to:",
    options: ["Prevent arbitrary pointer writes", "Disable ASLR", "Speed up malloc", "Increase heap size"],
    correctAnswer: 0,
    explanation: "Checks validate list pointers during unlinking.",
  },
  {
    id: 48,
    topic: "Allocator",
    question: "The top chunk grows via:",
    options: ["brk/sbrk", "fork", "execve", "mprotect"],
    correctAnswer: 0,
    explanation: "brk adjusts the program break for heap growth.",
  },
  {
    id: 49,
    topic: "Bins",
    question: "tcache reduces:",
    options: ["Allocator contention and overhead", "ASLR entropy", "Heap size", "Debug symbols"],
    correctAnswer: 0,
    explanation: "tcache speeds allocations by caching frees.",
  },
  {
    id: 50,
    topic: "Bins",
    question: "Fastbins differ from tcache because:",
    options: ["Fastbins are global while tcache is per-thread", "Fastbins are only for large chunks", "Fastbins are sorted by size", "Fastbins use encryption"],
    correctAnswer: 0,
    explanation: "Fastbins are global; tcache is per-thread.",
  },
  {
    id: 51,
    topic: "Bugs",
    question: "Corrupting the size field can lead to:",
    options: ["Arbitrary allocation or overlap", "Stronger ASLR", "Smaller binaries", "Better logging"],
    correctAnswer: 0,
    explanation: "Fake sizes can redirect allocator behavior.",
  },
  {
    id: 52,
    topic: "Bugs",
    question: "A freed chunk reused by the attacker leads to:",
    options: ["Use-after-free exploitation", "Automatic patching", "Improved ASLR", "Reduced coverage"],
    correctAnswer: 0,
    explanation: "Reallocation lets the attacker control data.",
  },
  {
    id: 53,
    topic: "Leaks",
    question: "Heap metadata often contains:",
    options: ["Pointers that can leak addresses", "Passwords by default", "TLS keys by default", "Only zeros"],
    correctAnswer: 0,
    explanation: "Metadata pointers can reveal base addresses.",
  },
  {
    id: 54,
    topic: "Overlaps",
    question: "Overlapping chunks can enable:",
    options: ["Writing into another object's data", "Only faster allocation", "Only stack growth", "Only heap shrinking"],
    correctAnswer: 0,
    explanation: "Overlaps allow cross-object corruption.",
  },
  {
    id: 55,
    topic: "Versioning",
    question: "Heap exploitation often depends on:",
    options: ["glibc version and configuration", "CPU model only", "Compiler warnings only", "Kernel uptime only"],
    correctAnswer: 0,
    explanation: "Allocator changes affect primitives.",
  },
  {
    id: 56,
    topic: "Hardening",
    question: "Safe-linking makes tcache poisoning harder by:",
    options: ["Masking pointers with heap-derived values", "Disabling free", "Removing chunks", "Changing the ABI"],
    correctAnswer: 0,
    explanation: "Masked pointers are harder to forge.",
  },
  {
    id: 57,
    topic: "Tools",
    question: "pwndbg and GEF are:",
    options: ["GDB extensions for exploit debugging", "Fuzzers", "Web scanners", "Kernel modules"],
    correctAnswer: 0,
    explanation: "They enhance GDB for exploitation work.",
  },
  {
    id: 58,
    topic: "Tools",
    question: "how2heap provides:",
    options: ["Examples of heap exploitation techniques", "Only static analysis", "Kernel patches", "Network captures"],
    correctAnswer: 0,
    explanation: "how2heap documents common heap techniques.",
  },
  {
    id: 59,
    topic: "Bugs",
    question: "Read-after-free can lead to:",
    options: ["Information disclosure", "Automatic mitigation", "No impact", "Only logging noise"],
    correctAnswer: 0,
    explanation: "Reading freed memory can leak sensitive data.",
  },
  {
    id: 60,
    topic: "Metadata",
    question: "Chunk metadata is typically located:",
    options: ["Just before user data", "At the end of the binary", "In CPU registers", "In kernel memory only"],
    correctAnswer: 0,
    explanation: "Headers precede the user allocation.",
  },
  {
    id: 61,
    topic: "Bugs",
    question: "Type confusion via UAF occurs when:",
    options: ["Freed memory is reused with a different object type", "Memory is zeroed", "Pointer is null", "Stack is empty"],
    correctAnswer: 0,
    explanation: "Reused memory can be interpreted as another type.",
  },
  {
    id: 62,
    topic: "Workflow",
    question: "A common first step is to:",
    options: ["Find a controllable heap bug", "Disable ASLR", "Remove symbols", "Patch the kernel"],
    correctAnswer: 0,
    explanation: "Exploitation starts with a heap corruption primitive.",
  },
  {
    id: 63,
    topic: "Bins",
    question: "Small bins are typically:",
    options: ["Size-segregated lists for medium chunks", "Only for huge chunks", "Only for mmap", "Only for tcache"],
    correctAnswer: 0,
    explanation: "Small bins handle medium-sized freed chunks.",
  },
  {
    id: 64,
    topic: "Bins",
    question: "Large bins are used for:",
    options: ["Larger freed chunks sorted by size", "Only tiny chunks", "Only stack buffers", "Only tcache entries"],
    correctAnswer: 0,
    explanation: "Large bins hold large, size-sorted chunks.",
  },
  {
    id: 65,
    topic: "Hardening",
    question: "Allocator checks can detect:",
    options: ["Double frees and corruption", "SQL injection", "CSRF", "TLS errors"],
    correctAnswer: 0,
    explanation: "Checks help catch invalid frees and metadata issues.",
  },
  {
    id: 66,
    topic: "Bugs",
    question: "A fake chunk attack generally requires:",
    options: ["Crafting plausible chunk metadata", "Only a hash leak", "Only a DNS leak", "Only a format string"],
    correctAnswer: 0,
    explanation: "Metadata must look valid to the allocator.",
  },
  {
    id: 67,
    topic: "Allocator",
    question: "tcache limits mean:",
    options: ["Only a small number of chunks per size are cached", "All chunks are cached forever", "No chunks are cached", "Only large chunks are cached"],
    correctAnswer: 0,
    explanation: "tcache keeps a small per-size list.",
  },
  {
    id: 68,
    topic: "Hardening",
    question: "Removing unused libraries helps because:",
    options: ["It reduces available gadgets and targets", "It disables ASLR", "It increases heap size", "It removes tcache"],
    correctAnswer: 0,
    explanation: "Fewer code targets reduces attack surface.",
  },
  {
    id: 69,
    topic: "Allocator",
    question: "Heap fragmentation can be reduced by:",
    options: ["Consolidation and size-aware allocation", "Disabling free", "Disabling malloc", "Only using mmap"],
    correctAnswer: 0,
    explanation: "Consolidation merges free chunks.",
  },
  {
    id: 70,
    topic: "Bugs",
    question: "Heap overflow can enable:",
    options: ["Freelist corruption and arbitrary allocation", "Automatic patching", "Stronger canaries", "More ASLR"],
    correctAnswer: 0,
    explanation: "Overflows can corrupt allocator metadata.",
  },
  {
    id: 71,
    topic: "Primitives",
    question: "A common exploitation primitive is:",
    options: ["Arbitrary write", "Only log reading", "Only timing", "Only string compare"],
    correctAnswer: 0,
    explanation: "Arbitrary write enables control over program state.",
  },
  {
    id: 72,
    topic: "Allocator",
    question: "Safe-linking uses pointer XOR with:",
    options: ["A shifted heap address", "A fixed constant only", "A random disk value", "A DNS response"],
    correctAnswer: 0,
    explanation: "glibc uses heap address shifting for masking.",
  },
  {
    id: 73,
    topic: "Hardening",
    question: "Modern glibc hardening makes:",
    options: ["Older heap exploits less reliable", "ASLR unnecessary", "NX irrelevant", "All bugs harmless"],
    correctAnswer: 0,
    explanation: "Hardening increases exploit complexity.",
  },
  {
    id: 74,
    topic: "Workflow",
    question: "After gaining a write primitive, attackers often:",
    options: ["Overwrite a function pointer or hook", "Disable free", "Remove logs", "Reboot the host"],
    correctAnswer: 0,
    explanation: "Control pointers enable execution redirection.",
  },
  {
    id: 75,
    topic: "Workflow",
    question: "Heap exploitation requires careful:",
    options: ["Understanding of allocator internals", "DNS configuration", "TLS certificates", "UI themes"],
    correctAnswer: 0,
    explanation: "Allocator behavior drives exploit strategy.",
  },
];

// Heap Feng Shui strategies
const heapFengShuiStrategies = [
  {
    strategy: "Hole Creation",
    description: "Create specific-sized gaps in the heap for target allocations",
    approach: "Allocate many chunks, free every Nth chunk to create holes",
    useCase: "Position vulnerable chunk next to target chunk",
    difficulty: "Medium",
    example: "Allocate 10 chunks, free chunks 2, 5, 8 to create 3 holes",
  },
  {
    strategy: "Chunk Alignment",
    description: "Ensure chunks align at specific offsets for overflow targets",
    approach: "Use size-specific allocations to control placement",
    useCase: "Align chunk headers for metadata corruption",
    difficulty: "High",
    example: "Allocate 0x88-sized chunks to ensure 16-byte alignment",
  },
  {
    strategy: "Adjacency Control",
    description: "Position two specific chunks adjacent to each other",
    approach: "Allocate victim, allocate target, free victim, reallocate",
    useCase: "Place overflow source next to target chunk",
    difficulty: "Medium",
    example: "malloc(A), malloc(B), free(A), malloc(C) -> C takes A's spot",
  },
  {
    strategy: "Freelist Priming",
    description: "Populate specific bins/tcaches with desired chunks",
    approach: "Free chunks of specific sizes to populate freelists",
    useCase: "Ensure next allocation comes from controlled freelist",
    difficulty: "Low",
    example: "Free 7x 0x90-sized chunks to fill tcache for that size",
  },
  {
    strategy: "Arena Selection",
    description: "Force allocations into specific arenas (multi-threaded)",
    approach: "Use thread affinity to control which arena services allocation",
    useCase: "Isolate exploit activity to one arena",
    difficulty: "Very High",
    example: "Create threads pinned to CPUs, use thread-local allocations",
  },
  {
    strategy: "Consolidation Prevention",
    description: "Prevent unwanted chunk merging during free",
    approach: "Maintain allocated sentinels between free chunks",
    useCase: "Keep target chunks at specific sizes",
    difficulty: "Medium",
    example: "malloc(A), malloc(SENTINEL), malloc(B) -> free(A) won't merge with B",
  },
];

// Bin management details
const binManagementDetails = [
  {
    binType: "tcache (Thread Cache)",
    sizeRange: "Up to 1032 bytes (0x408)",
    count: "64 bins (one per size class)",
    structure: "Singly-linked LIFO list",
    maxPerBin: "7 chunks (default)",
    unlinkingChecks: "Minimal (key check since 2.29)",
    behavior: "LIFO - Last freed is first allocated",
    coalescing: "No coalescing",
    safetyFeatures: "Safe-linking (2.32+), tcache key (2.29+)",
    notes: "Fastest path, per-thread, no locking required",
  },
  {
    binType: "fastbins",
    sizeRange: "16 to 176 bytes (0x10-0xB0) on 64-bit",
    count: "10 bins",
    structure: "Singly-linked LIFO list",
    maxPerBin: "Unlimited",
    unlinkingChecks: "Minimal size validation",
    behavior: "LIFO - Last freed is first allocated",
    coalescing: "Deferred until malloc_consolidate()",
    safetyFeatures: "Safe-linking (2.32+), size checks",
    notes: "Global, never consolidated automatically with neighbors",
  },
  {
    binType: "smallbins",
    sizeRange: "Less than 1024 bytes, not in fastbins/tcache",
    count: "62 bins (sizes 16, 24, 32... 1016 bytes)",
    structure: "Doubly-linked circular list",
    maxPerBin: "Unlimited",
    unlinkingChecks: "Safe unlinking (fd->bk == chunk && bk->fd == chunk)",
    behavior: "FIFO - First freed is first allocated",
    coalescing: "Immediate with adjacent free chunks",
    safetyFeatures: "Safe unlinking, size validation",
    notes: "Exact size match required, fast allocation",
  },
  {
    binType: "largebins",
    sizeRange: "Greater than or equal to 1024 bytes",
    count: "63 bins (size ranges: 1024-1088, 1088-1152... 512KB+)",
    structure: "Doubly-linked sorted list with fd_nextsize/bk_nextsize",
    maxPerBin: "Unlimited, sorted by size descending",
    unlinkingChecks: "Safe unlinking + nextsize pointer validation",
    behavior: "Best-fit - Smallest sufficient chunk allocated",
    coalescing: "Immediate with adjacent free chunks",
    safetyFeatures: "Safe unlinking, extensive size validation, sorted integrity",
    notes: "Most complex structure, slowest allocation path",
  },
  {
    binType: "unsorted bin",
    sizeRange: "All sizes (temporary storage)",
    count: "1 bin (circular doubly-linked)",
    structure: "Doubly-linked circular list",
    maxPerBin: "Unlimited",
    unlinkingChecks: "Safe unlinking",
    behavior: "FIFO - Recently freed chunks cached before sorting",
    coalescing: "During sorting phase",
    safetyFeatures: "Safe unlinking",
    notes: "Intermediate cache, chunks sorted into small/large bins on next malloc",
  },
];

// Advanced debugging commands
const debuggingCommands = [
  {
    tool: "pwndbg",
    command: "heap",
    description: "Display all heap chunks with addresses, sizes, and status",
    example: "heap -v",
    output: "Detailed chunk listing with flags",
  },
  {
    tool: "pwndbg",
    command: "bins",
    description: "Show all bin states (tcache, fastbins, small, large, unsorted)",
    example: "bins",
    output: "Complete freelist state with chain visualization",
  },
  {
    tool: "pwndbg",
    command: "vis_heap_chunks",
    description: "Visual ASCII art representation of heap layout",
    example: "vis_heap_chunks",
    output: "ASCII diagram showing chunk boundaries and relationships",
  },
  {
    tool: "pwndbg",
    command: "tcache",
    description: "Display tcache freelist state for all size classes",
    example: "tcache",
    output: "Per-size tcache chains with counts",
  },
  {
    tool: "pwndbg",
    command: "fastbins",
    description: "Show fastbin freelist chains",
    example: "fastbins",
    output: "Fastbin chains for each size class",
  },
  {
    tool: "pwndbg",
    command: "arenas",
    description: "List all malloc arenas (main + thread arenas)",
    example: "arenas",
    output: "Arena addresses and basic stats",
  },
  {
    tool: "pwndbg",
    command: "malloc_chunk",
    description: "Parse and display chunk structure at address",
    example: "malloc_chunk 0x555555756000",
    output: "Formatted chunk header fields",
  },
  {
    tool: "GEF",
    command: "heap chunks",
    description: "List all heap chunks with metadata",
    example: "heap chunks arena",
    output: "Chunk enumeration with colors",
  },
  {
    tool: "GEF",
    command: "heap bins",
    description: "Display bin states",
    example: "heap bins fast",
    output: "Specific bin type analysis",
  },
  {
    tool: "GEF",
    command: "heap arenas",
    description: "Show arena information",
    example: "heap arenas",
    output: "Arena addresses and structure",
  },
  {
    tool: "GDB",
    command: "x/20gx <addr>",
    description: "Examine memory as 64-bit hex values",
    example: "x/20gx $heap_base",
    output: "Raw memory dump",
  },
  {
    tool: "GDB",
    command: "print *(struct malloc_chunk*)addr",
    description: "Print chunk structure fields",
    example: "p *(struct malloc_chunk*)0x555555756000",
    output: "Parsed chunk structure",
  },
];

// Common pitfalls
const commonPitfalls = [
  {
    category: "Heap State",
    mistake: "Not accounting for tcache",
    consequence: "Chunk goes to tcache instead of intended bin",
    solution: "Fill tcache (7 chunks) before freeing to target bin",
    frequency: "Very Common",
  },
  {
    category: "Heap State",
    mistake: "Unexpected consolidation",
    consequence: "Chunks merge, destroying groomed layout",
    solution: "Place allocated sentinels to prevent merging",
    frequency: "Common",
  },
  {
    category: "Heap State",
    mistake: "Wrong chunk size calculation",
    consequence: "Allocation comes from unexpected bin",
    solution: "Account for header size and alignment (minimum 32 bytes on 64-bit)",
    frequency: "Common",
  },
  {
    category: "Primitives",
    mistake: "Forgetting safe-linking XOR mask",
    consequence: "Freelist pointer corruption fails on glibc 2.32+",
    solution: "Leak heap address, calculate XOR mask: (addr >> 12) ^ ptr",
    frequency: "Very Common (modern glibc)",
  },
  {
    category: "Primitives",
    mistake: "Not setting tcache key",
    consequence: "Double-free detected on glibc 2.29+",
    solution: "Overwrite tcache key field or use different free path",
    frequency: "Common (glibc 2.29+)",
  },
  {
    category: "Primitives",
    mistake: "Invalid chunk size during fake chunk",
    consequence: "Allocator crashes or rejects allocation",
    solution: "Ensure size is aligned, has PREV_INUSE set, and matches bin expectations",
    frequency: "Very Common",
  },
  {
    category: "Information Leaks",
    mistake: "Not checking for PIE/ASLR",
    consequence: "Hardcoded addresses fail in production",
    solution: "Always leak heap/libc base, calculate offsets dynamically",
    frequency: "Common",
  },
  {
    category: "Information Leaks",
    mistake: "Insufficient leak granularity",
    consequence: "Can leak libc but not heap, or vice versa",
    solution: "Develop separate leak primitives for heap and libc",
    frequency: "Common",
  },
  {
    category: "Timing",
    mistake: "Race conditions in multithreaded programs",
    consequence: "Heap state changes between steps",
    solution: "Use single-threaded context or atomic operations",
    frequency: "Uncommon but Critical",
  },
  {
    category: "Debugging",
    mistake: "Testing with ASan/debug allocator",
    consequence: "Exploit works in testing, fails in production",
    solution: "Test against actual target allocator version",
    frequency: "Common",
  },
  {
    category: "Validation",
    mistake: "Not handling allocation failures",
    consequence: "Null pointer dereference crashes exploit",
    solution: "Check malloc return values, handle OOM gracefully",
    frequency: "Uncommon",
  },
];

// Case studies data
const caseStudies = [
  {
    id: 1,
    name: "CVE-2021-3156: Sudo Heap Overflow (Baron Samedit)",
    severity: "Critical",
    cve: "CVE-2021-3156",
    year: "2021",
    affectedSoftware: "sudo versions 1.8.2-1.8.31p2, 1.9.0-1.9.5p1",
    vulnerabilityType: "Heap-based buffer overflow",
    description: "A heap-based buffer overflow in sudo's command line parsing allowed any local user to gain root privileges without authentication. The vulnerability existed in the way sudo handled backslash characters in the command line when running in shell mode (sudo -s or sudo -i). When a command line ended with a single backslash, sudo would overflow a heap buffer while unescaping the backslash character.",
    technicalDetails: [
      "Off-by-one heap overflow in set_cmnd() function",
      "Triggered by crafting command with single trailing backslash",
      "Overflow occurs during argument unescaping in shell mode",
      "Can overwrite adjacent heap chunk metadata",
      "Service_user structure contains function pointers targetable via overflow",
    ],
    exploitationSteps: [
      "Invoke sudo with -s flag to enable shell mode",
      "Craft command argument ending with single backslash (e.g., 'sudoedit -s \\')",
      "Overflow triggers in command parsing, writing beyond buffer boundary",
      "Groom heap to position service_user structure adjacent to overflow buffer",
      "Overflow overwrites service_user.debug_level and service_user.close function pointer",
      "Trigger function pointer call to hijack control flow",
      "Chain with ROP or direct shellcode to achieve privilege escalation",
    ],
    mitigations: [
      "Update sudo to version 1.9.5p2 or later",
      "Off-by-one fixed by correcting buffer size calculation",
      "Additional bounds checking in argument parsing",
      "Modern distributions use ASLR + PIE making exploitation harder",
    ],
    impact: "Any local user could gain root shell on vulnerable systems. Affected most Linux/Unix systems worldwide for 10+ years.",
    references: ["https://nvd.nist.gov/vuln/detail/CVE-2021-3156", "Qualys Security Advisory"],
  },
  {
    id: 2,
    name: "CVE-2014-0160: OpenSSL Heartbleed",
    severity: "Critical",
    cve: "CVE-2014-0160",
    year: "2014",
    affectedSoftware: "OpenSSL 1.0.1 through 1.0.1f",
    vulnerabilityType: "Heap over-read / Information disclosure",
    description: "Heartbleed was a heap buffer over-read vulnerability in OpenSSL's implementation of the TLS heartbeat extension. An attacker could read up to 64KB of process memory per heartbeat request, potentially exposing sensitive data including private keys, session tokens, passwords, and other secrets. While primarily an information disclosure bug, it demonstrates heap exploitation in cryptographic software.",
    technicalDetails: [
      "Missing bounds check in dtls1_process_heartbeat() and tls1_process_heartbeat()",
      "Attacker controls payload length in heartbeat request",
      "Server allocates buffer based on attacker-supplied length without validation",
      "memcpy() reads beyond actual payload data into adjacent heap memory",
      "Leaked memory returned to attacker in heartbeat response",
    ],
    exploitationSteps: [
      "Send TLS heartbeat request with payload_length=65535 but actual_payload=1 byte",
      "Server allocates 65535-byte buffer for response",
      "Server copies 1 byte of payload, then continues copying 65534 bytes of adjacent heap memory",
      "Heap memory may contain private keys, session cookies, user credentials, or other processes' data",
      "Receive heartbeat response containing leaked memory",
      "Repeat requests to sample different heap regions",
      "Extract sensitive data from leaked memory dumps",
    ],
    mitigations: [
      "Update OpenSSL to 1.0.1g or later",
      "Bounds check added to validate payload length matches actual data",
      "Revoke and reissue SSL certificates that may have been exposed",
      "Reset user passwords and session tokens",
      "ASLR helps randomize heap layout but doesn't prevent leak",
    ],
    impact: "Information disclosure vulnerability affecting ~17% of Internet's secure web servers. Leaked private keys compromised PKI trust model.",
    references: ["https://nvd.nist.gov/vuln/detail/CVE-2014-0160", "http://heartbleed.com/"],
  },
  {
    id: 3,
    name: "CVE-2019-11707: Firefox Type Confusion UAF",
    severity: "Critical",
    cve: "CVE-2019-11707",
    year: "2019",
    affectedSoftware: "Firefox < 67.0.4, Firefox ESR < 60.7.1",
    vulnerabilityType: "Type confusion leading to use-after-free",
    description: "A type confusion vulnerability in Firefox's Array.pop() JavaScript implementation could lead to a use-after-free condition. By manipulating JavaScript arrays in specific ways, an attacker could cause the browser to access freed memory, leading to arbitrary code execution within the context of the browser process. This vulnerability was exploited in targeted attacks in the wild.",
    technicalDetails: [
      "Type confusion in JIT-compiled Array.pop() handling",
      "Improper handling of array length during element removal",
      "Shape/type guard incorrectly optimized away in JIT code",
      "Allows ArrayBuffer to be freed while still referenced",
      "Freed memory reallocated with attacker-controlled data",
    ],
    exploitationSteps: [
      "Create JavaScript array with specific element types",
      "Trigger JIT compilation with repeated Array.pop() calls",
      "Exploit type confusion to create dangling pointer to ArrayBuffer",
      "Free the ArrayBuffer while retaining reference via confused type",
      "Trigger allocation of controlled data (e.g., array of objects)",
      "Reallocated memory overlaps with freed ArrayBuffer location",
      "Use dangling reference to read/write attacker-controlled objects",
      "Leak browser heap addresses to defeat ASLR",
      "Overwrite JavaScript object vtable or function pointer",
      "Achieve arbitrary code execution via hijacked control flow",
    ],
    mitigations: [
      "Update Firefox to version 67.0.4 or later (ESR 60.7.1+)",
      "Improved type guards in JIT compiler",
      "Enhanced shape verification during array operations",
      "Browser sandboxing limits impact of code execution",
      "Site Isolation mitigates cross-origin data leakage",
    ],
    impact: "Remote code execution via malicious web page. Used in targeted attacks by APT groups.",
    references: ["https://nvd.nist.gov/vuln/detail/CVE-2019-11707", "Mozilla Security Advisory 2019-18"],
  },
  {
    id: 4,
    name: "CVE-2016-4657: Safari Use-After-Free (Pegasus)",
    severity: "Critical",
    cve: "CVE-2016-4657",
    year: "2016",
    affectedSoftware: "iOS 9.3.4 and earlier, macOS Safari",
    vulnerabilityType: "WebKit use-after-free",
    description: "Part of the Pegasus spyware exploit chain, this WebKit vulnerability allowed remote code execution through a use-after-free in JavaScript's Array.prototype.slice(). The vulnerability was used in targeted attacks to compromise iPhones via malicious links. It demonstrated advanced heap exploitation techniques including heap feng shui and type confusion.",
    technicalDetails: [
      "Use-after-free in Array.prototype.slice() implementation",
      "Incorrect lifetime management of JavaScript objects during slice operation",
      "Freed JSArray object accessed after garbage collection",
      "Heap grooming used to control freed memory contents",
      "Type confusion achieved via UAF to corrupt object metadata",
    ],
    exploitationSteps: [
      "Craft JavaScript that triggers Array.slice() on specially constructed array",
      "Trigger garbage collection during slice operation to free backing storage",
      "Retain reference to sliced array (use-after-free)",
      "Heap spray to fill freed region with controlled JavaScript objects",
      "Access freed array to read/write controlled objects (type confusion)",
      "Leak WebKit heap and code addresses through object introspection",
      "Construct fake JavaScript object with controlled vtable pointer",
      "Trigger virtual method call on fake object to hijack control flow",
      "ROP chain to disable DEP/W^X protections",
      "Execute shellcode to install Pegasus spyware",
    ],
    mitigations: [
      "Update iOS to 9.3.5 or later",
      "Fixed object lifetime management in Array.slice()",
      "Enhanced garbage collection timing to prevent UAF windows",
      "Improved WebKit heap isolation and randomization",
      "Pointer authentication (PAC) on newer iOS devices mitigates control flow hijacking",
    ],
    impact: "Part of zero-click exploit chain used by NSO Group's Pegasus spyware. Compromised high-value targets including journalists and activists.",
    references: ["https://nvd.nist.gov/vuln/detail/CVE-2016-4657", "Citizen Lab Pegasus Report"],
  },
];

// Section navigation
const sectionNavItems = [
  { id: "intro", label: "Introduction", icon: "" },
  { id: "allocators", label: "Heap Allocators", icon: "" },
  { id: "feng-shui", label: "Heap Feng Shui", icon: "" },
  { id: "metadata", label: "Metadata Structures", icon: "" },
  { id: "bins", label: "Bin Management", icon: "" },
  { id: "techniques", label: "Exploit Techniques", icon: "" },
  { id: "pitfalls", label: "Common Pitfalls", icon: "" },
  { id: "heap-spray", label: "Heap Spray Details", icon: "" },
  { id: "house-of", label: "House of Techniques", icon: "" },
  { id: "workflow", label: "Exploitation Workflow", icon: "" },
  { id: "debugging", label: "Advanced Debugging", icon: "" },
  { id: "case-studies", label: "Case Studies", icon: "" },
  { id: "mitigations", label: "Mitigations", icon: "" },
  { id: "tools", label: "Tools", icon: "" },
  { id: "quiz", label: "Knowledge Check", icon: "" },
];

export default function HeapExploitationPage() {
  const navigate = useNavigate();
  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down("md"));
  const [activeSection, setActiveSection] = useState("intro");
  const [showScrollTop, setShowScrollTop] = useState(false);

  const pageContext = `Heap Exploitation Techniques - Comprehensive guide covering heap memory corruption, dynamic allocator internals, exploitation primitives (UAF, double-free, overflow), House of techniques, tcache/fastbin attacks, safe-linking bypass, heap grooming, and modern mitigations. Includes detailed metadata structures, workflow, tools (pwndbg, GEF, pwntools), and practical exploitation strategies for ptmalloc2, jemalloc, and hardened allocators.`;

  const accent = "#ef4444";

  // Scroll tracking
  useEffect(() => {
    const handleScroll = () => {
      setShowScrollTop(window.scrollY > 400);

      const sections = sectionNavItems.map((item) => item.id);
      let currentSection = "intro";

      for (const sectionId of sections) {
        const element = document.getElementById(sectionId);
        if (element) {
          const rect = element.getBoundingClientRect();
          if (rect.top <= 150 && rect.bottom >= 150) {
            currentSection = sectionId;
            break;
          }
        }
      }
      setActiveSection(currentSection);
    };

    window.addEventListener("scroll", handleScroll);
    return () => window.removeEventListener("scroll", handleScroll);
  }, []);

  const scrollToSection = (id: string) => {
    const element = document.getElementById(id);
    if (element) {
      const offset = 80;
      const elementPosition = element.getBoundingClientRect().top + window.scrollY;
      window.scrollTo({ top: elementPosition - offset, behavior: "smooth" });
    }
  };

  const scrollToTop = () => {
    window.scrollTo({ top: 0, behavior: "smooth" });
  };

  const progressPercent = ((sectionNavItems.findIndex((item) => item.id === activeSection) + 1) / sectionNavItems.length) * 100;

  // Sidebar Navigation
  const sidebarNav = (
    <Paper
      elevation={0}
      sx={{
        position: "sticky",
        top: 80,
        width: 240,
        maxHeight: "calc(100vh - 100px)",
        overflowY: "auto",
        display: { xs: "none", md: "block" },
        borderRadius: 3,
        border: `1px solid ${alpha(theme.palette.divider, 0.1)}`,
        "&::-webkit-scrollbar": {
          width: 6,
        },
        "&::-webkit-scrollbar-thumb": {
          bgcolor: alpha(accent, 0.3),
          borderRadius: 3,
        },
      }}
    >
      <Box sx={{ p: 2 }}>
        <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 1, color: accent, display: "flex", alignItems: "center", gap: 1 }}>
          <ListAltIcon sx={{ fontSize: 18 }} />
          Course Navigation
        </Typography>
        <Box sx={{ mb: 2 }}>
          <Box sx={{ display: "flex", justifyContent: "space-between", mb: 0.5 }}>
            <Typography variant="caption" color="text.secondary">
              Progress
            </Typography>
            <Typography variant="caption" sx={{ fontWeight: 600, color: accent }}>
              {Math.round(progressPercent)}%
            </Typography>
          </Box>
          <LinearProgress
            variant="determinate"
            value={progressPercent}
            sx={{
              height: 6,
              borderRadius: 3,
              bgcolor: alpha(accent, 0.1),
              "& .MuiLinearProgress-bar": {
                bgcolor: accent,
                borderRadius: 3,
              },
            }}
          />
        </Box>
        <Divider sx={{ mb: 1 }} />
        <List dense sx={{ mx: -1 }}>
          {sectionNavItems.map((item) => (
            <ListItem
              key={item.id}
              onClick={() => scrollToSection(item.id)}
              sx={{
                borderRadius: 1.5,
                mb: 0.25,
                py: 0.5,
                cursor: "pointer",
                bgcolor: activeSection === item.id ? alpha(accent, 0.15) : "transparent",
                borderLeft: activeSection === item.id ? `3px solid ${accent}` : "3px solid transparent",
                "&:hover": {
                  bgcolor: alpha(accent, 0.08),
                },
                transition: "all 0.15s ease",
              }}
            >
              <ListItemIcon sx={{ minWidth: 24, fontSize: "0.9rem" }}>{item.icon}</ListItemIcon>
              <ListItemText
                primary={
                  <Typography
                    variant="caption"
                    sx={{
                      fontWeight: activeSection === item.id ? 700 : 500,
                      color: activeSection === item.id ? accent : "text.secondary",
                    }}
                  >
                    {item.label}
                  </Typography>
                }
              />
            </ListItem>
          ))}
        </List>
      </Box>
    </Paper>
  );

  return (
    <LearnPageLayout pageTitle="Heap Exploitation" pageContext={pageContext}>
      <Box sx={{ display: "flex", gap: 3, position: "relative" }}>
        {/* Sidebar Navigation */}
        {sidebarNav}

        {/* Main Content */}
        <Container maxWidth="lg" sx={{ py: 4, flex: 1 }}>
          {/* Back Button */}
          <Chip
            component={Link}
            to="/learn"
            icon={<ArrowBackIcon />}
            label="Back to Learning Hub"
            clickable
            variant="outlined"
            sx={{ borderRadius: 2, mb: 3 }}
          />

          {/* Hero Banner */}
          <Paper
            sx={{
              p: 4,
              mb: 4,
              borderRadius: 4,
              background: `linear-gradient(135deg, ${alpha("#ef4444", 0.15)} 0%, ${alpha("#dc2626", 0.1)} 100%)`,
              border: `1px solid ${alpha("#ef4444", 0.2)}`,
              position: "relative",
              overflow: "hidden",
            }}
          >
            <Box
              sx={{
                position: "absolute",
                top: -50,
                right: -50,
                width: 200,
                height: 200,
                borderRadius: "50%",
                background: `linear-gradient(135deg, ${alpha("#ef4444", 0.1)}, transparent)`,
              }}
            />
            <Box sx={{ display: "flex", alignItems: "center", gap: 3, position: "relative" }}>
              <Box
                sx={{
                  width: 80,
                  height: 80,
                  borderRadius: 3,
                  background: `linear-gradient(135deg, #ef4444, #dc2626)`,
                  display: "flex",
                  alignItems: "center",
                  justifyContent: "center",
                  boxShadow: `0 8px 32px ${alpha("#ef4444", 0.3)}`,
                }}
              >
                <MemoryIcon sx={{ fontSize: 45, color: "white" }} />
              </Box>
              <Box>
                <Chip label="Reverse Engineering" size="small" sx={{ mb: 1, fontWeight: 600, bgcolor: alpha("#ef4444", 0.1), color: "#ef4444" }} />
                <Typography variant="h3" sx={{ fontWeight: 800, mb: 1 }}>
                  Heap Exploitation
                </Typography>
                <Typography variant="h6" color="text.secondary" sx={{ maxWidth: 600 }}>
                  Master dynamic memory corruption and modern exploitation techniques
                </Typography>
              </Box>
            </Box>
          </Paper>

          {/* Overview Section */}
          <Box id="intro">
            <Paper
              sx={{
                p: 4,
                mb: 5,
                borderRadius: 4,
                bgcolor: alpha(theme.palette.background.paper, 0.6),
                border: `1px solid ${alpha(theme.palette.divider, 0.1)}`,
              }}
            >
              <Typography variant="h5" sx={{ fontWeight: 700, mb: 2, display: "flex", alignItems: "center", gap: 1 }}>
                <InfoIcon sx={{ color: "#ef4444" }} />
                Overview
              </Typography>
              <Typography variant="body1" sx={{ mb: 2, lineHeight: 1.8 }}>
                Heap exploitation is the art and science of corrupting dynamic memory allocators to achieve arbitrary code execution. Unlike stack-based
                vulnerabilities that target fixed-size buffers and return addresses, heap exploitation requires deep understanding of allocator internals,
                metadata structures, and memory management algorithms. The heap is where programs allocate memory at runtime using functions like malloc(),
                calloc(), realloc(), and free() in C, or new/delete in C++.
              </Typography>
              <Typography variant="body1" sx={{ mb: 2, lineHeight: 1.8 }}>
                Modern heap allocators like glibc's ptmalloc2, jemalloc, tcmalloc, and Windows NT Heap implement sophisticated data structures including
                freelists, bins, caches, and metadata to efficiently manage dynamic memory. These allocators balance performance, thread safety, and
                fragmentation avoidancebut their complexity creates attack surface. By corrupting allocator metadata, manipulating freelist pointers, or
                exploiting allocator logic, attackers can achieve powerful primitives like arbitrary write, overlapping allocations, and control flow hijacking.
              </Typography>
              <Typography variant="body1" sx={{ mb: 3, lineHeight: 1.8 }}>
                This guide provides a comprehensive exploration of heap exploitation techniques from fundamentals to advanced topics. You'll learn how heap
                allocators work, common vulnerability classes (use-after-free, double-free, heap overflow), classic and modern exploitation techniques
                (tcache poisoning, fastbin attacks, House of techniques), modern mitigations (safe-linking, tcache keys, ASLR), and practical tools for heap
                analysis and exploitation.
              </Typography>

              <Grid container spacing={2}>
                <Grid item xs={12} md={4}>
                  <Box sx={{ p: 2, borderRadius: 2, bgcolor: alpha("#10b981", 0.05), border: `1px solid ${alpha("#10b981", 0.2)}` }}>
                    <Typography variant="subtitle2" sx={{ fontWeight: 700, color: "#10b981", mb: 1 }}>
                      Who This Is For
                    </Typography>
                    <Typography variant="body2" color="text.secondary">
                      Binary exploitation researchers, CTF players, penetration testers, security engineers, and malware analysts who need to understand
                      memory corruption at the heap level.
                    </Typography>
                  </Box>
                </Grid>
                <Grid item xs={12} md={4}>
                  <Box sx={{ p: 2, borderRadius: 2, bgcolor: alpha("#3b82f6", 0.05), border: `1px solid ${alpha("#3b82f6", 0.2)}` }}>
                    <Typography variant="subtitle2" sx={{ fontWeight: 700, color: "#3b82f6", mb: 1 }}>
                      Prerequisites
                    </Typography>
                    <Typography variant="body2" color="text.secondary">
                      Strong C/C++ programming skills, understanding of pointers and memory management, familiarity with assembly language and debuggers (GDB),
                      knowledge of buffer overflows and basic exploitation concepts.
                    </Typography>
                  </Box>
                </Grid>
                <Grid item xs={12} md={4}>
                  <Box sx={{ p: 2, borderRadius: 2, bgcolor: alpha("#f59e0b", 0.05), border: `1px solid ${alpha("#f59e0b", 0.2)}` }}>
                    <Typography variant="subtitle2" sx={{ fontWeight: 700, color: "#f59e0b", mb: 1 }}>
                      What You'll Learn
                    </Typography>
                    <Typography variant="body2" color="text.secondary">
                      Allocator internals (ptmalloc2, bins, tcache, fastbins), exploitation techniques (UAF, double-free, heap overflow, tcache poisoning),
                      House of techniques, heap grooming, bypassing modern mitigations, and practical tool usage.
                    </Typography>
                  </Box>
                </Grid>
              </Grid>
            </Paper>

            {/* Quick Stats */}
            <Grid container spacing={2} sx={{ mb: 5 }}>
              {[
                { value: "6", label: "Core Techniques", color: "#ef4444", icon: <BugReportIcon /> },
                { value: "6", label: "House of Variants", color: "#8b5cf6", icon: <AccountTreeIcon /> },
                { value: "6", label: "Heap Allocators", color: "#10b981", icon: <StorageIcon /> },
                { value: "8", label: "Essential Tools", color: "#3b82f6", icon: <BuildIcon /> },
                { value: "4", label: "Mitigation Classes", color: "#f59e0b", icon: <SecurityIcon /> },
                { value: "6", label: "Metadata Fields", color: "#06b6d4", icon: <LayersIcon /> },
              ].map((stat) => (
                <Grid item xs={6} md={2} key={stat.label}>
                  <Paper
                    sx={{
                      p: 2,
                      textAlign: "center",
                      borderRadius: 3,
                      border: `1px solid ${alpha(stat.color, 0.2)}`,
                      transition: "all 0.2s",
                      "&:hover": {
                        transform: "translateY(-2px)",
                        boxShadow: `0 4px 20px ${alpha(stat.color, 0.15)}`,
                      },
                    }}
                  >
                    <Box sx={{ color: stat.color, mb: 0.5 }}>{stat.icon}</Box>
                    <Typography variant="h4" sx={{ fontWeight: 800, color: stat.color }}>
                      {stat.value}
                    </Typography>
                    <Typography variant="caption" color="text.secondary">
                      {stat.label}
                    </Typography>
                  </Paper>
                </Grid>
              ))}
            </Grid>

            {/* Introduction Alert */}
            <Alert severity="info" icon={<InfoIcon />} sx={{ mb: 4, borderRadius: 3 }}>
              <AlertTitle sx={{ fontWeight: 700 }}>Why Learn Heap Exploitation?</AlertTitle>
              Heap vulnerabilities are prevalent in modern software and often more powerful than stack-based bugs. Understanding heap exploitation is essential
              for advanced penetration testing, vulnerability research, CTF competitions, and defensive security. Modern systems deploy sophisticated heap
              mitigations, making this a challenging and evolving field.
            </Alert>
          </Box>

          {/* Heap Allocators Section */}
          <Box id="allocators">
            <Typography variant="h4" sx={{ fontWeight: 800, mb: 1 }}>
               Heap Allocators by Platform
            </Typography>
            <Typography variant="body1" color="text.secondary" sx={{ mb: 3 }}>
              Different platforms and applications use different heap allocators with varying security properties
            </Typography>

            <TableContainer component={Paper} sx={{ mb: 5, borderRadius: 3, border: `1px solid ${alpha(theme.palette.divider, 0.1)}` }}>
              <Table>
                <TableHead>
                  <TableRow sx={{ bgcolor: alpha("#ef4444", 0.05) }}>
                    <TableCell sx={{ fontWeight: 700 }}>Allocator</TableCell>
                    <TableCell sx={{ fontWeight: 700 }}>Platform</TableCell>
                    <TableCell sx={{ fontWeight: 700 }}>Description</TableCell>
                    <TableCell sx={{ fontWeight: 700 }}>Key Features</TableCell>
                    <TableCell sx={{ fontWeight: 700 }}>Security</TableCell>
                  </TableRow>
                </TableHead>
                <TableBody>
                  {heapAllocators.map((allocator, idx) => (
                    <TableRow key={allocator.allocator} sx={{ "&:hover": { bgcolor: alpha("#ef4444", 0.02) } }}>
                      <TableCell sx={{ fontWeight: 600, fontFamily: "monospace", color: "#ef4444" }}>{allocator.allocator}</TableCell>
                      <TableCell>{allocator.platform}</TableCell>
                      <TableCell>{allocator.description}</TableCell>
                      <TableCell sx={{ fontSize: "0.85rem" }}>{allocator.features}</TableCell>
                      <TableCell sx={{ fontSize: "0.85rem" }}>{allocator.security}</TableCell>
                    </TableRow>
                  ))}
                </TableBody>
              </Table>
            </TableContainer>

            <Alert severity="warning" icon={<WarningIcon />} sx={{ mb: 5, borderRadius: 3 }}>
              <AlertTitle sx={{ fontWeight: 700 }}>Allocator Versioning Matters</AlertTitle>
              Heap exploitation techniques are highly version-specific. For example, glibc 2.26 introduced tcache, 2.29 added tcache keys, and 2.32 added
              safe-linking. Always verify the target allocator version and test your exploits accordingly. Use `ldd --version` to check glibc version on Linux.
            </Alert>
          </Box>

          {/* Heap Feng Shui Section */}
          <Box id="feng-shui">
            <Typography variant="h4" sx={{ fontWeight: 800, mb: 1 }}>
               Heap Feng Shui (Heap Grooming)
            </Typography>
            <Typography variant="body1" color="text.secondary" sx={{ mb: 3 }}>
              The art of shaping heap layout to create predictable memory arrangements for exploitation
            </Typography>

            <Paper sx={{ p: 4, mb: 3, borderRadius: 3, border: `1px solid ${alpha(theme.palette.divider, 0.1)}` }}>
              <Typography variant="body1" sx={{ mb: 2, lineHeight: 1.8 }}>
                Heap Feng Shui, also known as heap grooming or heap shaping, is the technique of carefully controlling heap allocations and deallocations to
                arrange memory in a predictable layout that favors exploitation. Unlike stack-based exploitation where memory layout is relatively static, heap
                exploitation requires active manipulation of the allocator's state to position chunks, create gaps, control adjacency, and prime freelists.
              </Typography>
              <Typography variant="body1" sx={{ mb: 2, lineHeight: 1.8 }}>
                The goal of heap feng shui is to transform a non-deterministic heap state into a reliable, predictable configuration. This involves
                understanding allocator behavior (tcache vs fastbins vs bins, LIFO vs FIFO ordering, consolidation rules), carefully sequencing allocations and
                frees, and accounting for application-specific allocation patterns. Successful grooming ensures that vulnerable operations (overflows, UAFs,
                double-frees) interact with heap memory in exploitable ways.
              </Typography>
              <Typography variant="body1" sx={{ mb: 2, lineHeight: 1.8 }}>
                Modern heap feng shui must contend with allocator hardening like safe-linking, ASLR, and tcache. Attackers often need to groom the heap
                multiple times: first to achieve an information leak (heap or libc address), then to position chunks for the actual exploit primitive.
                Multi-threaded applications add complexity, as concurrent allocations can disturb groomed layouts unless thread affinity or arena isolation is
                employed.
              </Typography>
              <Typography variant="body1" sx={{ lineHeight: 1.8 }}>
                Effective heap feng shui requires deep understanding of the target allocator's implementation. For ptmalloc2, this means knowing tcache limits
                (7 chunks per size), fastbin sizes (16-176 bytes), consolidation behavior, and bin selection order. Grooming typically involves three phases:
                (1) initial allocation to establish heap topology, (2) strategic frees to populate freelists and create holes, (3) reallocation to place
                target chunks in desired positions.
              </Typography>
            </Paper>

            <TableContainer component={Paper} sx={{ mb: 3, borderRadius: 3, border: `1px solid ${alpha(theme.palette.divider, 0.1)}` }}>
              <Table>
                <TableHead>
                  <TableRow sx={{ bgcolor: alpha("#ec4899", 0.05) }}>
                    <TableCell sx={{ fontWeight: 700 }}>Strategy</TableCell>
                    <TableCell sx={{ fontWeight: 700 }}>Description</TableCell>
                    <TableCell sx={{ fontWeight: 700 }}>Approach</TableCell>
                    <TableCell sx={{ fontWeight: 700 }}>Use Case</TableCell>
                    <TableCell sx={{ fontWeight: 700 }}>Difficulty</TableCell>
                  </TableRow>
                </TableHead>
                <TableBody>
                  {heapFengShuiStrategies.map((strategy) => (
                    <TableRow key={strategy.strategy} sx={{ "&:hover": { bgcolor: alpha("#ec4899", 0.02) } }}>
                      <TableCell sx={{ fontWeight: 600, color: "#ec4899" }}>{strategy.strategy}</TableCell>
                      <TableCell>{strategy.description}</TableCell>
                      <TableCell sx={{ fontSize: "0.85rem" }}>{strategy.approach}</TableCell>
                      <TableCell sx={{ fontSize: "0.85rem" }}>{strategy.useCase}</TableCell>
                      <TableCell>
                        <Chip
                          label={strategy.difficulty}
                          size="small"
                          sx={{
                            bgcolor:
                              strategy.difficulty === "Low"
                                ? alpha("#10b981", 0.1)
                                : strategy.difficulty === "Medium"
                                  ? alpha("#f59e0b", 0.1)
                                  : strategy.difficulty === "High"
                                    ? alpha("#ef4444", 0.1)
                                    : alpha("#dc2626", 0.1),
                            color:
                              strategy.difficulty === "Low"
                                ? "#10b981"
                                : strategy.difficulty === "Medium"
                                  ? "#f59e0b"
                                  : strategy.difficulty === "High"
                                    ? "#ef4444"
                                    : "#dc2626",
                            fontWeight: 600,
                          }}
                        />
                      </TableCell>
                    </TableRow>
                  ))}
                </TableBody>
              </Table>
            </TableContainer>

            <Grid container spacing={3} sx={{ mb: 3 }}>
              <Grid item xs={12} md={6}>
                <Paper sx={{ p: 3, borderRadius: 3, bgcolor: alpha("#06b6d4", 0.05), border: `1px solid ${alpha("#06b6d4", 0.2)}`, height: "100%" }}>
                  <Typography variant="h6" sx={{ fontWeight: 700, mb: 2, display: "flex", alignItems: "center", gap: 1 }}>
                    <CodeIcon sx={{ color: "#06b6d4" }} />
                    Example: Adjacency Control
                  </Typography>
                  <Paper
                    sx={{
                      p: 2,
                      bgcolor: alpha("#000", 0.05),
                      fontFamily: "monospace",
                      fontSize: "0.85rem",
                      overflowX: "auto",
                      borderRadius: 2,
                    }}
                  >
                    <pre style={{ margin: 0 }}>
                      {`// Goal: Place chunk B adjacent to chunk A
void *chunks[10];

// Phase 1: Allocate many chunks
for (int i = 0; i < 10; i++) {
    chunks[i] = malloc(0x80);
}

// Phase 2: Free every other chunk to create holes
for (int i = 1; i < 10; i += 2) {
    free(chunks[i]);
}

// Phase 3: Allocate victim and target
void *victim = malloc(0x80);  // Takes chunks[9]
void *target = malloc(0x80);  // Takes chunks[7]

// Now victim and target are adjacent!
// Overflow in victim affects target`}
                    </pre>
                  </Paper>
                </Paper>
              </Grid>

              <Grid item xs={12} md={6}>
                <Paper sx={{ p: 3, borderRadius: 3, bgcolor: alpha("#8b5cf6", 0.05), border: `1px solid ${alpha("#8b5cf6", 0.2)}`, height: "100%" }}>
                  <Typography variant="h6" sx={{ fontWeight: 700, mb: 2, display: "flex", alignItems: "center", gap: 1 }}>
                    <CodeIcon sx={{ color: "#8b5cf6" }} />
                    Example: Tcache Priming
                  </Typography>
                  <Paper
                    sx={{
                      p: 2,
                      bgcolor: alpha("#000", 0.05),
                      fontFamily: "monospace",
                      fontSize: "0.85rem",
                      overflowX: "auto",
                      borderRadius: 2,
                    }}
                  >
                    <pre style={{ margin: 0 }}>
                      {`// Goal: Fill tcache to force next free to fastbin
void *tcache_chunks[7];

// Fill tcache for 0x90 size class
for (int i = 0; i < 7; i++) {
    tcache_chunks[i] = malloc(0x80);
}

for (int i = 0; i < 7; i++) {
    free(tcache_chunks[i]);
}

// Tcache now full (7/7 for 0x90)
void *overflow_chunk = malloc(0x80);

// Next free goes to fastbin, not tcache!
free(overflow_chunk);

// Now we can attack fastbin metadata
// without tcache interference`}
                    </pre>
                  </Paper>
                </Paper>
              </Grid>
            </Grid>

            <Alert severity="info" icon={<TipsAndUpdatesIcon />} sx={{ mb: 5, borderRadius: 3 }}>
              <AlertTitle sx={{ fontWeight: 700 }}>Grooming Best Practices</AlertTitle>
              <List dense>
                <ListItem sx={{ py: 0 }}>
                  <ListItemIcon sx={{ minWidth: 30 }}>
                    <CheckCircleIcon sx={{ fontSize: 16, color: "#06b6d4" }} />
                  </ListItemIcon>
                  <ListItemText
                    primary="Always verify heap state with debugger (pwndbg heap/bins commands) during development"
                    primaryTypographyProps={{ variant: "body2" }}
                  />
                </ListItem>
                <ListItem sx={{ py: 0 }}>
                  <ListItemIcon sx={{ minWidth: 30 }}>
                    <CheckCircleIcon sx={{ fontSize: 16, color: "#06b6d4" }} />
                  </ListItemIcon>
                  <ListItemText
                    primary="Account for application's own allocations that may interfere with grooming"
                    primaryTypographyProps={{ variant: "body2" }}
                  />
                </ListItem>
                <ListItem sx={{ py: 0 }}>
                  <ListItemIcon sx={{ minWidth: 30 }}>
                    <CheckCircleIcon sx={{ fontSize: 16, color: "#06b6d4" }} />
                  </ListItemIcon>
                  <ListItemText
                    primary="Use consolidation prevention (sentinels) to maintain chunk boundaries"
                    primaryTypographyProps={{ variant: "body2" }}
                  />
                </ListItem>
                <ListItem sx={{ py: 0 }}>
                  <ListItemIcon sx={{ minWidth: 30 }}>
                    <CheckCircleIcon sx={{ fontSize: 16, color: "#06b6d4" }} />
                  </ListItemIcon>
                  <ListItemText
                    primary="Test grooming reliability across multiple runs to ensure consistency"
                    primaryTypographyProps={{ variant: "body2" }}
                  />
                </ListItem>
              </List>
            </Alert>
          </Box>

          {/* Metadata Structures */}
          <Box id="metadata">
            <Typography variant="h4" sx={{ fontWeight: 800, mb: 1 }}>
               Heap Metadata Structures (ptmalloc2/glibc)
            </Typography>
            <Typography variant="body1" color="text.secondary" sx={{ mb: 3 }}>
              Understanding chunk metadata is essential for crafting exploits and analyzing heap state
            </Typography>

            <TableContainer component={Paper} sx={{ mb: 5, borderRadius: 3, border: `1px solid ${alpha(theme.palette.divider, 0.1)}` }}>
              <Table>
                <TableHead>
                  <TableRow sx={{ bgcolor: alpha("#3b82f6", 0.05) }}>
                    <TableCell sx={{ fontWeight: 700 }}>Field</TableCell>
                    <TableCell sx={{ fontWeight: 700 }}>Description</TableCell>
                    <TableCell sx={{ fontWeight: 700 }}>Bits/Flags</TableCell>
                    <TableCell sx={{ fontWeight: 700 }}>Notes</TableCell>
                  </TableRow>
                </TableHead>
                <TableBody>
                  {heapMetadata.map((field) => (
                    <TableRow key={field.field} sx={{ "&:hover": { bgcolor: alpha("#3b82f6", 0.02) } }}>
                      <TableCell sx={{ fontWeight: 600, fontFamily: "monospace", color: "#3b82f6" }}>{field.field}</TableCell>
                      <TableCell>{field.description}</TableCell>
                      <TableCell sx={{ fontSize: "0.85rem" }}>{field.bits}</TableCell>
                      <TableCell sx={{ fontSize: "0.85rem" }}>{field.notes}</TableCell>
                    </TableRow>
                  ))}
                </TableBody>
              </Table>
            </TableContainer>

            <Paper sx={{ p: 3, mb: 5, borderRadius: 3, bgcolor: alpha("#06b6d4", 0.05), border: `1px solid ${alpha("#06b6d4", 0.2)}` }}>
              <Typography variant="h6" sx={{ fontWeight: 700, mb: 2, display: "flex", alignItems: "center", gap: 1 }}>
                <CodeIcon sx={{ color: "#06b6d4" }} />
                Example Chunk Structure
              </Typography>
              <Paper
                sx={{
                  p: 2,
                  bgcolor: alpha("#000", 0.05),
                  fontFamily: "monospace",
                  fontSize: "0.85rem",
                  overflowX: "auto",
                  borderRadius: 2,
                }}
              >
                <pre style={{ margin: 0 }}>
                  {`struct malloc_chunk {
  size_t      prev_size;  /* Size of previous chunk (if free) */
  size_t      size;       /* Size in bytes, including metadata */
                          /* Low 3 bits: PREV_INUSE, IS_MMAPPED, NON_MAIN_ARENA */

  /* Only for free chunks: */
  struct malloc_chunk* fd;         /* Forward pointer to next chunk in bin */
  struct malloc_chunk* bk;         /* Backward pointer to previous chunk */
  struct malloc_chunk* fd_nextsize; /* Only in large bins */
  struct malloc_chunk* bk_nextsize; /* Only in large bins */
};

/* For allocated chunks, user data starts at fd field location */
/* Chunk size is always aligned (e.g., 16 bytes on 64-bit) */
/* Minimum chunk size: 4*sizeof(void*) = 32 bytes on 64-bit */`}
                </pre>
              </Paper>
            </Paper>
          </Box>

          {/* Bin Management Deep Dive */}
          <Box id="bins">
            <Typography variant="h4" sx={{ fontWeight: 800, mb: 1 }}>
               Bin Management Deep Dive
            </Typography>
            <Typography variant="body1" color="text.secondary" sx={{ mb: 3 }}>
              Comprehensive analysis of ptmalloc2 bin types, behaviors, and exploitation implications
            </Typography>

            <Paper sx={{ p: 4, mb: 3, borderRadius: 3, border: `1px solid ${alpha(theme.palette.divider, 0.1)}` }}>
              <Typography variant="body1" sx={{ mb: 2, lineHeight: 1.8 }}>
                Bins are the fundamental data structures used by ptmalloc2 (glibc's allocator) to manage freed chunks. Understanding bin mechanics is critical
                for heap exploitation because bins dictate how freed memory is reused, how chunks are linked, what safety checks are performed, and which
                exploitation techniques are viable. The allocator maintains several bin types, each optimized for different size ranges and usage patterns.
              </Typography>
              <Typography variant="body1" sx={{ mb: 2, lineHeight: 1.8 }}>
                The bin hierarchy reflects performance vs. security tradeoffs. Tcache (per-thread cache, glibc 2.26+) is the fastest path with minimal checks,
                making it a primary target for modern exploits. Fastbins provide quick reuse for small chunks but defer coalescing. Smallbins offer exact-size
                matching with FIFO ordering and safe unlinking. Largebins implement complex best-fit allocation with extensive validation. The unsorted bin acts
                as a temporary cache before chunks are sorted into their final bins.
              </Typography>
              <Typography variant="body1" sx={{ mb: 2, lineHeight: 1.8 }}>
                Bin coalescing and consolidation behavior is crucial for exploitation. Tcache and fastbins never coalesce with neighbors automatically, allowing
                freed chunks to remain at their original sizes. Smallbins and largebins immediately coalesce with adjacent free chunks, potentially disrupting
                groomed heap layouts. Consolidation can be triggered explicitly via malloc_consolidate(), which moves fastbin chunks to unsorted bin and merges
                them with neighbors.
              </Typography>
              <Typography variant="body1" sx={{ lineHeight: 1.8 }}>
                Exploiting bins requires understanding their linking structures. Tcache and fastbins use singly-linked lists (only fd pointer), making them
                vulnerable to simple pointer corruption but protected by safe-linking on modern glibc. Smallbins and largebins use doubly-linked circular lists
                (fd and bk pointers) with safe unlinking checks that validate fd-&gt;bk == chunk && bk-&gt;fd == chunk. Largebins add fd_nextsize and
                bk_nextsize pointers for size-sorted traversal, creating additional attack surface but also additional validation.
              </Typography>
            </Paper>

            <TableContainer component={Paper} sx={{ mb: 3, borderRadius: 3, border: `1px solid ${alpha(theme.palette.divider, 0.1)}` }}>
              <Table>
                <TableHead>
                  <TableRow sx={{ bgcolor: alpha("#10b981", 0.05) }}>
                    <TableCell sx={{ fontWeight: 700 }}>Bin Type</TableCell>
                    <TableCell sx={{ fontWeight: 700 }}>Size Range</TableCell>
                    <TableCell sx={{ fontWeight: 700 }}>Structure</TableCell>
                    <TableCell sx={{ fontWeight: 700 }}>Behavior</TableCell>
                    <TableCell sx={{ fontWeight: 700 }}>Coalescing</TableCell>
                    <TableCell sx={{ fontWeight: 700 }}>Safety Features</TableCell>
                  </TableRow>
                </TableHead>
                <TableBody>
                  {binManagementDetails.map((bin) => (
                    <TableRow key={bin.binType} sx={{ "&:hover": { bgcolor: alpha("#10b981", 0.02) } }}>
                      <TableCell sx={{ fontWeight: 600, color: "#10b981" }}>{bin.binType}</TableCell>
                      <TableCell sx={{ fontSize: "0.85rem", fontFamily: "monospace" }}>{bin.sizeRange}</TableCell>
                      <TableCell sx={{ fontSize: "0.85rem" }}>{bin.structure}</TableCell>
                      <TableCell sx={{ fontSize: "0.85rem" }}>{bin.behavior}</TableCell>
                      <TableCell sx={{ fontSize: "0.85rem" }}>{bin.coalescing}</TableCell>
                      <TableCell sx={{ fontSize: "0.85rem" }}>{bin.safetyFeatures}</TableCell>
                    </TableRow>
                  ))}
                </TableBody>
              </Table>
            </TableContainer>

            <Grid container spacing={3} sx={{ mb: 3 }}>
              {binManagementDetails.map((bin) => (
                <Grid item xs={12} md={6} key={bin.binType}>
                  <Accordion
                    sx={{
                      borderRadius: 3,
                      border: `1px solid ${alpha("#10b981", 0.2)}`,
                      "&:before": { display: "none" },
                    }}
                  >
                    <AccordionSummary
                      expandIcon={<ExpandMoreIcon />}
                      sx={{
                        bgcolor: alpha("#10b981", 0.05),
                        "&:hover": { bgcolor: alpha("#10b981", 0.08) },
                        borderRadius: 3,
                      }}
                    >
                      <Box sx={{ display: "flex", alignItems: "center", gap: 2, width: "100%" }}>
                        <Box
                          sx={{
                            width: 40,
                            height: 40,
                            borderRadius: 2,
                            bgcolor: "#10b981",
                            display: "flex",
                            alignItems: "center",
                            justifyContent: "center",
                            color: "white",
                          }}
                        >
                          <StorageIcon />
                        </Box>
                        <Box>
                          <Typography variant="subtitle1" sx={{ fontWeight: 700 }}>
                            {bin.binType}
                          </Typography>
                          <Typography variant="caption" color="text.secondary">
                            {bin.count}
                          </Typography>
                        </Box>
                      </Box>
                    </AccordionSummary>
                    <AccordionDetails>
                      <Grid container spacing={2}>
                        <Grid item xs={12}>
                          <Typography variant="caption" sx={{ fontWeight: 700, display: "block", mb: 0.5 }}>
                            Unlinking Checks:
                          </Typography>
                          <Typography variant="body2" color="text.secondary">
                            {bin.unlinkingChecks}
                          </Typography>
                        </Grid>
                        <Grid item xs={12}>
                          <Typography variant="caption" sx={{ fontWeight: 700, display: "block", mb: 0.5 }}>
                            Max Per Bin:
                          </Typography>
                          <Typography variant="body2" color="text.secondary">
                            {bin.maxPerBin}
                          </Typography>
                        </Grid>
                        <Grid item xs={12}>
                          <Typography variant="caption" sx={{ fontWeight: 700, display: "block", mb: 0.5 }}>
                            Implementation Notes:
                          </Typography>
                          <Paper sx={{ p: 2, bgcolor: alpha("#10b981", 0.03), borderRadius: 2 }}>
                            <Typography variant="body2">{bin.notes}</Typography>
                          </Paper>
                        </Grid>
                      </Grid>
                    </AccordionDetails>
                  </Accordion>
                </Grid>
              ))}
            </Grid>

            <Paper sx={{ p: 3, mb: 3, borderRadius: 3, bgcolor: alpha("#06b6d4", 0.05), border: `1px solid ${alpha("#06b6d4", 0.2)}` }}>
              <Typography variant="h6" sx={{ fontWeight: 700, mb: 2, display: "flex", alignItems: "center", gap: 1 }}>
                <CodeIcon sx={{ color: "#06b6d4" }} />
                Bin Traversal Example (Smallbin)
              </Typography>
              <Paper
                sx={{
                  p: 2,
                  bgcolor: alpha("#000", 0.05),
                  fontFamily: "monospace",
                  fontSize: "0.85rem",
                  overflowX: "auto",
                  borderRadius: 2,
                }}
              >
                <pre style={{ margin: 0 }}>
                  {`// Smallbin structure (doubly-linked circular list)
// bin->fd points to oldest (first) chunk
// bin->bk points to newest (last) chunk

struct malloc_chunk *victim = bin->fd;

// Safe unlinking check
if (victim->fd->bk != victim || victim->bk->fd != victim) {
    // Corrupted! Abort
    malloc_printerr("corrupted double-linked list");
}

// Remove from bin
victim->fd->bk = victim->bk;
victim->bk->fd = victim->fd;

// victim is now unlinked and ready for reuse
return victim;`}
                </pre>
              </Paper>
            </Paper>

            <Alert severity="warning" icon={<WarningIcon />} sx={{ mb: 5, borderRadius: 3 }}>
              <AlertTitle sx={{ fontWeight: 700 }}>Bin Selection Order</AlertTitle>
              When malloc is called, ptmalloc2 searches bins in this order: (1) Tcache for exact size, (2) Fastbin for exact size, (3) Smallbin for exact
              size, (4) Unsorted bin (scanned linearly), (5) Largebin best-fit, (6) Top chunk, (7) Create new heap via mmap. Understanding this order is
              critical for predicting allocation behavior during exploitation.
            </Alert>
          </Box>

          {/* Exploitation Techniques */}
          <Box id="techniques">
            <Typography variant="h4" sx={{ fontWeight: 800, mb: 1 }}>
               Core Exploitation Techniques
            </Typography>
            <Typography variant="body1" color="text.secondary" sx={{ mb: 3 }}>
              Detailed breakdown of primary heap exploitation primitives
            </Typography>

            <Grid container spacing={3} sx={{ mb: 5 }}>
              {exploitTechniques.map((tech) => (
                <Grid item xs={12} md={6} key={tech.name}>
                  <Accordion
                    sx={{
                      borderRadius: 3,
                      border: `1px solid ${alpha(tech.color, 0.2)}`,
                      "&:before": { display: "none" },
                      "&.Mui-expanded": {
                        boxShadow: `0 8px 24px ${alpha(tech.color, 0.15)}`,
                      },
                    }}
                  >
                    <AccordionSummary
                      expandIcon={<ExpandMoreIcon />}
                      sx={{
                        bgcolor: alpha(tech.color, 0.05),
                        "&:hover": { bgcolor: alpha(tech.color, 0.08) },
                        borderRadius: 3,
                      }}
                    >
                      <Box sx={{ display: "flex", alignItems: "center", gap: 2, width: "100%" }}>
                        <Box
                          sx={{
                            width: 40,
                            height: 40,
                            borderRadius: 2,
                            bgcolor: tech.color,
                            display: "flex",
                            alignItems: "center",
                            justifyContent: "center",
                            color: "white",
                          }}
                        >
                          <BugReportIcon />
                        </Box>
                        <Box>
                          <Typography variant="subtitle1" sx={{ fontWeight: 700 }}>
                            {tech.name}
                          </Typography>
                          <Typography variant="caption" color="text.secondary">
                            {tech.description}
                          </Typography>
                        </Box>
                      </Box>
                    </AccordionSummary>
                    <AccordionDetails>
                      <Typography variant="subtitle2" sx={{ fontWeight: 700, mt: 1, mb: 1 }}>
                        Prerequisites:
                      </Typography>
                      <List dense>
                        {tech.prerequisites.map((prereq, idx) => (
                          <ListItem key={idx} sx={{ py: 0 }}>
                            <ListItemIcon sx={{ minWidth: 24 }}>
                              <CheckCircleIcon sx={{ fontSize: 16, color: tech.color }} />
                            </ListItemIcon>
                            <ListItemText primary={prereq} primaryTypographyProps={{ variant: "body2" }} />
                          </ListItem>
                        ))}
                      </List>

                      <Typography variant="subtitle2" sx={{ fontWeight: 700, mt: 2, mb: 1 }}>
                        Exploitation Steps:
                      </Typography>
                      <List dense>
                        {tech.steps.map((step, idx) => (
                          <ListItem key={idx} sx={{ py: 0.25 }}>
                            <ListItemIcon sx={{ minWidth: 32 }}>
                              <Chip label={idx + 1} size="small" sx={{ width: 24, height: 24, fontSize: "0.7rem", bgcolor: tech.color, color: "white" }} />
                            </ListItemIcon>
                            <ListItemText primary={step} primaryTypographyProps={{ variant: "body2" }} />
                          </ListItem>
                        ))}
                      </List>

                      <Typography variant="subtitle2" sx={{ fontWeight: 700, mt: 2, mb: 1 }}>
                        Mitigations:
                      </Typography>
                      <Box sx={{ display: "flex", gap: 1, flexWrap: "wrap" }}>
                        {tech.mitigations.map((mitigation) => (
                          <Chip key={mitigation} label={mitigation} size="small" variant="outlined" sx={{ borderColor: alpha(tech.color, 0.3) }} />
                        ))}
                      </Box>
                    </AccordionDetails>
                  </Accordion>
                </Grid>
              ))}
            </Grid>
          </Box>

          {/* Common Pitfalls and Errors */}
          <Box id="pitfalls">
            <Typography variant="h4" sx={{ fontWeight: 800, mb: 1 }}>
               Common Pitfalls and Errors
            </Typography>
            <Typography variant="body1" color="text.secondary" sx={{ mb: 3 }}>
              Frequent mistakes in heap exploitation and how to avoid them
            </Typography>

            <Paper sx={{ p: 4, mb: 3, borderRadius: 3, border: `1px solid ${alpha(theme.palette.divider, 0.1)}` }}>
              <Typography variant="body1" sx={{ mb: 2, lineHeight: 1.8 }}>
                Heap exploitation is notoriously difficult and error-prone. Unlike stack-based vulnerabilities that often work predictably, heap exploits must
                contend with complex allocator state, version-specific behavior, non-deterministic allocation patterns, and modern hardening mechanisms. Even
                experienced exploit developers frequently encounter failures due to subtle allocator quirks, incorrect assumptions, or overlooked edge cases.
              </Typography>
              <Typography variant="body1" sx={{ mb: 2, lineHeight: 1.8 }}>
                The most common category of errors involves misunderstanding allocator state. Attackers often forget that tcache intercepts small frees before
                fastbins, causing chunks to go to the wrong freelist. Unexpected consolidation can merge carefully positioned chunks, destroying groomed layouts.
                Incorrect size calculations lead to chunks being allocated from unexpected bins. These state-related errors typically manifest as exploits that
                work in controlled testing but fail against the real target.
              </Typography>
              <Typography variant="body1" sx={{ mb: 2, lineHeight: 1.8 }}>
                Modern glibc hardening introduces version-specific pitfalls. Safe-linking (glibc 2.32+) XOR-masks freelist pointers with heap-derived values,
                breaking exploits that directly corrupt fd pointers without accounting for the mask. Tcache keys (glibc 2.29+) detect double-frees by storing a
                magic value in freed chunks. Safe unlinking validates doubly-linked list integrity. Attackers must know the exact target glibc version and
                adapt techniques accordingly.
              </Typography>
              <Typography variant="body1" sx={{ lineHeight: 1.8 }}>
                Information leak failures are particularly frustrating. Exploits may successfully leak libc addresses but fail to leak heap addresses needed for
                safe-linking bypass, or vice versa. PIE/ASLR checks are sometimes overlooked during development, causing exploits to fail when addresses are
                randomized. Testing with ASan or debug allocators can mask bugs that only appear with the production allocator. The key to avoiding these
                pitfalls is methodical testing, careful allocator version verification, and thorough debugging with tools like pwndbg.
              </Typography>
            </Paper>

            <TableContainer component={Paper} sx={{ mb: 3, borderRadius: 3, border: `1px solid ${alpha(theme.palette.divider, 0.1)}` }}>
              <Table>
                <TableHead>
                  <TableRow sx={{ bgcolor: alpha("#f59e0b", 0.05) }}>
                    <TableCell sx={{ fontWeight: 700 }}>Category</TableCell>
                    <TableCell sx={{ fontWeight: 700 }}>Mistake</TableCell>
                    <TableCell sx={{ fontWeight: 700 }}>Consequence</TableCell>
                    <TableCell sx={{ fontWeight: 700 }}>Solution</TableCell>
                    <TableCell sx={{ fontWeight: 700 }}>Frequency</TableCell>
                  </TableRow>
                </TableHead>
                <TableBody>
                  {commonPitfalls.map((pitfall, idx) => (
                    <TableRow key={idx} sx={{ "&:hover": { bgcolor: alpha("#f59e0b", 0.02) } }}>
                      <TableCell sx={{ fontWeight: 600, color: "#f59e0b" }}>{pitfall.category}</TableCell>
                      <TableCell>{pitfall.mistake}</TableCell>
                      <TableCell sx={{ fontSize: "0.85rem" }}>{pitfall.consequence}</TableCell>
                      <TableCell sx={{ fontSize: "0.85rem" }}>{pitfall.solution}</TableCell>
                      <TableCell>
                        <Chip
                          label={pitfall.frequency}
                          size="small"
                          sx={{
                            bgcolor: pitfall.frequency.includes("Very Common")
                              ? alpha("#ef4444", 0.1)
                              : pitfall.frequency.includes("Common")
                                ? alpha("#f59e0b", 0.1)
                                : alpha("#10b981", 0.1),
                            color: pitfall.frequency.includes("Very Common") ? "#ef4444" : pitfall.frequency.includes("Common") ? "#f59e0b" : "#10b981",
                            fontWeight: 600,
                          }}
                        />
                      </TableCell>
                    </TableRow>
                  ))}
                </TableBody>
              </Table>
            </TableContainer>

            <Alert severity="error" icon={<WarningIcon />} sx={{ mb: 5, borderRadius: 3 }}>
              <AlertTitle sx={{ fontWeight: 700 }}>Critical Debugging Tip</AlertTitle>
              When your heap exploit fails, use pwndbg's 'bins' command to inspect actual allocator state. Compare expected vs. actual bin contents, check for
              unexpected consolidation, verify tcache counts, and examine chunk metadata. Most heap exploit failures are due to incorrect assumptions about
              allocator state rather than code bugs. Always debug the heap state, not just your exploit code.
            </Alert>
          </Box>

          {/* Heap Spray Techniques Detail */}
          <Box id="heap-spray">
            <Typography variant="h4" sx={{ fontWeight: 800, mb: 1 }}>
               Heap Spray Techniques Detail
            </Typography>
            <Typography variant="body1" color="text.secondary" sx={{ mb: 3 }}>
              Advanced heap spraying strategies for increasing exploitation reliability
            </Typography>

            <Paper sx={{ p: 4, mb: 3, borderRadius: 3, border: `1px solid ${alpha(theme.palette.divider, 0.1)}` }}>
              <Typography variant="body1" sx={{ mb: 2, lineHeight: 1.8 }}>
                Heap spraying is a probabilistic exploitation technique that fills large portions of the heap with attacker-controlled data to increase the
                likelihood of exploitation success. Unlike precise heap feng shui, which aims for deterministic chunk placement, heap spraying trades precision
                for reliability by saturating the heap address space. The attacker allocates thousands or millions of objects containing exploit payloads,
                hoping that vulnerable operations (UAF dereferences, corrupted function pointers, etc.) will land on controlled data.
              </Typography>
              <Typography variant="body1" sx={{ mb: 2, lineHeight: 1.8 }}>
                Classic heap spraying allocates many identically-sized chunks filled with shellcode or ROP chains, often prepended with NOP sleds for alignment
                tolerance. The spray density must be high enough that random memory accesses have a reasonable probability of hitting controlled data. In
                browser exploitation, JavaScript objects or ArrayBuffers are common spray vehicles. In application exploitation, any controllable allocation
                interface (input buffers, cached data structures, etc.) can be leveraged.
              </Typography>
              <Typography variant="body1" sx={{ mb: 2, lineHeight: 1.8 }}>
                Modern heap spraying must contend with ASLR, which randomizes heap base addresses and introduces entropy. High-entropy ASLR (especially on
                64-bit systems with large address spaces) significantly reduces spray effectiveness. Attackers respond with larger spray volumes, multi-stage
                sprays (spray -&gt; leak -&gt; targeted spray), or combined spraying with heap feng shui. Platform-specific optimizations leverage allocator
                behavior: spraying into tcache vs. fastbins vs. largebins has different performance and reliability characteristics.
              </Typography>
              <Typography variant="body1" sx={{ lineHeight: 1.8 }}>
                Success rate calculation depends on spray size, heap size, and target address randomization. For a 1GB spray in a 4GB heap with perfect
                distribution, the probability of hitting controlled data is ~25%. Doubling the spray doubles the success rate (up to saturation). However,
                spraying has costs: memory consumption may trigger OOM errors, allocation time may alert detection systems, and large sprays are forensically
                obvious. Modern exploits often combine small targeted sprays with precise heap shaping for optimal reliability and stealth.
              </Typography>
            </Paper>

            <Grid container spacing={3} sx={{ mb: 3 }}>
              <Grid item xs={12} md={6}>
                <Paper sx={{ p: 3, borderRadius: 3, border: `1px solid ${alpha("#ec4899", 0.2)}`, height: "100%" }}>
                  <Typography variant="h6" sx={{ fontWeight: 700, mb: 2, color: "#ec4899" }}>
                    Classic Spray Pattern
                  </Typography>
                  <Typography variant="body2" sx={{ mb: 2 }}>
                    Allocate many chunks with identical payload to saturate address space
                  </Typography>
                  <List dense>
                    <ListItem sx={{ py: 0.25 }}>
                      <ListItemIcon sx={{ minWidth: 24 }}>
                        <CheckCircleIcon sx={{ fontSize: 14, color: "#ec4899" }} />
                      </ListItemIcon>
                      <ListItemText primary="Allocate 10,000+ chunks of same size" primaryTypographyProps={{ variant: "caption" }} />
                    </ListItem>
                    <ListItem sx={{ py: 0.25 }}>
                      <ListItemIcon sx={{ minWidth: 24 }}>
                        <CheckCircleIcon sx={{ fontSize: 14, color: "#ec4899" }} />
                      </ListItemIcon>
                      <ListItemText primary="Fill with NOP sled + shellcode" primaryTypographyProps={{ variant: "caption" }} />
                    </ListItem>
                    <ListItem sx={{ py: 0.25 }}>
                      <ListItemIcon sx={{ minWidth: 24 }}>
                        <CheckCircleIcon sx={{ fontSize: 14, color: "#ec4899" }} />
                      </ListItemIcon>
                      <ListItemText primary="Trigger vulnerability (UAF, corruption)" primaryTypographyProps={{ variant: "caption" }} />
                    </ListItem>
                    <ListItem sx={{ py: 0.25 }}>
                      <ListItemIcon sx={{ minWidth: 24 }}>
                        <CheckCircleIcon sx={{ fontSize: 14, color: "#ec4899" }} />
                      </ListItemIcon>
                      <ListItemText primary="High probability of landing in spray" primaryTypographyProps={{ variant: "caption" }} />
                    </ListItem>
                  </List>
                  <Chip label="Best for: Low-entropy ASLR, 32-bit systems" size="small" sx={{ mt: 1, bgcolor: alpha("#ec4899", 0.1), color: "#ec4899" }} />
                </Paper>
              </Grid>

              <Grid item xs={12} md={6}>
                <Paper sx={{ p: 3, borderRadius: 3, border: `1px solid ${alpha("#8b5cf6", 0.2)}`, height: "100%" }}>
                  <Typography variant="h6" sx={{ fontWeight: 700, mb: 2, color: "#8b5cf6" }}>
                    Targeted Spray (Leak + Spray)
                  </Typography>
                  <Typography variant="body2" sx={{ mb: 2 }}>
                    Use information leak to guide spray placement
                  </Typography>
                  <List dense>
                    <ListItem sx={{ py: 0.25 }}>
                      <ListItemIcon sx={{ minWidth: 24 }}>
                        <CheckCircleIcon sx={{ fontSize: 14, color: "#8b5cf6" }} />
                      </ListItemIcon>
                      <ListItemText primary="Stage 1: Leak heap/libc address" primaryTypographyProps={{ variant: "caption" }} />
                    </ListItem>
                    <ListItem sx={{ py: 0.25 }}>
                      <ListItemIcon sx={{ minWidth: 24 }}>
                        <CheckCircleIcon sx={{ fontSize: 14, color: "#8b5cf6" }} />
                      </ListItemIcon>
                      <ListItemText primary="Calculate target region offset" primaryTypographyProps={{ variant: "caption" }} />
                    </ListItem>
                    <ListItem sx={{ py: 0.25 }}>
                      <ListItemIcon sx={{ minWidth: 24 }}>
                        <CheckCircleIcon sx={{ fontSize: 14, color: "#8b5cf6" }} />
                      </ListItemIcon>
                      <ListItemText primary="Stage 2: Spray near target address" primaryTypographyProps={{ variant: "caption" }} />
                    </ListItem>
                    <ListItem sx={{ py: 0.25 }}>
                      <ListItemIcon sx={{ minWidth: 24 }}>
                        <CheckCircleIcon sx={{ fontSize: 14, color: "#8b5cf6" }} />
                      </ListItemIcon>
                      <ListItemText primary="Much higher success rate" primaryTypographyProps={{ variant: "caption" }} />
                    </ListItem>
                  </List>
                  <Chip label="Best for: Modern ASLR, 64-bit systems" size="small" sx={{ mt: 1, bgcolor: alpha("#8b5cf6", 0.1), color: "#8b5cf6" }} />
                </Paper>
              </Grid>

              <Grid item xs={12} md={6}>
                <Paper sx={{ p: 3, borderRadius: 3, border: `1px solid ${alpha("#10b981", 0.2)}`, height: "100%" }}>
                  <Typography variant="h6" sx={{ fontWeight: 700, mb: 2, color: "#10b981" }}>
                    Bin-Specific Spray
                  </Typography>
                  <Typography variant="body2" sx={{ mb: 2 }}>
                    Target specific allocator bins for controlled placement
                  </Typography>
                  <List dense>
                    <ListItem sx={{ py: 0.25 }}>
                      <ListItemIcon sx={{ minWidth: 24 }}>
                        <CheckCircleIcon sx={{ fontSize: 14, color: "#10b981" }} />
                      </ListItemIcon>
                      <ListItemText primary="Spray tcache-sized chunks (< 1032 bytes)" primaryTypographyProps={{ variant: "caption" }} />
                    </ListItem>
                    <ListItem sx={{ py: 0.25 }}>
                      <ListItemIcon sx={{ minWidth: 24 }}>
                        <CheckCircleIcon sx={{ fontSize: 14, color: "#10b981" }} />
                      </ListItemIcon>
                      <ListItemText primary="Leverage LIFO allocation pattern" primaryTypographyProps={{ variant: "caption" }} />
                    </ListItem>
                    <ListItem sx={{ py: 0.25 }}>
                      <ListItemIcon sx={{ minWidth: 24 }}>
                        <CheckCircleIcon sx={{ fontSize: 14, color: "#10b981" }} />
                      </ListItemIcon>
                      <ListItemText primary="Free some chunks to populate bins" primaryTypographyProps={{ variant: "caption" }} />
                    </ListItem>
                    <ListItem sx={{ py: 0.25 }}>
                      <ListItemIcon sx={{ minWidth: 24 }}>
                        <CheckCircleIcon sx={{ fontSize: 14, color: "#10b981" }} />
                      </ListItemIcon>
                      <ListItemText primary="Next allocation returns sprayed chunk" primaryTypographyProps={{ variant: "caption" }} />
                    </ListItem>
                  </List>
                  <Chip label="Best for: Combined with feng shui" size="small" sx={{ mt: 1, bgcolor: alpha("#10b981", 0.1), color: "#10b981" }} />
                </Paper>
              </Grid>

              <Grid item xs={12} md={6}>
                <Paper sx={{ p: 3, borderRadius: 3, border: `1px solid ${alpha("#3b82f6", 0.2)}`, height: "100%" }}>
                  <Typography variant="h6" sx={{ fontWeight: 700, mb: 2, color: "#3b82f6" }}>
                    Success Rate Calculation
                  </Typography>
                  <Typography variant="body2" sx={{ mb: 2 }}>
                    Estimate spray effectiveness
                  </Typography>
                  <Paper sx={{ p: 2, bgcolor: alpha("#000", 0.05), fontFamily: "monospace", fontSize: "0.75rem", borderRadius: 2 }}>
                    <pre style={{ margin: 0 }}>
                      {`// Simple probability model
heap_size = 4GB (2^32 bytes)
spray_size = 1GB (2^30 bytes)
probability = spray_size / heap_size
            = 1GB / 4GB
            = 0.25 (25%)

// With ASLR entropy
aslr_bits = 12 (4096 possible bases)
effective_prob = 0.25 / 4096
               = 0.000061 (0.006%)

// Required spray for 50% success
target_prob = 0.5
required = target_prob * heap * aslr
         = 0.5 * 4GB * 4096
         = 8TB (impractical)`}
                    </pre>
                  </Paper>
                  <Chip label="ASLR drastically reduces spray effectiveness" size="small" sx={{ mt: 1, bgcolor: alpha("#3b82f6", 0.1), color: "#3b82f6" }} />
                </Paper>
              </Grid>
            </Grid>

            <Paper sx={{ p: 3, mb: 3, borderRadius: 3, bgcolor: alpha("#06b6d4", 0.05), border: `1px solid ${alpha("#06b6d4", 0.2)}` }}>
              <Typography variant="h6" sx={{ fontWeight: 700, mb: 2, display: "flex", alignItems: "center", gap: 1 }}>
                <CodeIcon sx={{ color: "#06b6d4" }} />
                JavaScript Heap Spray Example
              </Typography>
              <Paper
                sx={{
                  p: 2,
                  bgcolor: alpha("#000", 0.05),
                  fontFamily: "monospace",
                  fontSize: "0.85rem",
                  overflowX: "auto",
                  borderRadius: 2,
                }}
              >
                <pre style={{ margin: 0 }}>
                  {`// Browser heap spray using ArrayBuffers
function heapSpray() {
    const spraySize = 100 * 1024 * 1024;  // 100MB
    const chunkSize = 1024 * 1024;        // 1MB per chunk
    const numChunks = spraySize / chunkSize;

    // ROP chain or shellcode as Uint32Array
    const payload = new Uint32Array([
        0x41414141, 0x42424242,  // Placeholder addresses
        0x43434343, 0x44444444,
        // ... actual ROP gadgets ...
    ]);

    const spray = [];
    for (let i = 0; i < numChunks; i++) {
        const buffer = new ArrayBuffer(chunkSize);
        const view = new Uint32Array(buffer);

        // Fill buffer with payload pattern
        for (let j = 0; j < view.length; j += payload.length) {
            view.set(payload, j);
        }

        spray.push(buffer);
    }

    // Trigger vulnerability (UAF, type confusion, etc.)
    triggerVulnerability();
}`}
                </pre>
              </Paper>
            </Paper>

            <Alert severity="info" icon={<TipsAndUpdatesIcon />} sx={{ mb: 5, borderRadius: 3 }}>
              <AlertTitle sx={{ fontWeight: 700 }}>Modern Spray Techniques</AlertTitle>
              Modern heap spraying often combines with other techniques: (1) Spray to achieve initial code execution, (2) Use limited primitives to leak
              addresses, (3) Free spray objects to reclaim memory, (4) Perform targeted second-stage exploitation with leaked addresses. This multi-stage
              approach balances spray coverage with resource constraints and detection evasion.
            </Alert>
          </Box>

          {/* House of Techniques */}
          <Box id="house-of">
            <Typography variant="h4" sx={{ fontWeight: 800, mb: 1 }}>
               House of Techniques
            </Typography>
            <Typography variant="body1" color="text.secondary" sx={{ mb: 3 }}>
              Named exploitation techniques targeting specific allocator behaviors (primarily ptmalloc2)
            </Typography>

            <Grid container spacing={3} sx={{ mb: 5 }}>
              {houseOfTechniques.map((house) => (
                <Grid item xs={12} key={house.name}>
                  <Accordion
                    sx={{
                      borderRadius: 3,
                      border: `1px solid ${alpha("#8b5cf6", 0.2)}`,
                      "&:before": { display: "none" },
                    }}
                  >
                    <AccordionSummary
                      expandIcon={<ExpandMoreIcon />}
                      sx={{
                        bgcolor: alpha("#8b5cf6", 0.05),
                        "&:hover": { bgcolor: alpha("#8b5cf6", 0.08) },
                        borderRadius: 3,
                      }}
                    >
                      <Box sx={{ display: "flex", alignItems: "center", justifyContent: "space-between", width: "100%", gap: 2 }}>
                        <Box sx={{ display: "flex", alignItems: "center", gap: 2 }}>
                          <Typography variant="subtitle1" sx={{ fontWeight: 700, color: "#8b5cf6" }}>
                            {house.name}
                          </Typography>
                          <Chip label={house.difficulty} size="small" sx={{ bgcolor: alpha("#8b5cf6", 0.1), color: "#8b5cf6", fontWeight: 600 }} />
                        </Box>
                        <Chip
                          label={house.status}
                          size="small"
                          sx={{
                            bgcolor: house.status.includes("mitigated") ? alpha("#f59e0b", 0.1) : alpha("#10b981", 0.1),
                            color: house.status.includes("mitigated") ? "#f59e0b" : "#10b981",
                            fontWeight: 600,
                          }}
                        />
                      </Box>
                    </AccordionSummary>
                    <AccordionDetails>
                      <Typography variant="body2" sx={{ mb: 2 }}>
                        {house.description}
                      </Typography>
                      <Grid container spacing={2}>
                        <Grid item xs={12} md={6}>
                          <Typography variant="caption" sx={{ fontWeight: 700, display: "block", mb: 0.5 }}>
                            Target Allocator:
                          </Typography>
                          <Chip label={house.targetAllocator} size="small" variant="outlined" />
                        </Grid>
                        <Grid item xs={12}>
                          <Typography variant="caption" sx={{ fontWeight: 700, display: "block", mb: 0.5 }}>
                            Prerequisites:
                          </Typography>
                          <Typography variant="body2" color="text.secondary">
                            {house.prerequisites}
                          </Typography>
                        </Grid>
                        <Grid item xs={12}>
                          <Typography variant="caption" sx={{ fontWeight: 700, display: "block", mb: 0.5 }}>
                            Technique:
                          </Typography>
                          <Paper sx={{ p: 2, bgcolor: alpha("#8b5cf6", 0.03), borderRadius: 2 }}>
                            <Typography variant="body2">{house.technique}</Typography>
                          </Paper>
                        </Grid>
                      </Grid>
                    </AccordionDetails>
                  </Accordion>
                </Grid>
              ))}
            </Grid>

            <Alert severity="info" icon={<TipsAndUpdatesIcon />} sx={{ mb: 5, borderRadius: 3 }}>
              <AlertTitle sx={{ fontWeight: 700 }}>Learning Resources</AlertTitle>
              The how2heap GitHub repository (https://github.com/shellphish/how2heap) provides working proof-of-concept code for many House of techniques and
              other heap exploitation primitives, with examples for different glibc versions. This is an invaluable resource for hands-on learning.
            </Alert>
          </Box>

          {/* Exploitation Workflow */}
          <Box id="workflow">
            <Typography variant="h4" sx={{ fontWeight: 800, mb: 1 }}>
               Heap Exploitation Workflow
            </Typography>
            <Typography variant="body1" color="text.secondary" sx={{ mb: 3 }}>
              Systematic approach to developing heap exploitation from vulnerability to code execution
            </Typography>

            <Grid container spacing={3} sx={{ mb: 5 }}>
              {exploitWorkflow.map((item) => (
                <Grid item xs={12} md={6} key={item.step}>
                  <Paper
                    sx={{
                      p: 3,
                      height: "100%",
                      borderRadius: 3,
                      border: `1px solid ${alpha("#10b981", 0.2)}`,
                      transition: "all 0.2s",
                      "&:hover": {
                        boxShadow: `0 8px 24px ${alpha("#10b981", 0.15)}`,
                      },
                    }}
                  >
                    <Box sx={{ display: "flex", alignItems: "flex-start", gap: 2, mb: 2 }}>
                      <Box
                        sx={{
                          width: 48,
                          height: 48,
                          borderRadius: "50%",
                          bgcolor: "#10b981",
                          color: "white",
                          display: "flex",
                          alignItems: "center",
                          justifyContent: "center",
                          fontWeight: 800,
                          fontSize: "1.2rem",
                          flexShrink: 0,
                        }}
                      >
                        {item.step}
                      </Box>
                      <Box>
                        <Typography variant="h6" sx={{ fontWeight: 700 }}>
                          {item.phase}
                        </Typography>
                        <Typography variant="body2" color="text.secondary">
                          {item.description}
                        </Typography>
                      </Box>
                    </Box>
                    <List dense>
                      {item.details.map((detail, idx) => (
                        <ListItem key={idx} sx={{ py: 0.25 }}>
                          <ListItemIcon sx={{ minWidth: 24 }}>
                            <CheckCircleIcon sx={{ fontSize: 16, color: "#10b981" }} />
                          </ListItemIcon>
                          <ListItemText primary={detail} primaryTypographyProps={{ variant: "body2", fontSize: "0.85rem" }} />
                        </ListItem>
                      ))}
                    </List>
                  </Paper>
                </Grid>
              ))}
            </Grid>
          </Box>

          {/* Advanced Debugging Section */}
          <Box id="debugging">
            <Typography variant="h4" sx={{ fontWeight: 800, mb: 1 }}>
               Advanced Heap Debugging
            </Typography>
            <Typography variant="body1" color="text.secondary" sx={{ mb: 3 }}>
              Professional debugging techniques for heap analysis and exploitation development
            </Typography>

            <Paper sx={{ p: 4, mb: 3, borderRadius: 3, border: `1px solid ${alpha(theme.palette.divider, 0.1)}` }}>
              <Typography variant="body1" sx={{ mb: 2, lineHeight: 1.8 }}>
                Effective heap debugging is essential for developing reliable exploits and understanding allocator behavior. Unlike user-space debugging where
                you examine application state, heap debugging requires inspecting allocator internals: bin states, freelist chains, chunk metadata, arena
                structures, and memory layout. Modern debugger extensions like pwndbg and GEF provide specialized commands that parse and visualize heap
                structures, making complex allocator state comprehensible.
              </Typography>
              <Typography variant="body1" sx={{ mb: 2, lineHeight: 1.8 }}>
                The heap debugging workflow typically involves: (1) Setting breakpoints at key allocator functions (malloc, free, realloc), (2) Stepping through
                exploitation primitives while monitoring heap state, (3) Inspecting bin contents to verify grooming succeeded, (4) Examining chunk metadata to
                detect corruption or unexpected changes, (5) Comparing expected vs. actual memory layouts. Visualizing heap chunks graphically or as ASCII art
                helps identify adjacency relationships and spot anomalies.
              </Typography>
              <Typography variant="body1" sx={{ mb: 2, lineHeight: 1.8 }}>
                Memory dump interpretation is a critical skill. Raw heap dumps show chunk headers, user data, and freelist pointers. Understanding alignment,
                flag bits (PREV_INUSE, IS_MMAPPED), and pointer encoding (safe-linking XOR) is necessary to parse dumps correctly. Corrupted metadata often
                appears as suspicious sizes (too large, unaligned), invalid pointers (not heap addresses), or broken freelist chains (loops, null terminators).
              </Typography>
              <Typography variant="body1" sx={{ lineHeight: 1.8 }}>
                Common heap corruption scenarios have characteristic signatures. Double-frees show duplicate entries in bin freelists. Use-after-free manifests
                as freed chunks containing unexpected data patterns. Heap overflows corrupt adjacent chunk metadata (size fields, fd/bk pointers). Safe-linking
                violations appear as XOR-masked pointers that don't match expected values. Learning to recognize these patterns accelerates debugging and helps
                diagnose exploit failures quickly.
              </Typography>
            </Paper>

            <TableContainer component={Paper} sx={{ mb: 3, borderRadius: 3, border: `1px solid ${alpha(theme.palette.divider, 0.1)}` }}>
              <Table>
                <TableHead>
                  <TableRow sx={{ bgcolor: alpha("#06b6d4", 0.05) }}>
                    <TableCell sx={{ fontWeight: 700 }}>Tool</TableCell>
                    <TableCell sx={{ fontWeight: 700 }}>Command</TableCell>
                    <TableCell sx={{ fontWeight: 700 }}>Description</TableCell>
                    <TableCell sx={{ fontWeight: 700 }}>Example Usage</TableCell>
                  </TableRow>
                </TableHead>
                <TableBody>
                  {debuggingCommands.map((cmd, idx) => (
                    <TableRow key={idx} sx={{ "&:hover": { bgcolor: alpha("#06b6d4", 0.02) } }}>
                      <TableCell sx={{ fontWeight: 600, color: "#06b6d4" }}>{cmd.tool}</TableCell>
                      <TableCell sx={{ fontFamily: "monospace", fontSize: "0.85rem" }}>{cmd.command}</TableCell>
                      <TableCell sx={{ fontSize: "0.85rem" }}>{cmd.description}</TableCell>
                      <TableCell sx={{ fontFamily: "monospace", fontSize: "0.8rem" }}>{cmd.example}</TableCell>
                    </TableRow>
                  ))}
                </TableBody>
              </Table>
            </TableContainer>

            <Grid container spacing={3} sx={{ mb: 3 }}>
              <Grid item xs={12} md={6}>
                <Paper sx={{ p: 3, borderRadius: 3, bgcolor: alpha("#8b5cf6", 0.05), border: `1px solid ${alpha("#8b5cf6", 0.2)}`, height: "100%" }}>
                  <Typography variant="h6" sx={{ fontWeight: 700, mb: 2, display: "flex", alignItems: "center", gap: 1 }}>
                    <CodeIcon sx={{ color: "#8b5cf6" }} />
                    Memory Dump Interpretation
                  </Typography>
                  <Paper
                    sx={{
                      p: 2,
                      bgcolor: alpha("#000", 0.05),
                      fontFamily: "monospace",
                      fontSize: "0.75rem",
                      overflowX: "auto",
                      borderRadius: 2,
                    }}
                  >
                    <pre style={{ margin: 0 }}>
                      {`gdb-peda$ x/10gx 0x555555756000
0x555555756000: 0x0000000000000000  prev_size
0x555555756008: 0x0000000000000091  size (0x90 + PREV_INUSE)
0x555555756010: 0x00007ffff7dd2ca0  fd (libc address!)
0x555555756018: 0x00007ffff7dd2ca0  bk (libc address!)
0x555555756020: 0x4141414141414141  user data
0x555555756028: 0x4242424242424242  user data
0x555555756030: 0x4343434343434343  user data
0x555555756038: 0x0000000000000000  user data
0x555555756040: 0x0000000000000000  user data
0x555555756048: 0x0000000000000090  next chunk prev_size`}
                    </pre>
                  </Paper>
                  <Typography variant="caption" color="text.secondary" sx={{ display: "block", mt: 1 }}>
                    Freed chunk in unsorted bin - fd/bk point to libc (information leak opportunity!)
                  </Typography>
                </Paper>
              </Grid>

              <Grid item xs={12} md={6}>
                <Paper sx={{ p: 3, borderRadius: 3, bgcolor: alpha("#ef4444", 0.05), border: `1px solid ${alpha("#ef4444", 0.2)}`, height: "100%" }}>
                  <Typography variant="h6" sx={{ fontWeight: 700, mb: 2, display: "flex", alignItems: "center", gap: 1 }}>
                    <WarningIcon sx={{ color: "#ef4444" }} />
                    Corruption Detection
                  </Typography>
                  <Paper
                    sx={{
                      p: 2,
                      bgcolor: alpha("#000", 0.05),
                      fontFamily: "monospace",
                      fontSize: "0.75rem",
                      overflowX: "auto",
                      borderRadius: 2,
                    }}
                  >
                    <pre style={{ margin: 0 }}>
                      {`gdb-peda$ heap
Chunk(addr=0x555555756090, size=0x90, flags=PREV_INUSE)
Chunk(addr=0x555555756120, size=0xfffffffffffffff1)
                                     ^^^^ CORRUPTED!
    Size too large and not aligned!
    Likely heap overflow corrupted size field

gdb-peda$ bins
tcachebins
0x90 [7]: 0x555555756010 -> 0x555555756010
          ^^^^^^^^^^^^^^^^    ^^^^^^^^^^^^^^^^
          LOOP DETECTED! Double-free or corruption`}
                    </pre>
                  </Paper>
                  <Typography variant="caption" color="text.secondary" sx={{ display: "block", mt: 1 }}>
                    Common corruption signatures: invalid sizes, freelist loops, non-heap pointers
                  </Typography>
                </Paper>
              </Grid>
            </Grid>

            <Paper sx={{ p: 3, mb: 3, borderRadius: 3, bgcolor: alpha("#10b981", 0.05), border: `1px solid ${alpha("#10b981", 0.2)}` }}>
              <Typography variant="h6" sx={{ fontWeight: 700, mb: 2, display: "flex", alignItems: "center", gap: 1 }}>
                <TipsAndUpdatesIcon sx={{ color: "#10b981" }} />
                Heap Debugging Workflow
              </Typography>
              <List>
                <ListItem>
                  <ListItemIcon>
                    <CheckCircleIcon sx={{ color: "#10b981" }} />
                  </ListItemIcon>
                  <ListItemText
                    primary="Set breakpoint before critical allocation/free"
                    secondary="Example: break malloc, break free, break __libc_malloc"
                  />
                </ListItem>
                <ListItem>
                  <ListItemIcon>
                    <CheckCircleIcon sx={{ color: "#10b981" }} />
                  </ListItemIcon>
                  <ListItemText primary="Run heap command to snapshot chunk layout" secondary="pwndbg: heap, heap -v for verbose" />
                </ListItem>
                <ListItem>
                  <ListItemIcon>
                    <CheckCircleIcon sx={{ color: "#10b981" }} />
                  </ListItemIcon>
                  <ListItemText primary="Check bin states before and after operations" secondary="pwndbg: bins (shows all bin types)" />
                </ListItem>
                <ListItem>
                  <ListItemIcon>
                    <CheckCircleIcon sx={{ color: "#10b981" }} />
                  </ListItemIcon>
                  <ListItemText primary="Examine specific chunks in detail" secondary="pwndbg: malloc_chunk <address>, x/20gx <address>" />
                </ListItem>
                <ListItem>
                  <ListItemIcon>
                    <CheckCircleIcon sx={{ color: "#10b981" }} />
                  </ListItemIcon>
                  <ListItemText
                    primary="Compare expected vs actual state"
                    secondary="Did chunk go to expected bin? Is adjacency correct? Are pointers sane?"
                  />
                </ListItem>
                <ListItem>
                  <ListItemIcon>
                    <CheckCircleIcon sx={{ color: "#10b981" }} />
                  </ListItemIcon>
                  <ListItemText primary="Iterate and adjust grooming strategy" secondary="Modify allocation sequence based on observed behavior" />
                </ListItem>
              </List>
            </Paper>

            <Alert severity="info" icon={<InfoIcon />} sx={{ mb: 5, borderRadius: 3 }}>
              <AlertTitle sx={{ fontWeight: 700 }}>Automation Tip</AlertTitle>
              For complex heap exploits, consider writing GDB Python scripts that automate state checking. Scripts can parse bin states, validate chunk
              relationships, and alert on unexpected conditions. Pwndbg and GEF provide Python APIs for accessing allocator internals programmatically,
              enabling sophisticated automated debugging.
            </Alert>
          </Box>

          {/* Case Studies */}
          <Box id="case-studies">
            <Typography variant="h4" sx={{ fontWeight: 800, mb: 1 }}>
               Real-World Case Studies
            </Typography>
            <Typography variant="body1" color="text.secondary" sx={{ mb: 3 }}>
              Detailed analysis of notable heap exploitation CVEs
            </Typography>

            <Grid container spacing={3} sx={{ mb: 5 }}>
              {caseStudies.map((study) => (
                <Grid item xs={12} key={study.id}>
                  <Accordion
                    sx={{
                      borderRadius: 3,
                      border: `1px solid ${alpha(
                        study.severity === "Critical" ? "#ef4444" : study.severity === "High" ? "#f59e0b" : "#10b981",
                        0.2
                      )}`,
                      "&:before": { display: "none" },
                    }}
                  >
                    <AccordionSummary
                      expandIcon={<ExpandMoreIcon />}
                      sx={{
                        bgcolor: alpha(study.severity === "Critical" ? "#ef4444" : study.severity === "High" ? "#f59e0b" : "#10b981", 0.05),
                        "&:hover": {
                          bgcolor: alpha(study.severity === "Critical" ? "#ef4444" : study.severity === "High" ? "#f59e0b" : "#10b981", 0.08),
                        },
                        borderRadius: 3,
                      }}
                    >
                      <Box sx={{ display: "flex", alignItems: "center", justifyContent: "space-between", width: "100%", gap: 2 }}>
                        <Box sx={{ flex: 1 }}>
                          <Box sx={{ display: "flex", alignItems: "center", gap: 2, mb: 0.5 }}>
                            <Typography variant="h6" sx={{ fontWeight: 700 }}>
                              {study.name}
                            </Typography>
                            <Chip
                              label={study.severity}
                              size="small"
                              sx={{
                                bgcolor: alpha(study.severity === "Critical" ? "#ef4444" : "#f59e0b", 0.1),
                                color: study.severity === "Critical" ? "#ef4444" : "#f59e0b",
                                fontWeight: 700,
                              }}
                            />
                            <Chip label={study.year} size="small" variant="outlined" />
                          </Box>
                          <Typography variant="body2" color="text.secondary">
                            {study.cve} - {study.vulnerabilityType}
                          </Typography>
                        </Box>
                      </Box>
                    </AccordionSummary>
                    <AccordionDetails>
                      <Grid container spacing={3}>
                        <Grid item xs={12}>
                          <Typography variant="h6" sx={{ fontWeight: 700, mb: 1 }}>
                            Overview
                          </Typography>
                          <Typography variant="body2" sx={{ mb: 2 }}>
                            {study.description}
                          </Typography>
                        </Grid>

                        <Grid item xs={12} md={6}>
                          <Paper sx={{ p: 2, bgcolor: alpha("#3b82f6", 0.03), borderRadius: 2, height: "100%" }}>
                            <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 1 }}>
                              Affected Software
                            </Typography>
                            <Typography variant="body2" color="text.secondary">
                              {study.affectedSoftware}
                            </Typography>
                          </Paper>
                        </Grid>

                        <Grid item xs={12} md={6}>
                          <Paper sx={{ p: 2, bgcolor: alpha("#ef4444", 0.03), borderRadius: 2, height: "100%" }}>
                            <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 1 }}>
                              Impact
                            </Typography>
                            <Typography variant="body2" color="text.secondary">
                              {study.impact}
                            </Typography>
                          </Paper>
                        </Grid>

                        <Grid item xs={12}>
                          <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 1 }}>
                            Technical Details
                          </Typography>
                          <List dense>
                            {study.technicalDetails.map((detail, idx) => (
                              <ListItem key={idx} sx={{ py: 0.25 }}>
                                <ListItemIcon sx={{ minWidth: 28 }}>
                                  <BugReportIcon sx={{ fontSize: 16, color: "#ef4444" }} />
                                </ListItemIcon>
                                <ListItemText primary={detail} primaryTypographyProps={{ variant: "body2" }} />
                              </ListItem>
                            ))}
                          </List>
                        </Grid>

                        <Grid item xs={12}>
                          <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 1 }}>
                            Exploitation Steps
                          </Typography>
                          <List dense>
                            {study.exploitationSteps.map((step, idx) => (
                              <ListItem key={idx} sx={{ py: 0.5, alignItems: "flex-start" }}>
                                <ListItemIcon sx={{ minWidth: 36, mt: 0.5 }}>
                                  <Chip
                                    label={idx + 1}
                                    size="small"
                                    sx={{ width: 24, height: 24, fontSize: "0.7rem", bgcolor: "#8b5cf6", color: "white" }}
                                  />
                                </ListItemIcon>
                                <ListItemText primary={step} primaryTypographyProps={{ variant: "body2" }} />
                              </ListItem>
                            ))}
                          </List>
                        </Grid>

                        <Grid item xs={12}>
                          <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 1 }}>
                            Mitigations
                          </Typography>
                          <Box sx={{ display: "flex", gap: 1, flexWrap: "wrap" }}>
                            {study.mitigations.map((mitigation, idx) => (
                              <Chip key={idx} label={mitigation} size="small" sx={{ bgcolor: alpha("#10b981", 0.1), color: "#10b981" }} />
                            ))}
                          </Box>
                        </Grid>

                        <Grid item xs={12}>
                          <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 1 }}>
                            References
                          </Typography>
                          <Box sx={{ display: "flex", gap: 1, flexWrap: "wrap" }}>
                            {study.references.map((ref, idx) => (
                              <Chip key={idx} label={ref} size="small" variant="outlined" clickable />
                            ))}
                          </Box>
                        </Grid>
                      </Grid>
                    </AccordionDetails>
                  </Accordion>
                </Grid>
              ))}
            </Grid>

            <Alert severity="success" icon={<SecurityIcon />} sx={{ mb: 5, borderRadius: 3 }}>
              <AlertTitle sx={{ fontWeight: 700 }}>Learning from Real Exploits</AlertTitle>
              Studying real-world CVEs teaches practical exploitation techniques, common vulnerability patterns, and defensive strategies. Notice how modern
              exploits often chain multiple primitives (leak -&gt; groom -&gt; corrupt -&gt; execute) and combine heap exploitation with other techniques (ROP,
              format strings). Pay attention to how attackers bypassed mitigations and how defenders responded with patches and hardening.
            </Alert>
          </Box>

          {/* Mitigations */}
          <Box id="mitigations">
            <Typography variant="h4" sx={{ fontWeight: 800, mb: 1 }}>
               Mitigations and Hardening
            </Typography>
            <Typography variant="body1" color="text.secondary" sx={{ mb: 3 }}>
              Modern defenses against heap exploitation and their effectiveness
            </Typography>

            <Grid container spacing={3} sx={{ mb: 5 }}>
              {mitigationsList.map((category) => (
                <Grid item xs={12} md={6} key={category.category}>
                  <Paper
                    sx={{
                      p: 3,
                      height: "100%",
                      borderRadius: 3,
                      border: `1px solid ${alpha(category.color, 0.2)}`,
                    }}
                  >
                    <Typography variant="h6" sx={{ fontWeight: 700, mb: 2, color: category.color }}>
                      {category.category}
                    </Typography>
                    <List dense>
                      {category.items.map((item) => (
                        <ListItem key={item.name} sx={{ flexDirection: "column", alignItems: "flex-start", py: 1.5, px: 0 }}>
                          <Box sx={{ display: "flex", alignItems: "center", gap: 1, mb: 0.5, width: "100%" }}>
                            <Typography variant="subtitle2" sx={{ fontWeight: 700, flex: 1 }}>
                              {item.name}
                            </Typography>
                            <Chip
                              label={item.effectiveness}
                              size="small"
                              sx={{
                                bgcolor:
                                  item.effectiveness === "Very High"
                                    ? alpha("#10b981", 0.1)
                                    : item.effectiveness === "High"
                                      ? alpha("#3b82f6", 0.1)
                                      : item.effectiveness === "Medium"
                                        ? alpha("#f59e0b", 0.1)
                                        : alpha("#6b7280", 0.1),
                                color:
                                  item.effectiveness === "Very High"
                                    ? "#10b981"
                                    : item.effectiveness === "High"
                                      ? "#3b82f6"
                                      : item.effectiveness === "Medium"
                                        ? "#f59e0b"
                                        : "#6b7280",
                                fontWeight: 600,
                                fontSize: "0.7rem",
                              }}
                            />
                          </Box>
                          <Typography variant="caption" color="text.secondary">
                            {item.description}
                          </Typography>
                        </ListItem>
                      ))}
                    </List>
                  </Paper>
                </Grid>
              ))}
            </Grid>

            <Alert severity="warning" icon={<SecurityIcon />} sx={{ mb: 5, borderRadius: 3 }}>
              <AlertTitle sx={{ fontWeight: 700 }}>Bypass Techniques Exist</AlertTitle>
              While modern mitigations significantly raise the bar for heap exploitation, determined attackers can often bypass them. Safe-linking can be
              defeated with heap address leaks, ASLR can be bypassed via information disclosure, and tcache keys can be overwritten. Defense in depth is
              essentialcombine multiple mitigations, use hardened allocators in security-critical contexts, and employ runtime monitoring.
            </Alert>
          </Box>

          {/* Tools Section */}
          <Box id="tools">
            <Typography variant="h4" sx={{ fontWeight: 800, mb: 1 }}>
               Essential Tools for Heap Exploitation
            </Typography>
            <Typography variant="body1" color="text.secondary" sx={{ mb: 3 }}>
              Debuggers, frameworks, and utilities for heap analysis and exploit development
            </Typography>

            <Grid container spacing={3} sx={{ mb: 5 }}>
              {heapTools.map((tool) => (
                <Grid item xs={12} md={6} key={tool.name}>
                  <Paper
                    sx={{
                      p: 3,
                      height: "100%",
                      borderRadius: 3,
                      border: `1px solid ${alpha("#3b82f6", 0.2)}`,
                      transition: "all 0.2s",
                      "&:hover": {
                        transform: "translateY(-2px)",
                        boxShadow: `0 8px 24px ${alpha("#3b82f6", 0.15)}`,
                      },
                    }}
                  >
                    <Box sx={{ display: "flex", alignItems: "center", gap: 2, mb: 2 }}>
                      <Box
                        sx={{
                          width: 48,
                          height: 48,
                          borderRadius: 2,
                          bgcolor: alpha("#3b82f6", 0.1),
                          display: "flex",
                          alignItems: "center",
                          justifyContent: "center",
                          color: "#3b82f6",
                        }}
                      >
                        <BuildIcon />
                      </Box>
                      <Box>
                        <Typography variant="h6" sx={{ fontWeight: 700 }}>
                          {tool.name}
                        </Typography>
                        <Chip label={tool.category} size="small" sx={{ bgcolor: alpha("#3b82f6", 0.1), color: "#3b82f6" }} />
                      </Box>
                    </Box>
                    <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
                      {tool.description}
                    </Typography>
                    <Typography variant="caption" sx={{ fontWeight: 700, display: "block", mb: 0.5 }}>
                      Key Features:
                    </Typography>
                    <List dense>
                      {tool.keyFeatures.map((feature, idx) => (
                        <ListItem key={idx} sx={{ py: 0.25, px: 0 }}>
                          <ListItemIcon sx={{ minWidth: 20 }}>
                            <CheckCircleIcon sx={{ fontSize: 14, color: "#3b82f6" }} />
                          </ListItemIcon>
                          <ListItemText primary={feature} primaryTypographyProps={{ variant: "caption" }} />
                        </ListItem>
                      ))}
                    </List>
                    <Chip label={tool.platform} size="small" variant="outlined" sx={{ mt: 1, borderColor: alpha("#3b82f6", 0.3) }} />
                  </Paper>
                </Grid>
              ))}
            </Grid>

            <Paper sx={{ p: 3, mb: 5, borderRadius: 3, bgcolor: alpha("#06b6d4", 0.05), border: `1px solid ${alpha("#06b6d4", 0.2)}` }}>
              <Typography variant="h6" sx={{ fontWeight: 700, mb: 2, display: "flex", alignItems: "center", gap: 1 }}>
                <TipsAndUpdatesIcon sx={{ color: "#06b6d4" }} />
                GDB Commands for Heap Analysis
              </Typography>
              <Paper
                sx={{
                  p: 2,
                  bgcolor: alpha("#000", 0.05),
                  fontFamily: "monospace",
                  fontSize: "0.85rem",
                  overflowX: "auto",
                  borderRadius: 2,
                }}
              >
                <pre style={{ margin: 0 }}>
                  {`# pwndbg commands (after installing pwndbg)
heap                    # Show all heap chunks
bins                    # Display bin/freelist state
vis_heap_chunks         # Visual heap layout
tcache                  # Show tcache state
fastbins                # Show fastbin state
arenas                  # List all arenas
heap -v                 # Verbose heap info

# GEF commands (after installing GEF)
heap chunks             # List all chunks
heap bins               # Show bins
heap arenas             # Show arenas

# Standard GDB
x/20gx <address>        # Examine memory as 64-bit hex
p *(struct malloc_chunk *)<addr>  # Print chunk structure
info proc mappings      # Show memory map (find heap)
vmmap                   # pwndbg: show memory map with colors`}
                </pre>
              </Paper>
            </Paper>
          </Box>

          {/* Related Learning */}
          <Paper sx={{ p: 3, mb: 5, borderRadius: 3, bgcolor: alpha("#8b5cf6", 0.05), border: `1px solid ${alpha("#8b5cf6", 0.2)}` }}>
            <Typography variant="h6" sx={{ fontWeight: 700, mb: 2, display: "flex", alignItems: "center", gap: 1 }}>
              <SchoolIcon sx={{ color: "#8b5cf6" }} />
              Related Learning Topics
            </Typography>
            <Box sx={{ display: "flex", gap: 1, flexWrap: "wrap" }}>
              <Chip label="Buffer Overflow " clickable onClick={() => navigate("/learn/buffer-overflow")} sx={{ fontWeight: 600 }} />
              <Chip label="Return-Oriented Programming " clickable onClick={() => navigate("/learn/rop")} sx={{ fontWeight: 600 }} />
              <Chip label="Binary Analysis Guide " clickable onClick={() => navigate("/learn/binary-analysis")} sx={{ fontWeight: 600 }} />
              <Chip label="Linux Internals for RE " clickable onClick={() => navigate("/learn/linux-internals-re")} sx={{ fontWeight: 600 }} />
            </Box>
          </Paper>

          {/* Quiz Section */}
          <Paper
            id="quiz"
            sx={{
              p: 4,
              borderRadius: 3,
              border: `1px solid ${alpha(QUIZ_ACCENT_COLOR, 0.2)}`,
            }}
          >
            <Typography variant="h5" sx={{ fontWeight: 800, mb: 3, display: "flex", alignItems: "center", gap: 2 }}>
              <QuizIcon sx={{ color: QUIZ_ACCENT_COLOR }} />
              Knowledge Check
            </Typography>
            <QuizSection
              questions={quizQuestions}
              accentColor={QUIZ_ACCENT_COLOR}
              title="Heap Exploitation Knowledge Check"
              description="Random 10-question quiz drawn from a 75-question bank covering allocator internals, exploitation techniques, and mitigations."
              questionsPerQuiz={QUIZ_QUESTION_COUNT}
            />
          </Paper>

          {/* Bottom Navigation */}
          <Box sx={{ mt: 4, textAlign: "center" }}>
            <Button
              variant="outlined"
              startIcon={<ArrowBackIcon />}
              onClick={() => navigate("/learn")}
              sx={{ borderColor: "#ef4444", color: "#ef4444" }}
            >
              Back to Learning Hub
            </Button>
          </Box>
        </Container>

        {/* Scroll to Top FAB */}
        {showScrollTop && (
          <Tooltip title="Scroll to top" placement="left">
            <IconButton
              onClick={scrollToTop}
              sx={{
                position: "fixed",
                bottom: 24,
                right: 24,
                bgcolor: accent,
                color: "white",
                "&:hover": {
                  bgcolor: alpha(accent, 0.8),
                },
                boxShadow: `0 4px 20px ${alpha(accent, 0.3)}`,
              }}
            >
              <KeyboardArrowUpIcon />
            </IconButton>
          </Tooltip>
        )}
      </Box>
    </LearnPageLayout>
  );
}
