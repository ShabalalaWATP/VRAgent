import React, { useState, useEffect, useRef } from "react";
import {
  Box,
  Container,
  Typography,
  Paper,
  Tabs,
  Tab,
  Chip,
  Button,
  Accordion,
  AccordionSummary,
  AccordionDetails,
  Grid,
  List,
  ListItem,
  ListItemIcon,
  ListItemText,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  IconButton,
  Tooltip,
  Alert,
  Drawer,
  Fab,
  Zoom,
  Divider,
  useTheme,
  useMediaQuery,
  alpha,
} from "@mui/material";
import ArrowBackIcon from "@mui/icons-material/ArrowBack";
import ExpandMoreIcon from "@mui/icons-material/ExpandMore";
import ContentCopyIcon from "@mui/icons-material/ContentCopy";
import RouterIcon from "@mui/icons-material/Router";
import SecurityIcon from "@mui/icons-material/Security";
import ShieldIcon from "@mui/icons-material/Shield";
import WarningIcon from "@mui/icons-material/Warning";
import CheckCircleIcon from "@mui/icons-material/CheckCircle";
import SearchIcon from "@mui/icons-material/Search";
import TuneIcon from "@mui/icons-material/Tune";
import StorageIcon from "@mui/icons-material/Storage";
import BuildIcon from "@mui/icons-material/Build";
import MenuBookIcon from "@mui/icons-material/MenuBook";
import KeyboardArrowUp from "@mui/icons-material/KeyboardArrowUp";
import ListIcon from "@mui/icons-material/List";
import SchoolIcon from "@mui/icons-material/School";
import NetworkCheckIcon from "@mui/icons-material/NetworkCheck";
import LanIcon from "@mui/icons-material/Lan";
import DnsIcon from "@mui/icons-material/Dns";
import HttpIcon from "@mui/icons-material/Http";
import VpnKeyIcon from "@mui/icons-material/VpnKey";
import BugReportIcon from "@mui/icons-material/BugReport";
import { Link, useNavigate } from "react-router-dom";
import LearnPageLayout from "../components/LearnPageLayout";

interface TabPanelProps {
  children?: React.ReactNode;
  index: number;
  value: number;
}

function TabPanel(props: TabPanelProps) {
  const { children, value, index, ...other } = props;
  return (
    <div role="tabpanel" hidden={value !== index} {...other}>
      {value === index && <Box sx={{ py: 3 }}>{children}</Box>}
    </div>
  );
}

const CodeBlock: React.FC<{ code: string; language?: string }> = ({
  code,
  language = "bash",
}) => {
  const [copied, setCopied] = useState(false);

  const handleCopy = () => {
    navigator.clipboard.writeText(code);
    setCopied(true);
    setTimeout(() => setCopied(false), 2000);
  };

  return (
    <Paper
      sx={{
        p: 2,
        bgcolor: "#101626",
        borderRadius: 2,
        position: "relative",
        my: 2,
        border: "1px solid rgba(14, 165, 233, 0.3)",
      }}
    >
      <Box sx={{ position: "absolute", top: 8, right: 8, display: "flex", gap: 1 }}>
        <Chip label={language} size="small" sx={{ bgcolor: "#0ea5e9", color: "#0b1020" }} />
        <Tooltip title={copied ? "Copied!" : "Copy"}>
          <IconButton size="small" onClick={handleCopy} sx={{ color: "#e2e8f0" }}>
            <ContentCopyIcon fontSize="small" />
          </IconButton>
        </Tooltip>
      </Box>
      <Box
        component="pre"
        sx={{
          m: 0,
          overflow: "auto",
          fontFamily: "monospace",
          fontSize: "0.85rem",
          color: "#e2e8f0",
          pt: 2,
        }}
      >
        {code}
      </Box>
    </Paper>
  );
};

const NetworkProtocolExploitationPage: React.FC = () => {
  const navigate = useNavigate();
  const [tabValue, setTabValue] = useState(0);
  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down('md'));
  const [tocOpen, setTocOpen] = useState(false);
  const [showScrollTop, setShowScrollTop] = useState(false);
  const contentRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    const handleScroll = () => {
      setShowScrollTop(window.scrollY > 400);
    };
    window.addEventListener('scroll', handleScroll);
    return () => window.removeEventListener('scroll', handleScroll);
  }, []);

  const scrollToTop = () => {
    window.scrollTo({ top: 0, behavior: 'smooth' });
  };

  // ===========================================
  // PART 1: NETWORKING FUNDAMENTALS FOR BEGINNERS
  // ===========================================

  // Comprehensive introduction to networking concepts
  const networkingFundamentals = {
    whatIsNetworking: {
      title: "What is Computer Networking?",
      content: `Imagine you want to send a letter to a friend in another city. You write the letter, put it in an envelope, 
write the address, and drop it in a mailbox. The postal service picks it up, sorts it, routes it through 
various facilities, and eventually delivers it to your friend's mailbox. Your friend opens the envelope and reads your message.

Computer networking works remarkably similarly! When you visit a website, send an email, or stream a video, 
your computer is essentially "sending letters" to other computers. But instead of paper letters, we send 
packets of digital data. And instead of postal workers, we have routers, switches, and protocols that handle 
the delivery.

**The Key Players in Networking:**
‚Ä¢ **Your Device (Client)**: Your computer, phone, or tablet that initiates communication
‚Ä¢ **Servers**: Powerful computers that store websites, apps, and data, waiting to respond to requests
‚Ä¢ **Routers**: Like postal sorting facilities - they read addresses and decide where to send packets next
‚Ä¢ **Switches**: Connect multiple devices on the same local network, like a mail room in an office building
‚Ä¢ **Protocols**: The agreed-upon rules for how devices communicate - like knowing to put a stamp in the corner

**Why This Matters for Security:**
Every step in this process is a potential target for attackers. They might:
‚Ä¢ Intercept your "letters" and read them (eavesdropping)
‚Ä¢ Forge letters that appear to come from you (spoofing)
‚Ä¢ Overwhelm the postal system with millions of fake letters (denial of service)
‚Ä¢ Trick the routing system into delivering letters to the wrong place (routing attacks)

Understanding how networks work is the first step to understanding how they can be exploited and defended.`
    },
    packetsExplained: {
      title: "What is a Packet?",
      content: `When you send a file over the internet, it doesn't travel as one big chunk. Instead, it gets broken 
into smaller pieces called **packets**. Think of it like shipping a large piece of furniture - you might 
disassemble it, ship each piece separately with instructions, and reassemble it at the destination.

**Why Break Data into Packets?**
1. **Efficiency**: Multiple conversations can share the same network wires
2. **Reliability**: If one packet gets lost, only that piece needs to be resent
3. **Routing Flexibility**: Different packets can take different paths to the destination
4. **Error Handling**: Smaller chunks are easier to verify for errors

**Anatomy of a Packet:**
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  HEADERS (Address & Control Information)        ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îÇ  ‚îÇ Source IP: 192.168.1.100                ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ Destination IP: 142.250.80.46           ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ Protocol: TCP                           ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ Source Port: 54321                      ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ Destination Port: 443                   ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ Sequence Number: 12847                  ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ Checksum: 0x8a4f                        ‚îÇ   ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  PAYLOAD (The Actual Data)                      ‚îÇ
‚îÇ  "GET /search?q=cats HTTP/1.1..."              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

**Security Implications:**
‚Ä¢ Headers are usually NOT encrypted (attackers can see where traffic is going)
‚Ä¢ Payload MAY be encrypted (with HTTPS/TLS) or may be plaintext
‚Ä¢ Forged headers can make packets appear to come from somewhere else
‚Ä¢ Malformed packets can crash poorly-written software`
    },
    osiModel: {
      title: "The OSI Model: Network Layers Explained",
      content: `The OSI (Open Systems Interconnection) model is a way to understand networks by dividing them into 
7 layers, each with a specific job. Think of it like building a house - you need a foundation (physical), 
framing (structure), electrical (connectivity), and so on. Each layer depends on the ones below it.

**Layer 7 - Application Layer** üñ•Ô∏è
What you see and interact with. Web browsers, email clients, chat apps.
Examples: HTTP, HTTPS, FTP, SMTP, DNS
Security Issues: SQL injection, XSS, authentication bypasses

**Layer 6 - Presentation Layer** üî§
Translates data formats, handles encryption/decryption, compression.
Examples: SSL/TLS encryption, JPEG encoding, data serialization
Security Issues: Weak encryption, format string bugs

**Layer 5 - Session Layer** ü§ù
Manages sessions and connections between applications.
Examples: Session tokens, RPC sessions, NetBIOS
Security Issues: Session hijacking, fixation attacks

**Layer 4 - Transport Layer** üöö
Ensures reliable delivery of data segments. TCP and UDP live here.
Examples: TCP (reliable), UDP (fast), port numbers
Security Issues: SYN floods, port scanning, connection hijacking

**Layer 3 - Network Layer** üó∫Ô∏è
Handles addressing and routing between different networks. IP addresses.
Examples: IP, ICMP, routing protocols (BGP, OSPF)
Security Issues: IP spoofing, route hijacking, ICMP attacks

**Layer 2 - Data Link Layer** üîó
Handles communication within the same network segment. MAC addresses.
Examples: Ethernet, Wi-Fi (802.11), ARP, switches
Security Issues: ARP spoofing, MAC flooding, VLAN hopping

**Layer 1 - Physical Layer** üîå
The actual cables, radio waves, and electrical signals.
Examples: Ethernet cables, fiber optics, Wi-Fi radio
Security Issues: Wiretapping, jamming, physical access

**Memory Aid: "All People Seem To Need Data Processing"**
(Application, Presentation, Session, Transport, Network, Data Link, Physical)

**Why This Matters:**
When analyzing network attacks, identifying the layer helps you understand:
‚Ä¢ What tools to use for detection
‚Ä¢ What defenses are relevant
‚Ä¢ What information the attacker has access to`
    },
    tcpIpStack: {
      title: "The TCP/IP Model: How the Internet Actually Works",
      content: `While the OSI model is great for learning, the internet actually uses the **TCP/IP model**, 
which simplifies things into 4 layers. This is the real-world protocol suite that powers everything you do online.

**TCP/IP Layer Stack:**

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  APPLICATION LAYER                                          ‚îÇ
‚îÇ  HTTP, HTTPS, DNS, SMTP, FTP, SSH, Telnet                  ‚îÇ
‚îÇ  "What service are we using?"                               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  TRANSPORT LAYER                                            ‚îÇ
‚îÇ  TCP (reliable) or UDP (fast)                              ‚îÇ
‚îÇ  "How do we ensure delivery?"                               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  INTERNET LAYER                                             ‚îÇ
‚îÇ  IP addressing, routing, ICMP                              ‚îÇ
‚îÇ  "How do we find the destination?"                          ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  NETWORK ACCESS LAYER                                       ‚îÇ
‚îÇ  Ethernet, Wi-Fi, physical transmission                    ‚îÇ
‚îÇ  "How do we physically send the bits?"                      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

**A Real-World Example: Loading a Webpage**

When you type "www.google.com" and press Enter, here's what happens:

1. **Application Layer**: Your browser creates an HTTP request
2. **Transport Layer**: TCP breaks it into segments, adds port numbers (80 or 443)
3. **Internet Layer**: IP adds source and destination addresses, finds the route
4. **Network Access**: Ethernet frames the packet, sends it over the wire

At Google's server, this process reverses:
4. Network Access receives the electrical signals
3. IP layer reads the destination address, accepts the packet
2. TCP reassembles the segments, sends to the right port
1. The web server application processes your request

**TCP vs UDP: The Two Transport Protocols**

TCP (Transmission Control Protocol):
‚Ä¢ Reliable - guarantees delivery in order
‚Ä¢ Uses a "handshake" to establish connection
‚Ä¢ Retransmits lost packets
‚Ä¢ Used for: Web browsing, email, file transfers
‚Ä¢ Slower but dependable

UDP (User Datagram Protocol):
‚Ä¢ Fast but "best effort" - no guarantee
‚Ä¢ No handshake needed
‚Ä¢ Lost packets stay lost
‚Ä¢ Used for: Video streaming, gaming, DNS queries
‚Ä¢ Fast but unreliable

**The TCP Three-Way Handshake:**

  Client                    Server
    ‚îÇ                          ‚îÇ
    ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ SYN ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ  "Can we talk?"
    ‚îÇ                          ‚îÇ
    ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ SYN-ACK ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ  "Yes, let's talk"
    ‚îÇ                          ‚îÇ
    ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ACK ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ  "Great, starting now"
    ‚îÇ                          ‚îÇ
    ‚îÇ      CONNECTION          ‚îÇ
    ‚îÇ      ESTABLISHED         ‚îÇ

This handshake is a MAJOR attack target. SYN flood attacks abuse this by sending millions of SYNs 
without completing the handshake, exhausting server resources.`
    },
    ipAddressing: {
      title: "IP Addresses: The Postal Addresses of the Internet",
      content: `Every device on the internet needs a unique address so data can find it. That's what IP addresses do.
There are two versions in use today: IPv4 (older, more common) and IPv6 (newer, gradually being adopted).

**IPv4 Addresses:**
Format: Four numbers (0-255) separated by dots
Example: 192.168.1.100

Each number is 8 bits (1 byte), so IPv4 = 32 bits total
Total possible addresses: ~4.3 billion (we've run out!)

**Private vs Public IP Addresses:**

Private IPs (used inside your network):
‚Ä¢ 10.0.0.0 - 10.255.255.255
‚Ä¢ 172.16.0.0 - 172.31.255.255  
‚Ä¢ 192.168.0.0 - 192.168.255.255

These addresses are NOT routable on the internet. Your home router uses NAT 
(Network Address Translation) to let multiple devices share one public IP.

Public IPs (routable on the internet):
‚Ä¢ Everything else
‚Ä¢ Your ISP assigns you one (or more)
‚Ä¢ This is what websites see when you connect

**IPv6 Addresses:**
Format: Eight groups of 4 hex digits, separated by colons
Example: 2001:0db8:85a3:0000:0000:8a2e:0370:7334
Shortened: 2001:db8:85a3::8a2e:370:7334

IPv6 = 128 bits = 340 undecillion addresses (enough for every atom on Earth!)

**Ports: The Apartment Numbers**

If an IP address is like a street address, a port is like an apartment number.
One server (one IP) can run many services (many ports).

Well-Known Ports (0-1023):
‚Ä¢ 21: FTP (file transfer)
‚Ä¢ 22: SSH (secure shell)
‚Ä¢ 23: Telnet (insecure remote access)
‚Ä¢ 25: SMTP (email sending)
‚Ä¢ 53: DNS (domain name resolution)
‚Ä¢ 80: HTTP (web traffic)
‚Ä¢ 443: HTTPS (secure web traffic)
‚Ä¢ 445: SMB (Windows file sharing)
‚Ä¢ 3389: RDP (Windows remote desktop)

**Security Implications:**
‚Ä¢ Attackers scan ports to find running services
‚Ä¢ Services on unexpected ports might be hiding
‚Ä¢ Open ports = potential attack surface
‚Ä¢ Every listening port should be intentional and secured`
    },
    howDataFlows: {
      title: "How Data Actually Flows Across the Internet",
      content: `Let's trace what happens when you visit https://www.example.com from start to finish.
This will tie together everything we've discussed.

**Step 1: DNS Resolution** üîç
Your browser doesn't know what 142.250.80.46 is. It only knows "www.example.com"

Browser ‚Üí "Hey OS, what's the IP for www.example.com?"
OS ‚Üí Checks local cache, then asks your configured DNS server
DNS Server ‚Üí "That's 93.184.216.34"
OS ‚Üí Caches the answer, tells browser

**Step 2: TCP Connection** ü§ù
Your browser needs to establish a connection to port 443 (HTTPS)

Your PC ‚îÄ‚îÄSYN‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ> example.com:443
Your PC <‚îÄ‚îÄSYN-ACK‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ example.com:443  
Your PC ‚îÄ‚îÄACK‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ> example.com:443
Connection established!

**Step 3: TLS Handshake** üîê
Before sending any data, we need to set up encryption

Browser ‚Üí "Hello! I support TLS 1.3, these ciphers..."
Server ‚Üí "Great, let's use TLS 1.3 with AES-256. Here's my certificate"
Browser ‚Üí Verifies certificate is valid and trusted
Both ‚Üí Derive shared encryption keys
Secure channel established!

**Step 4: HTTP Request** üì§
Now your browser sends the actual request (encrypted)

GET / HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0...
Accept: text/html...

**Step 5: Server Processing** ‚öôÔ∏è
example.com's web server:
‚Ä¢ Receives the request
‚Ä¢ Finds the homepage file
‚Ä¢ Prepares the response

**Step 6: HTTP Response** üì•
Server sends back (encrypted):

HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 1256

<!DOCTYPE html>
<html>...

**Step 7: Rendering** üñºÔ∏è
Browser decrypts, parses HTML, requests CSS/JS/images, renders the page

**Step 8: Connection Teardown** üëã
When done, TCP gracefully closes:

PC ‚îÄ‚îÄFIN‚îÄ‚îÄ> Server
PC <‚îÄ‚îÄACK‚îÄ‚îÄ Server
PC <‚îÄ‚îÄFIN‚îÄ‚îÄ Server
PC ‚îÄ‚îÄACK‚îÄ‚îÄ> Server

**Attack Opportunities at Each Step:**

Step 1 (DNS): DNS spoofing, cache poisoning
Step 2 (TCP): SYN floods, connection hijacking
Step 3 (TLS): Downgrade attacks, cert spoofing
Step 4 (HTTP): Request smuggling, header injection
Step 5 (Server): Application vulnerabilities
Step 6 (Response): Response splitting, injection
Step 7 (Rendering): XSS, malicious content
Step 8 (Teardown): Connection reuse attacks`
    }
  };

  // Expanded glossary with detailed beginner-friendly explanations
  const expandedGlossary = [
    { 
      term: "Handshake", 
      shortDesc: "Initial exchange that sets up a connection or session.",
      fullExplanation: `A handshake is like introducing yourself before a conversation. In networking, devices 
exchange initial messages to agree on how they'll communicate. The TCP three-way handshake (SYN, SYN-ACK, ACK) 
is the most famous example - it ensures both sides are ready before sending real data. TLS also has a handshake 
to negotiate encryption. Handshakes are common attack targets because they happen before security is fully established.`
    },
    { 
      term: "Stateful Protocol", 
      shortDesc: "Protocol that tracks session state on both ends.",
      fullExplanation: `A stateful protocol remembers past interactions. TCP is stateful - it tracks sequence numbers, 
which packets were acknowledged, what data was already sent. This is like having a conversation where you remember 
what was said before. The downside? The server must allocate memory for each connection, creating opportunities for 
"state exhaustion" attacks where attackers create many partial connections to consume all server memory.`
    },
    { 
      term: "Stateless Protocol", 
      shortDesc: "Protocol with no session memory between packets.",
      fullExplanation: `A stateless protocol treats each request independently, with no memory of past requests. UDP and 
HTTP (in its basic form) are stateless. Each request contains all information needed to process it. This is efficient 
but has security implications - there's no built-in way to verify that sequential packets came from the same sender, 
making spoofing attacks easier. It's like talking to someone with amnesia - every sentence is brand new to them.`
    },
    { 
      term: "Downgrade Attack", 
      shortDesc: "Forcing a weaker protocol version or cipher.",
      fullExplanation: `A downgrade attack tricks systems into using older, weaker security settings even when both sides 
support stronger ones. For example, an attacker might manipulate a TLS handshake to force TLS 1.0 instead of TLS 1.3, 
then exploit known vulnerabilities in the older version. It's like a thief convincing you to use a simple door lock 
instead of your deadbolt by claiming the deadbolt is "broken." Defense: disable legacy versions entirely so there's 
nothing to downgrade to.`
    },
    { 
      term: "Amplification Attack", 
      shortDesc: "Small request triggers a much larger response.",
      fullExplanation: `In an amplification attack, the attacker sends a small request that generates a huge response, 
and spoofs the source address to be the victim's IP. The victim gets flooded with responses they never requested. 
DNS amplification is notorious - a 60-byte query can generate a 3000-byte response (50x amplification). NTP and 
memcached have even higher ratios. It's like signing someone up for 1000 catalogs using a single postcard - minimal 
effort for the attacker, maximum annoyance for the victim.`
    },
    { 
      term: "Parsing", 
      shortDesc: "How a system reads and interprets protocol data.",
      fullExplanation: `Parsing is how software makes sense of raw data. When your browser receives HTTP, it must parse 
the headers, understand the content-length, find where the body starts, etc. Security bugs arise when different systems 
parse the same data differently. If a firewall parses a request one way but the server parses it another way, attackers 
can craft requests that the firewall thinks are safe but the server interprets as malicious. This is called a 
"parser differential" and enables attacks like HTTP request smuggling.`
    },
    { 
      term: "ALPN", 
      shortDesc: "TLS extension to negotiate application protocols.",
      fullExplanation: `ALPN (Application-Layer Protocol Negotiation) is a TLS extension that lets clients and servers 
agree on which application protocol to use (HTTP/1.1, HTTP/2, HTTP/3) during the TLS handshake, before any application 
data is sent. This saves a round-trip compared to negotiating after TLS is established. Security relevance: ALPN choices 
can reveal what services are running, and misconfigurations might allow unexpected protocol negotiation.`
    },
    { 
      term: "Fragmentation", 
      shortDesc: "Splitting packets to fit network MTU limits.",
      fullExplanation: `Networks have a Maximum Transmission Unit (MTU) - the largest packet size they can handle 
(typically 1500 bytes for Ethernet). Larger data must be split (fragmented) into smaller pieces. The destination 
reassembles them. Security issues: fragments can be used to evade security tools that only inspect the first 
fragment, and reassembly vulnerabilities have caused crashes and code execution (the infamous "Ping of Death" 
and more recent fragmentation attacks).`
    },
    { 
      term: "Replay Attack", 
      shortDesc: "Reusing captured traffic to impersonate a valid session.",
      fullExplanation: `In a replay attack, an attacker captures legitimate network traffic and retransmits it later 
to trick the server. If you capture someone logging in, you might be able to replay that login sequence to gain 
access. Defenses include timestamps, sequence numbers, and nonces (one-time values) that make old traffic invalid. 
TLS sessions include mechanisms to prevent replay, but application-layer protocols sometimes forget to add their own.`
    },
    { 
      term: "Digital Signature", 
      shortDesc: "Cryptographic proof that data was not modified.",
      fullExplanation: `A digital signature is like a tamper-evident seal that also proves who created the content. 
It uses asymmetric cryptography - the sender uses their private key to create a signature, and anyone with their 
public key can verify it. If even one bit of the signed data changes, verification fails. Used in TLS certificates, 
code signing, email (S/MIME, PGP), and protocol integrity checks (like SMB signing). Without signatures, attackers 
can modify data in transit without detection.`
    },
    { 
      term: "Session Resumption", 
      shortDesc: "Reusing prior TLS parameters to reduce handshake overhead.",
      fullExplanation: `A full TLS handshake is expensive - multiple round-trips, CPU-intensive cryptography. Session 
resumption lets a client and server reuse previously negotiated parameters to skip most of this work. There are two 
methods: session IDs (server stores state) and session tickets (client stores encrypted state). Security consideration: 
if session secrets are compromised, all resumed sessions are compromised. Also, session tickets must be encrypted with 
keys that are rotated regularly.`
    },
    { 
      term: "Man-in-the-Middle (MITM)", 
      shortDesc: "Attacker secretly intercepts and possibly alters communication.",
      fullExplanation: `In a MITM attack, the attacker positions themselves between two communicating parties, 
intercepting all traffic. They might just eavesdrop, or actively modify messages. Think of it as someone standing 
between you and your friend, passing notes - they can read them, change them, or replace them entirely. TLS is 
designed to prevent MITM attacks through certificate verification, but attacks exist: rogue Wi-Fi hotspots, ARP 
spoofing on local networks, compromised routers, and users clicking through certificate warnings.`
    },
    { 
      term: "Spoofing", 
      shortDesc: "Forging the source address or identity of network traffic.",
      fullExplanation: `Spoofing is pretending to be someone else. IP spoofing means sending packets with a fake source 
IP address. ARP spoofing means claiming to have a different MAC address. DNS spoofing means returning fake DNS answers. 
Spoofing is easiest with connectionless protocols (UDP) because there's no handshake to verify identity. Even TCP can 
be spoofed with enough guessing of sequence numbers. Defenses include ingress filtering (BCP38), cryptographic 
authentication, and monitoring for anomalies.`
    },
    { 
      term: "Encapsulation", 
      shortDesc: "Wrapping data in successive protocol headers as it moves down the stack.",
      fullExplanation: `As data travels down the network stack, each layer adds its own header (and sometimes trailer) 
around the data from the layer above. HTTP data gets wrapped in TCP headers, which gets wrapped in IP headers, which 
gets wrapped in Ethernet frames. At the destination, each layer strips off its header and passes the payload up. 
Understanding encapsulation helps you read packet captures - you're peeling off layers to see what's inside.`
    },
    { 
      term: "Checksum", 
      shortDesc: "Simple integrity check calculated from packet data.",
      fullExplanation: `A checksum is a value calculated from packet contents to detect transmission errors. TCP and IP 
both include checksums. However, checksums are NOT security features - they protect against accidental corruption, not 
intentional modification. An attacker who changes the data can recalculate a valid checksum. For security, you need 
cryptographic hashes or MACs (Message Authentication Codes), which require a secret key to compute.`
    },
  ];

  const objectives = [
    "Explain how protocol design choices create security risk.",
    "Recognize common exploitation themes across TCP, UDP, DNS, TLS, and SMB.",
    "Map weaknesses to detection signals and logging sources.",
    "Prioritize hardening actions that reduce protocol attack surface.",
    "Practice safe, read-only analysis in a lab environment.",
  ];
  const beginnerPath = [
    "1) Review the glossary and protocol map.",
    "2) Learn the top exploitation patterns at a high level.",
    "3) Connect each pattern to a detection signal.",
    "4) Apply the hardening checklist to your environment.",
    "5) Run the safe lab walkthrough and document normal baselines.",
  ];
  const glossary = [
    { term: "Handshake", desc: "Initial exchange that sets up a connection or session." },
    { term: "Stateful", desc: "Protocol that tracks session state on both ends." },
    { term: "Stateless", desc: "Protocol with no session memory between packets." },
    { term: "Downgrade", desc: "Forcing a weaker protocol version or cipher." },
    { term: "Amplification", desc: "Small request triggers a much larger response." },
    { term: "Parsing", desc: "How a system reads and interprets protocol data." },
    { term: "ALPN", desc: "TLS extension used to negotiate application protocols (HTTP/2 vs HTTP/1.1)." },
    { term: "Fragmentation", desc: "Splitting packets across the network to fit MTU limits." },
    { term: "Replay", desc: "Reusing captured traffic to impersonate a valid session." },
    { term: "Signature", desc: "Cryptographic integrity check that proves data was not modified." },
    { term: "Session resumption", desc: "Reusing prior TLS session parameters to reduce handshake overhead." },
  ];
  const scenarios = [
    "Legacy protocols left enabled for convenience.",
    "Management services exposed to untrusted networks.",
    "Inconsistent parsing between proxies and backends.",
    "Weak authentication on internal protocols.",
    "Misconfigured DNS or UDP services allowing amplification.",
    "Overly permissive firewall rules for internal services.",
    "Outdated appliances or firmware with protocol bugs.",
  ];

  // Common attack surfaces explained for beginners
  const attackSurfaces = [
    {
      surface: "Network Perimeter",
      description: "The boundary between your internal network and the internet. Firewalls, load balancers, and public-facing servers live here.",
      risks: "If breached, attackers gain initial access. Misconfigured firewall rules, exposed management interfaces, and vulnerable services are common issues.",
      defenses: "Defense in depth, minimal exposed services, WAF, regular penetration testing, network segmentation."
    },
    {
      surface: "Internal Network",
      description: "Traffic between servers, workstations, and services inside your organization. Often less secured than perimeter.",
      risks: "Once inside, attackers can move laterally. Internal protocols often lack encryption (SMB, LDAP, internal HTTP). Trust is often assumed.",
      defenses: "Zero trust architecture, microsegmentation, internal TLS, monitoring east-west traffic, privilege access management."
    },
    {
      surface: "Management Plane",
      description: "Administrative interfaces for configuring network devices, servers, and services. SSH, RDP, SNMP, web admin consoles.",
      risks: "Highest value target - control over infrastructure. Often protected only by password. Exposed to wrong networks.",
      defenses: "Jump hosts, MFA everywhere, restrict to management VLAN, audit all access, privileged access workstations."
    },
    {
      surface: "Name Resolution",
      description: "DNS, mDNS, LLMNR, NetBIOS - services that translate names to addresses. Critical for all network communication.",
      risks: "Poison the resolver, control where traffic goes. DNS is often unencrypted and trusted implicitly.",
      defenses: "DNSSEC, DoH/DoT, disable legacy name resolution (LLMNR, NBNS), monitor resolver changes."
    },
    {
      surface: "Authentication Flows",
      description: "How users and systems prove their identity. Kerberos, LDAP, RADIUS, SAML, OAuth flows.",
      risks: "Weak authentication = unauthorized access. Credential theft, replay attacks, token manipulation.",
      defenses: "MFA, certificate-based auth, short token lifetimes, anomaly detection, credential monitoring."
    },
  ];

  // Real-world attack scenarios for understanding
  const realWorldScenarios = [
    {
      title: "The Coffee Shop MITM",
      scenario: "Attacker sets up a rogue Wi-Fi access point with a legitimate-sounding name ('Starbucks_WiFi'). Victims connect, and all their traffic flows through the attacker.",
      techniques: "ARP spoofing, DNS hijacking, SSL stripping, credential harvesting",
      lesson: "Never trust public Wi-Fi for sensitive activities. Use VPN. Verify HTTPS. Watch for certificate warnings.",
      difficulty: "Beginner - tools like WiFi-Pumpkin make this trivially easy"
    },
    {
      title: "DNS Cache Poisoning",
      scenario: "Attacker sends forged DNS responses to a resolver, inserting malicious IP addresses for legitimate domains. Victims are silently redirected to attacker-controlled servers.",
      techniques: "DNS spoofing, birthday attack on transaction IDs, Kaminsky attack variant",
      lesson: "Implement DNSSEC validation. Use trusted resolvers. Monitor for unusual DNS patterns. Source port randomization.",
      difficulty: "Intermediate - requires network access and timing"
    },
    {
      title: "SMB Relay Attack",
      scenario: "Attacker captures NTLM authentication attempts and relays them to another server, gaining access as the victim user. No password cracking required.",
      techniques: "LLMNR/NBNS poisoning to capture auth, relay to SMB/LDAP/HTTP, token impersonation",
      lesson: "Disable NTLM where possible. Require SMB signing. Disable legacy name resolution. Use Kerberos.",
      difficulty: "Intermediate - requires internal network access"
    },
    {
      title: "BGP Hijacking",
      scenario: "Attacker announces routes for IP prefixes they don't own, causing internet traffic to flow through their network. Can intercept traffic at massive scale.",
      techniques: "Route injection, prefix hijacking, AS path manipulation",
      lesson: "Implement RPKI, monitor BGP announcements, have relationships with upstream providers who can respond.",
      difficulty: "Advanced - requires BGP peering capability"
    },
    {
      title: "NTP Amplification DDoS",
      scenario: "Attacker sends small 'monlist' queries to NTP servers with spoofed source IP (the victim). Servers respond with huge lists to the victim, overwhelming them.",
      techniques: "UDP source spoofing, amplification factor ~556x, distributed across many reflectors",
      lesson: "Disable monlist on NTP servers. Implement BCP38 egress filtering. Use rate limiting. DDoS mitigation services.",
      difficulty: "Beginner - scripts widely available"
    },
  ];

  // ===========================================
  // PART 2: PROTOCOL DEEP DIVES
  // ===========================================

  // Detailed explanations for each protocol - beginner friendly
  const protocolDeepDives = {
    TCP: {
      fullName: "Transmission Control Protocol",
      whatItDoes: `TCP is the reliable workhorse of the internet. When you load a webpage, send an email, or download a file, 
TCP ensures every piece of data arrives correctly and in order. It's like sending a package with tracking and signature 
confirmation - you know it arrived, and the recipient confirms they got it.`,
      howItWorks: `1. **Connection Setup (Three-Way Handshake)**:
   ‚Ä¢ Client sends SYN: "I want to talk, here's my starting sequence number"
   ‚Ä¢ Server sends SYN-ACK: "Okay, here's my starting sequence number too"
   ‚Ä¢ Client sends ACK: "Got it, let's begin"

2. **Data Transfer**:
   ‚Ä¢ Data is split into segments with sequence numbers
   ‚Ä¢ Receiver acknowledges each segment received
   ‚Ä¢ If acknowledgment doesn't arrive, sender retransmits

3. **Connection Teardown**:
   ‚Ä¢ Either side sends FIN: "I'm done sending"
   ‚Ä¢ Other side acknowledges and sends their FIN
   ‚Ä¢ Final acknowledgment closes the connection`,
      securityWeaknesses: [
        "**SYN Flood**: Attackers send millions of SYNs without completing handshakes, filling the server's connection table",
        "**Sequence Number Prediction**: If predictable, attackers can inject packets into existing connections",
        "**Reset Attacks**: Forged RST packets can kill legitimate connections",
        "**Session Hijacking**: Taking over an established connection by predicting sequence numbers",
        "**Time-Wait Assassination**: Exploiting the TIME_WAIT state to cause resource exhaustion"
      ],
      realWorldExamples: [
        "**GitHub DDoS (2018)**: Massive SYN flood combined with amplification took GitHub offline",
        "**Land Attack**: Classic attack sending SYN with source = destination, causing loops",
        "**Slowloris**: Keeps many TCP connections open by sending partial requests"
      ],
      defenseStrategies: [
        "Enable SYN cookies to handle SYN floods without storing state",
        "Use connection timeouts and limits per source IP",
        "Implement TCP sequence number randomization",
        "Deploy network firewalls with connection tracking",
        "Use load balancers that can absorb connection floods"
      ],
      detectionMethods: [
        "Monitor for high numbers of SYN_RECV connections",
        "Alert on unusual retransmission rates",
        "Track connections per source IP",
        "Watch for RST packet anomalies"
      ]
    },
    UDP: {
      fullName: "User Datagram Protocol",
      whatItDoes: `UDP is the "fire and forget" protocol. It sends packets without establishing a connection, without 
guaranteeing delivery, and without waiting for acknowledgments. This makes it fast but unreliable - perfect for 
real-time applications like video calls, gaming, and DNS lookups where speed matters more than occasional lost packets.`,
      howItWorks: `UDP is beautifully simple:
1. Application says "send this data to IP:port"
2. UDP adds a minimal header (source port, dest port, length, checksum)
3. Packet is sent - no handshake, no waiting, no confirmation
4. If it arrives, great. If not, the application must handle it.

The header is only 8 bytes (vs TCP's 20+ bytes), making UDP more efficient for small messages.`,
      securityWeaknesses: [
        "**Source IP Spoofing**: No handshake means no verification - anyone can claim to be anyone",
        "**Amplification Attacks**: Small request ‚Üí large response, with spoofed source = victim",
        "**Reflection Attacks**: Using legitimate servers to bounce attacks at victims",
        "**No Built-in Authentication**: UDP trusts whatever the packet says",
        "**Fragmentation Attacks**: UDP fragments can bypass security inspection"
      ],
      realWorldExamples: [
        "**Memcached Amplification (2018)**: 51,000x amplification factor, 1.7 Tbps attacks",
        "**DNS Amplification**: Query for ANY record generates huge responses",
        "**NTP Monlist**: Single packet triggers list of 600 IPs from NTP server",
        "**SSDP Reflection**: UPnP devices used to amplify attacks"
      ],
      defenseStrategies: [
        "Implement BCP38 ingress filtering (prevent spoofed source IPs leaving your network)",
        "Rate-limit UDP responses, especially to new IPs",
        "Disable unnecessary UDP services",
        "Use response rate limiting (RRL) on DNS servers",
        "Deploy upstream DDoS protection for amplification attacks"
      ],
      detectionMethods: [
        "Monitor for asymmetric traffic (small inbound, large outbound)",
        "Alert on sudden spikes in UDP traffic",
        "Track response sizes for UDP services",
        "Watch for traffic to unusual UDP ports"
      ]
    },
    DNS: {
      fullName: "Domain Name System",
      whatItDoes: `DNS is the internet's phone book. When you type "google.com", DNS translates it to an IP address 
(142.250.80.46) that computers can use. Without DNS, you'd have to memorize IP addresses for every website. 
It's hierarchical: root servers ‚Üí TLD servers (.com, .org) ‚Üí authoritative servers (google.com's nameservers).`,
      howItWorks: `1. **Your browser**: "What's the IP for www.example.com?"
2. **Your OS**: Checks local cache, then asks configured resolver
3. **Recursive Resolver** (like 8.8.8.8): 
   - Asks root server: "Who handles .com?"
   - Root says: "Ask 192.5.6.30 (Verisign)"
   - Asks .com server: "Who handles example.com?"
   - .com says: "Ask 93.184.216.34"
   - Asks example.com's server: "What's www?"
   - Gets answer: "93.184.216.34"
4. **Resolver**: Caches answer, returns to your OS
5. **Your browser**: Connects to 93.184.216.34`,
      securityWeaknesses: [
        "**Cache Poisoning**: Inject fake DNS answers into resolver cache",
        "**DNS Spoofing**: Race to answer before legitimate server",
        "**Open Resolver Abuse**: Servers answering queries from anyone enable amplification",
        "**Zone Transfer Leakage**: Exposing all DNS records for a domain",
        "**Subdomain Takeover**: Claiming abandoned DNS records",
        "**DNS Tunneling**: Hiding data exfiltration in DNS queries"
      ],
      realWorldExamples: [
        "**Kaminsky Attack (2008)**: Revolutionary cache poisoning technique affecting most resolvers",
        "**Sea Turtle (2019)**: State-sponsored DNS hijacking of government domains",
        "**DYN Attack (2016)**: DNS provider DDoS that took down Twitter, Reddit, Netflix"
      ],
      defenseStrategies: [
        "Implement DNSSEC to cryptographically verify DNS answers",
        "Use DNS over HTTPS (DoH) or DNS over TLS (DoT) for privacy",
        "Restrict DNS recursion to authorized clients only",
        "Enable Response Rate Limiting (RRL) on authoritative servers",
        "Monitor for DNS tunneling patterns",
        "Use split-horizon DNS for internal/external resolution"
      ],
      detectionMethods: [
        "Alert on large DNS responses (potential amplification)",
        "Monitor for unusual query patterns (tunneling)",
        "Track NXDOMAIN rates for anomalies",
        "Watch for DNS queries to suspicious TLDs",
        "Detect resolver changes on endpoints"
      ]
    },
    TLS: {
      fullName: "Transport Layer Security",
      whatItDoes: `TLS encrypts your communication so eavesdroppers can't read it, and authenticates servers so you know 
you're talking to the real google.com, not an imposter. When you see the padlock in your browser, TLS is working. 
It protects passwords, credit cards, private messages - everything sensitive online.`,
      howItWorks: `**The TLS 1.3 Handshake (Simplified)**:

1. **Client Hello**: "Hi! I support TLS 1.3, these cipher suites, here's my key share"
2. **Server Hello**: "Great! Let's use TLS 1.3 with AES-256-GCM, here's my key share"
3. **Certificate**: Server sends its certificate (proving identity)
4. **Finished**: Both sides derive encryption keys and confirm handshake
5. **Application Data**: All further communication is encrypted

TLS 1.3 is faster (1 round-trip vs 2) and more secure (removed weak algorithms) than 1.2.`,
      securityWeaknesses: [
        "**Downgrade Attacks**: Force use of older, vulnerable TLS versions",
        "**Certificate Issues**: Expired, self-signed, or misconfigured certificates",
        "**Weak Ciphers**: Old cipher suites with known vulnerabilities",
        "**Heartbleed (historical)**: Memory leak in OpenSSL exposed private keys",
        "**BEAST, POODLE, CRIME**: Various attacks on TLS 1.0/1.1 and CBC modes",
        "**Private Key Compromise**: If the key leaks, all past traffic can be decrypted (without PFS)"
      ],
      realWorldExamples: [
        "**Heartbleed (2014)**: Affected 17% of secure web servers, massive private key exposure",
        "**DigiNotar (2011)**: CA compromise led to forged certificates for google.com",
        "**ROBOT (2017)**: RSA padding oracle attack affected major sites",
        "**Cloudbleed (2017)**: Memory leak exposed customer data across thousands of sites"
      ],
      defenseStrategies: [
        "Disable TLS 1.0 and 1.1 - require TLS 1.2 minimum, prefer 1.3",
        "Use only strong cipher suites (AEAD modes like AES-GCM)",
        "Enable HSTS (HTTP Strict Transport Security)",
        "Implement certificate transparency monitoring",
        "Use short-lived certificates (Let's Encrypt 90-day model)",
        "Enable Perfect Forward Secrecy (ECDHE key exchange)"
      ],
      detectionMethods: [
        "Log and alert on TLS 1.0/1.1 connections",
        "Monitor for certificate errors and warnings",
        "Track cipher suite usage",
        "Alert on handshake failures",
        "Watch for unusual certificate chains"
      ]
    },
    SMB: {
      fullName: "Server Message Block",
      whatItDoes: `SMB is how Windows computers share files, printers, and other resources on a network. When you access 
\\\\server\\share in Windows Explorer, you're using SMB. It's deeply integrated into Windows and Active Directory, 
making it both essential and a prime target for attackers.`,
      howItWorks: `1. **Connection**: Client connects to TCP port 445
2. **Negotiation**: Agree on SMB version (SMB1, SMB2, SMB3)
3. **Authentication**: Usually NTLM or Kerberos through Windows
4. **Tree Connect**: Client requests access to a share
5. **File Operations**: Open, read, write, close files

SMB3 adds encryption, but SMB1 is dangerously insecure and still sometimes enabled for compatibility.`,
      securityWeaknesses: [
        "**SMBv1 Vulnerabilities**: EternalBlue exploit used by WannaCry ransomware",
        "**NTLM Relay**: Capture and relay authentication without cracking passwords",
        "**Unsigned Sessions**: Without SMB signing, packets can be modified in transit",
        "**Null Sessions**: Anonymous access can enumerate users and shares",
        "**Pass-the-Hash**: Use captured NTLM hashes directly without cracking"
      ],
      realWorldExamples: [
        "**WannaCry (2017)**: Ransomware using EternalBlue spread to 200,000+ computers",
        "**NotPetya (2017)**: Used SMB for lateral movement, caused $10B+ in damages",
        "**NTLM Relay Attacks**: Commonly used in penetration testing and real attacks"
      ],
      defenseStrategies: [
        "Disable SMBv1 completely on all systems",
        "Require SMB signing on all connections",
        "Enable SMB encryption (SMB3)",
        "Restrict SMB to internal networks only",
        "Use Kerberos instead of NTLM where possible",
        "Implement network segmentation to limit lateral movement"
      ],
      detectionMethods: [
        "Alert on SMBv1 usage",
        "Monitor for unsigned SMB sessions",
        "Track new SMB connections between unusual hosts",
        "Watch for enumeration patterns (many shares accessed)",
        "Detect unusual file access patterns"
      ]
    },
    SSH: {
      fullName: "Secure Shell",
      whatItDoes: `SSH provides encrypted remote access to servers. It replaced insecure Telnet for command-line access 
and is the standard way administrators manage Linux/Unix servers. SSH can also tunnel other protocols, transfer files 
(SCP/SFTP), and forward ports.`,
      howItWorks: `1. **Connection**: Client connects to TCP port 22
2. **Key Exchange**: Diffie-Hellman establishes shared secret
3. **Server Authentication**: Server proves identity via host key
4. **User Authentication**: Password, public key, or other methods
5. **Encrypted Channel**: All further communication is encrypted

Public key authentication is more secure than passwords - the private key never leaves your machine.`,
      securityWeaknesses: [
        "**Password Brute Force**: Default configs allow unlimited attempts",
        "**Weak Keys**: Short RSA keys or compromised private keys",
        "**Trust on First Use**: Most users blindly accept host keys",
        "**Key Management**: Lost or stolen private keys",
        "**Legacy Algorithms**: Old ciphers and key exchange methods",
        "**SSH Agent Forwarding**: Can be hijacked on compromised hosts"
      ],
      realWorldExamples: [
        "**Libssh Vulnerability (2018)**: Authentication bypass with single packet",
        "**SSH Key Sprawl**: Unmanaged keys leading to unauthorized access",
        "**Brute Force Botnets**: Millions of login attempts daily"
      ],
      defenseStrategies: [
        "Disable password authentication, require key-based auth",
        "Use strong key types (Ed25519 or RSA 4096+)",
        "Implement fail2ban or similar rate limiting",
        "Change default port (security through obscurity, but reduces noise)",
        "Use certificate-based SSH authentication",
        "Audit authorized_keys files regularly"
      ],
      detectionMethods: [
        "Alert on authentication failures from new IPs",
        "Monitor for unusual login times or locations",
        "Track new SSH keys being added",
        "Watch for SSH tunneling patterns",
        "Detect brute force attempts"
      ]
    },
    Kerberos: {
      fullName: "Kerberos Authentication Protocol",
      whatItDoes: `Kerberos is the authentication backbone of Active Directory. When you log into a Windows domain computer, 
Kerberos proves your identity and gives you "tickets" to access network resources without re-entering passwords. 
It's named after the three-headed dog guarding Hades - representing the three parties: client, server, and KDC.`,
      howItWorks: `1. **AS-REQ**: Client requests TGT (Ticket Granting Ticket) from KDC
2. **AS-REP**: KDC returns TGT encrypted with user's password hash
3. **TGS-REQ**: Client presents TGT, requests service ticket
4. **TGS-REP**: KDC returns service ticket for specific resource
5. **AP-REQ**: Client presents service ticket to target server
6. **Access Granted**: Server verifies ticket, allows access

Tickets have lifetimes (default 10 hours) and can be renewed or delegated.`,
      securityWeaknesses: [
        "**Kerberoasting**: Request service tickets, crack offline",
        "**Golden Ticket**: Forge TGTs with compromised krbtgt hash",
        "**Silver Ticket**: Forge service tickets with service account hash",
        "**AS-REP Roasting**: Attack accounts with pre-auth disabled",
        "**Pass-the-Ticket**: Reuse stolen tickets",
        "**Delegation Abuse**: Impersonate users through misconfigured delegation"
      ],
      realWorldExamples: [
        "**APT Campaigns**: Golden tickets for persistent domain access",
        "**Internal Penetration Tests**: Kerberoasting is standard technique",
        "**SolarWinds (2020)**: Attackers forged SAML tokens (similar concept)"
      ],
      defenseStrategies: [
        "Use long, random passwords for service accounts",
        "Implement Group Managed Service Accounts (gMSA)",
        "Disable pre-authentication only when absolutely necessary",
        "Monitor krbtgt account closely",
        "Rotate krbtgt password twice per year",
        "Limit delegation scope and type"
      ],
      detectionMethods: [
        "Alert on TGT requests for sensitive accounts",
        "Monitor for unusual service ticket requests",
        "Track delegation usage",
        "Detect ticket anomalies (lifetime, flags)",
        "Watch for pre-auth failures"
      ]
    },
    HTTP: {
      fullName: "Hypertext Transfer Protocol",
      whatItDoes: `HTTP is how your browser talks to web servers. Every webpage, API call, and web application uses HTTP. 
It's a request-response protocol: you request a page, the server sends it back. Modern HTTP (HTTP/2, HTTP/3) adds 
performance features like multiplexing and server push.`,
      howItWorks: `**Request:**
GET /page.html HTTP/1.1
Host: example.com
User-Agent: Mozilla/5.0...

**Response:**
HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 1234

<!DOCTYPE html>...

HTTP is stateless - each request is independent. Cookies and sessions add state on top.`,
      securityWeaknesses: [
        "**Request Smuggling**: Conflicting headers (Content-Length vs Transfer-Encoding)",
        "**Host Header Attacks**: Manipulating the Host header for cache poisoning",
        "**Desync Attacks**: Proxy/backend parsing differences",
        "**Response Splitting**: Injecting headers into responses",
        "**CRLF Injection**: Inserting line breaks to add headers"
      ],
      realWorldExamples: [
        "**Request Smuggling on PayPal**: James Kettle's research showed major vulnerabilities",
        "**Capital One Breach (2019)**: SSRF through web application",
        "**CVE-2023-25690**: Apache HTTP Server request smuggling"
      ],
      defenseStrategies: [
        "Normalize all HTTP traffic through reverse proxies",
        "Reject ambiguous requests (conflicting length headers)",
        "Keep proxy and backend software patched and aligned",
        "Use HTTP/2 end-to-end where possible",
        "Implement strict Content-Security-Policy headers"
      ],
      detectionMethods: [
        "Alert on HTTP 400/431 error spikes",
        "Monitor for unusual header combinations",
        "Track response splitting indicators",
        "Watch for chunked encoding anomalies"
      ]
    }
  };

  const protocolMap = [
    {
      protocol: "TCP",
      layer: "L4",
      ports: "Any",
      weakness: "State exhaustion, weak timeouts, backlog pressure.",
      defense: "SYN cookies, connection limits, tuned timeouts.",
      detection: "SYN_RECV spikes, retransmits, backlog drops.",
    },
    {
      protocol: "UDP",
      layer: "L4",
      ports: "Any",
      weakness: "Spoofing, reflection, no handshake.",
      defense: "Ingress filtering, rate limits, restrict exposure.",
      detection: "Asymmetric traffic, response size spikes.",
    },
    {
      protocol: "ICMP",
      layer: "L3",
      ports: "N/A",
      weakness: "Recon, abuse of error messages, floods.",
      defense: "Rate limit, monitor, block where unnecessary.",
      detection: "ICMP bursts, unreachable storms.",
    },
    {
      protocol: "DNS",
      layer: "L7",
      ports: "53 UDP/TCP",
      weakness: "Open recursion, cache poisoning, large responses.",
      defense: "Restrict recursion, DNSSEC, response rate limiting.",
      detection: "Large responses, NXDOMAIN spikes, resolver changes.",
    },
    {
      protocol: "TLS",
      layer: "L7",
      ports: "443, 465, 993",
      weakness: "Downgrade, weak ciphers, expired certs.",
      defense: "Disable legacy, enforce strong cipher suites.",
      detection: "Legacy versions, handshake failures, cert errors.",
    },
    {
      protocol: "HTTP",
      layer: "L7",
      ports: "80/443",
      weakness: "Parser confusion, header ambiguity, smuggling risk.",
      defense: "Normalize proxies, strict parsing, patch gateways.",
      detection: "400/431 errors, conflicting length headers.",
    },
    {
      protocol: "HTTP/2",
      layer: "L7",
      ports: "443",
      weakness: "Stream abuse, header compression edge cases.",
      defense: "Limit streams, patch proxies, enforce H2 settings.",
      detection: "RST_STREAM spikes, H2 errors in logs.",
    },
    {
      protocol: "SMB",
      layer: "L7",
      ports: "445",
      weakness: "Legacy versions, weak signing, lateral movement.",
      defense: "Disable SMBv1, enforce signing, limit exposure.",
      detection: "Unsigned sessions, new SMB access paths.",
    },
    {
      protocol: "Kerberos",
      layer: "L7",
      ports: "88 TCP/UDP",
      weakness: "Ticket abuse, time sync issues, delegation misconfig.",
      defense: "Harden time sync, limit delegation, monitor tickets.",
      detection: "Pre-auth failures, unusual ticket lifetimes.",
    },
    {
      protocol: "LDAP",
      layer: "L7",
      ports: "389/636",
      weakness: "Cleartext binds, anonymous access, overbroad reads.",
      defense: "Require LDAPS, disable anonymous, least privilege.",
      detection: "Simple binds from new hosts, large directory reads.",
    },
    {
      protocol: "SSH",
      layer: "L7",
      ports: "22",
      weakness: "Weak keys, password brute force, legacy ciphers.",
      defense: "Disable password auth, enforce strong keys, rate limit.",
      detection: "Auth failures, new key usage, new source IPs.",
    },
    {
      protocol: "RDP",
      layer: "L7",
      ports: "3389",
      weakness: "Exposed service, weak auth, NLA disabled.",
      defense: "Restrict access, enforce NLA, MFA, jump hosts.",
      detection: "Failed logons, lockouts, new source IPs.",
    },
    {
      protocol: "SNMP",
      layer: "L7",
      ports: "161/162 UDP",
      weakness: "Default communities, unauth management.",
      defense: "Use SNMPv3, restrict to management VLANs.",
      detection: "Community use, queries from unknown IPs.",
    },
    {
      protocol: "NTP",
      layer: "L7",
      ports: "123 UDP",
      weakness: "Amplification, exposed control queries.",
      defense: "Restrict access, disable legacy modes, rate limits.",
      detection: "Large NTP responses, spikes to port 123.",
    },
    {
      protocol: "DHCP",
      layer: "L7",
      ports: "67/68 UDP",
      weakness: "Rogue servers, IP conflicts, starvation.",
      defense: "DHCP snooping, trusted ports only.",
      detection: "Multiple offers, lease spikes, unknown servers.",
    },
  ];

  const exposureChecklist = [
    "Inventory all listening services and map them to owners.",
    "Verify management ports are restricted to admin networks.",
    "Confirm DNS recursion is limited to trusted clients.",
    "Disable legacy protocols (SMBv1, TLS 1.0/1.1, Telnet).",
    "Rate-limit or shield UDP services that can amplify traffic.",
  ];

  // ===========================================
  // PART 3: EXPLOITATION PATTERNS DEEP DIVE
  // ===========================================

  // Detailed exploitation pattern explanations for beginners
  const exploitationPatternsDetailed = {
    stateExhaustion: {
      title: "State Exhaustion Attacks",
      icon: "üíÄ",
      summary: "Consume server resources by creating many partial or long-lived sessions until the server can't accept new connections.",
      
      deepExplanation: `**The Core Concept:**
Stateful protocols like TCP need to track information about each connection. When you start a TCP connection, 
the server creates a data structure in memory to track that connection's state. This includes:
‚Ä¢ Sequence numbers for ordering packets
‚Ä¢ Window sizes for flow control
‚Ä¢ Timeout values
‚Ä¢ Source/destination addresses and ports

**The Attack:**
An attacker exploits this by creating many connections without completing them or by keeping them alive 
indefinitely. Since each connection consumes memory and CPU, enough partial connections will exhaust the 
server's resources, preventing legitimate users from connecting.

**Types of State Exhaustion:**

1. **SYN Flood**: Send millions of SYN packets without completing the handshake
   - Server allocates memory for each half-open connection
   - Backlog queue fills up, new connections dropped

2. **Slowloris**: Open connections and send requests very slowly
   - Keep connection alive but never complete the request
   - Web servers often limit concurrent connections per IP

3. **RUDY (R-U-Dead-Yet)**: Send POST requests with very slow body
   - Server waits for complete body before processing
   - Resources tied up waiting

**Why It Works:**
Servers must be ready to handle legitimate slow connections. The internet has variable latency, so servers 
can't just close slow connections immediately. Attackers exploit this tolerance.`,

      technicalDetails: `**TCP Backlog:**
When a SYN arrives, Linux adds an entry to the SYN backlog queue. This queue has a limited size 
(controlled by net.ipv4.tcp_max_syn_backlog). Once full, new SYNs are dropped.

**SYN Cookies - The Defense:**
Instead of storing state, the server encodes connection info into the initial sequence number 
returned in the SYN-ACK. If a valid ACK returns, the server can reconstruct the connection state. 
No memory needed until the handshake completes!

Enable with: sysctl -w net.ipv4.tcp_syncookies=1

**Connection Table:**
Fully established connections live in a hash table. The size is also limited. Tools like 
"netstat" or "ss" show current connections and states.`,

      realExamples: [
        {
          name: "GitHub DDoS (2018)",
          description: "Attackers combined SYN floods with memcached amplification, achieving 1.35 Tbps of traffic",
          outcome: "GitHub was offline for ~10 minutes before mitigation kicked in"
        },
        {
          name: "Slowloris vs Apache",
          description: "Single attacker could take down Apache servers by exhausting worker threads",
          outcome: "Led to changes in how web servers handle slow connections"
        }
      ],

      detectionSignals: [
        "High count of connections in SYN_RECV state",
        "Backlog warnings in system logs",
        "Connection timeout errors increasing",
        "Server becoming unresponsive to new connections",
        "Memory pressure on connection tracking",
        "Firewall conntrack table filling up"
      ],

      defenseStrategies: [
        { strategy: "Enable SYN cookies", command: "sysctl -w net.ipv4.tcp_syncookies=1" },
        { strategy: "Reduce SYN-ACK retries", command: "sysctl -w net.ipv4.tcp_synack_retries=2" },
        { strategy: "Set connection limits per IP", command: "iptables -A INPUT -p tcp --syn -m connlimit --connlimit-above 100 -j DROP" },
        { strategy: "Use load balancers with connection queuing", command: "Configure HAProxy/nginx with connection limits" }
      ]
    },

    amplificationReflection: {
      title: "Amplification & Reflection Attacks",
      icon: "üì°",
      summary: "Abuse UDP services to multiply attack traffic - send small requests with spoofed source, get huge responses sent to victim.",

      deepExplanation: `**The Core Concept:**
Some network services respond with much more data than they receive. If an attacker can make requests 
appear to come from someone else (spoofing), they can use these services as "amplifiers" to attack 
the victim with traffic they never requested.

**How It Works:**

1. Attacker sends small UDP request to vulnerable service
2. Source IP in the request is forged to be the victim's IP
3. Server sends large response to the "source" (victim)
4. Victim gets flooded with responses they never asked for

**Why UDP?**
UDP has no handshake - the server just responds to wherever the packet says it came from. 
TCP can't be amplified because the three-way handshake requires the real source to respond.

**Amplification Factors:**
‚Ä¢ DNS: 28-54x (ask for ANY record on large domain)
‚Ä¢ NTP: 556x (monlist command returns list of recent clients)
‚Ä¢ Memcached: 51,000x (statistics command returns huge response)
‚Ä¢ SSDP: 30x (UPnP discovery)
‚Ä¢ CharGen: Infinite (responds with endless character stream)

**The Math:**
If attacker has 100 Mbps bandwidth and uses 50x amplification:
100 Mbps √ó 50 = 5 Gbps hitting the victim
The attacker's connection doesn't need to be big - they're using others' bandwidth.`,

      technicalDetails: `**DNS Amplification Details:**
Query: dig ANY example.com @open-resolver (small ~60 bytes)
Response: Full zone information (potentially 3000+ bytes)

The attacker finds "open resolvers" - DNS servers that answer queries from anyone.
They send millions of spoofed queries, all appearing to come from the victim.

**NTP Monlist:**
The monlist command asks an NTP server for the list of its 600 most recent clients.
Request: 8 bytes
Response: Up to 48,000 bytes (600 entries √ó 80 bytes)

Most patched now, but millions of vulnerable servers existed.

**BCP38 - The Prevention:**
If every ISP implemented BCP38 (ingress filtering), spoofed packets would be dropped 
at the network edge. Unfortunately, adoption is incomplete.`,

      realExamples: [
        {
          name: "Memcached Attacks (2018)",
          description: "Attackers discovered memcached servers exposed to internet, achieving 1.7 Tbps attacks",
          outcome: "Largest DDoS ever at the time, affected GitHub, and prompted emergency patches"
        },
        {
          name: "Spamhaus Attack (2013)",
          description: "DNS amplification attack against anti-spam organization",
          outcome: "300 Gbps attack, large enough to impact internet exchange points"
        }
      ],

      detectionSignals: [
        "Sudden spike in inbound UDP traffic",
        "Large responses from DNS/NTP/SSDP ports",
        "Traffic from many different source IPs (reflectors)",
        "Asymmetric traffic (small outbound, huge inbound)",
        "Source ports being well-known UDP service ports"
      ],

      defenseStrategies: [
        { strategy: "Disable unused UDP services", command: "systemctl disable ntp memcached" },
        { strategy: "Enable DNS Response Rate Limiting", command: "Configure BIND/Unbound RRL" },
        { strategy: "Implement BCP38 egress filtering", command: "Prevent spoofed IPs leaving your network" },
        { strategy: "Use upstream DDoS protection", command: "Cloudflare, AWS Shield, Akamai" }
      ]
    },

    downgradeAttacks: {
      title: "Protocol Downgrade Attacks",
      icon: "‚¨áÔ∏è",
      summary: "Force systems to use older, weaker protocol versions that have known vulnerabilities.",

      deepExplanation: `**The Core Concept:**
For backward compatibility, many systems support both old and new protocol versions. During negotiation, 
they agree on the newest version both support. An attacker can manipulate this negotiation to force 
use of the oldest, weakest version - which may have known vulnerabilities.

**Where Downgrades Happen:**

1. **TLS Version**: Force TLS 1.0 instead of TLS 1.3
   - TLS 1.0 has known attacks (BEAST, POODLE)
   - Weak cipher suites still available

2. **SMB Version**: Force SMBv1 instead of SMBv3
   - SMBv1 has no signing or encryption
   - Vulnerable to EternalBlue

3. **SSH Algorithms**: Force weak ciphers or key exchange
   - Older SSH can use DES, small keys
   - Might enable known attacks

4. **HTTP Version**: Force HTTP/1.1 instead of HTTP/2
   - Missing security headers
   - Request smuggling easier

**The POODLE Attack (Example):**
POODLE exploited a flaw in SSL 3.0's CBC padding. Even if both client and server supported TLS 1.2, 
an attacker could cause connection failures until they fell back to SSL 3.0, then exploit it.

**Why This Works:**
Protocols are designed for graceful degradation - if the newest version fails, try an older one. 
This is good for reliability but bad for security. Attackers exploit this by making the newer 
versions appear to fail.`,

      technicalDetails: `**TLS Downgrade Prevention:**
TLS 1.3 includes "downgrade sentinel" - a special value in the ServerHello random field 
that alerts clients to potential downgrade attacks.

Clients should check for: 
0x44 0x4F 0x57 0x4E 0x47 0x52 0x44 0x01 (TLS 1.2)
0x44 0x4F 0x57 0x4E 0x47 0x52 0x44 0x00 (TLS 1.1 or below)

**Testing for Downgrade:**
# Use testssl.sh to check
./testssl.sh --protocols example.com

# Or openssl
openssl s_client -connect example.com:443 -tls1

**Preventing Downgrade:**
Best defense is disabling legacy versions entirely. If you only support TLS 1.2+, 
there's nothing to downgrade to.`,

      realExamples: [
        {
          name: "POODLE (2014)",
          description: "SSL 3.0 padding oracle attack, enabled by forcing downgrade from TLS",
          outcome: "SSL 3.0 disabled across the internet"
        },
        {
          name: "DROWN (2016)",
          description: "Attack on TLS servers that also supported SSLv2",
          outcome: "33% of HTTPS servers vulnerable, mass patching required"
        }
      ],

      detectionSignals: [
        "Clients negotiating old TLS versions (1.0, 1.1)",
        "Weak cipher suites being used",
        "Connection failures followed by successful weaker connections",
        "SMBv1 traffic when SMBv3 should be used",
        "Legacy protocol alerts in security tools"
      ],

      defenseStrategies: [
        { strategy: "Disable TLS 1.0 and 1.1", command: "Configure server to require TLS 1.2+" },
        { strategy: "Disable weak cipher suites", command: "Remove RC4, DES, export ciphers" },
        { strategy: "Disable SMBv1 on Windows", command: "Disable-WindowsOptionalFeature -Online -FeatureName SMB1Protocol" },
        { strategy: "Enable HSTS", command: "Add Strict-Transport-Security header" }
      ]
    },

    parserMismatch: {
      title: "Parser Mismatch & Desync",
      icon: "üîÄ",
      summary: "Exploit differences in how systems interpret the same protocol data to bypass security controls.",

      deepExplanation: `**The Core Concept:**
When a request passes through multiple systems (firewall ‚Üí load balancer ‚Üí web server), each system 
parses the protocol differently. If they disagree on where one request ends and another begins, 
an attacker can craft requests that look safe to the firewall but dangerous to the backend.

**HTTP Request Smuggling (Classic Example):**

HTTP has two ways to indicate body length:
‚Ä¢ Content-Length: 13 (body is exactly 13 bytes)
‚Ä¢ Transfer-Encoding: chunked (body sent in chunks with sizes)

What if a request has BOTH headers with different values?
‚Ä¢ Front-end uses Content-Length
‚Ä¢ Back-end uses Transfer-Encoding
‚Ä¢ They disagree on where the request ends!

**The Attack:**
Attacker sends one request that the front-end sees as ONE request, but the back-end sees as TWO.
The "hidden" second request can bypass security, access other users' data, or execute unauthorized actions.

POST / HTTP/1.1
Content-Length: 13
Transfer-Encoding: chunked

0

GET /admin HTTP/1.1
...

Front-end: "This is a normal POST to /"
Back-end: "This is POST to / followed by GET to /admin"

**Why It's Dangerous:**
‚Ä¢ Bypass WAF rules
‚Ä¢ Access other users' sessions
‚Ä¢ Cache poisoning
‚Ä¢ Reflected XSS without user interaction`,

      technicalDetails: `**CL.TE vs TE.CL:**
CL.TE: Front-end uses Content-Length, Back-end uses Transfer-Encoding
TE.CL: Front-end uses Transfer-Encoding, Back-end uses Content-Length

Each requires different payload construction.

**Testing:**
Use Burp Suite's HTTP Request Smuggler extension
Or manually test with timing differences

**Related: HTTP/2 Downgrade Smuggling:**
HTTP/2 gets translated to HTTP/1.1 by some proxies.
Attackers craft HTTP/2 requests that become malicious HTTP/1.1.

**Defense:**
1. Ensure all systems parse identically (hard)
2. Reject ambiguous requests
3. Use HTTP/2 end-to-end
4. Keep proxy software patched and aligned`,

      realExamples: [
        {
          name: "PayPal (2019)",
          description: "James Kettle demonstrated request smuggling on PayPal, bypassing authentication",
          outcome: "Led to widespread awareness and patching of this attack class"
        },
        {
          name: "CVE-2023-25690 Apache",
          description: "Request splitting vulnerability in Apache HTTP Server mod_proxy",
          outcome: "Patch released, all Apache users advised to update"
        }
      ],

      detectionSignals: [
        "HTTP 400 errors from backend servers",
        "Requests with conflicting Content-Length headers",
        "Unusual chunked encoding patterns",
        "Backend errors about malformed requests",
        "Users seeing other users' responses (cache poisoning)"
      ],

      defenseStrategies: [
        { strategy: "Reject ambiguous requests", command: "Configure proxy to reject CL + TE together" },
        { strategy: "Normalize all requests", command: "Use consistent HTTP parsing across stack" },
        { strategy: "Use HTTP/2 end-to-end", command: "Avoid protocol translation" },
        { strategy: "Keep software updated", command: "Patch nginx, HAProxy, Apache regularly" }
      ]
    },

    nameResolutionAttacks: {
      title: "Name Resolution Manipulation",
      icon: "üó∫Ô∏è",
      summary: "Abuse DNS or local name resolution to redirect traffic to attacker-controlled systems.",

      deepExplanation: `**The Core Concept:**
Before your computer can talk to google.com, it needs to know Google's IP address. Name resolution 
services (DNS, LLMNR, NBNS, mDNS) perform this translation. If an attacker can control name resolution, 
they control where your traffic goes.

**Attack Vectors:**

1. **DNS Cache Poisoning:**
   - Inject fake answers into a resolver's cache
   - All users of that resolver get wrong answers
   - Can redirect banking.com to attacker's server

2. **LLMNR/NBNS Poisoning (Windows):**
   - Windows asks the local network for unknown names
   - Attacker responds first with their own IP
   - Victim connects to attacker instead

3. **Rogue DHCP:**
   - Attacker sets up DHCP server on network
   - Victims get attacker's DNS servers
   - All DNS queries go through attacker

4. **DNS Rebinding:**
   - Attacker's domain initially resolves to attacker
   - Browser loads attacker's JavaScript
   - DNS changes to victim's internal IP
   - JavaScript now accesses internal network

**Why LLMNR/NBNS Is Bad:**
When you mistype a server name, Windows asks the whole network "who is FLESHARE?"
Any device can respond. Attackers run Responder to answer with their IP, 
then capture the authentication attempt.`,

      technicalDetails: `**Responder Attack:**
# Start Responder on Linux
sudo responder -I eth0 -wrf

When Windows user types \\\\wrongservername
- Responder answers the LLMNR query
- User's machine tries to authenticate to Responder
- Responder captures NTLMv2 hash
- Hash can be cracked offline or relayed

**DNS Spoofing at Protocol Level:**
DNS queries have a transaction ID (16 bits = 65536 possibilities).
Attacker must guess the ID to inject fake response.
Kaminsky attack improved odds by guessing many IDs quickly.

**DNSSEC:**
Cryptographically signs DNS records.
Resolvers can verify answers came from authoritative source.
Adoption still incomplete (~30% of domains).`,

      realExamples: [
        {
          name: "Kaminsky Attack (2008)",
          description: "Dan Kaminsky discovered a way to poison DNS caches much faster than previously thought",
          outcome: "Emergency patches released, changed how DNS security is viewed"
        },
        {
          name: "Sea Turtle (2019)",
          description: "State-sponsored actors hijacked DNS for government and military domains",
          outcome: "Credentials stolen from multiple governments, MFA recommended"
        }
      ],

      detectionSignals: [
        "LLMNR/NBNS queries for non-existent names",
        "Multiple DHCP offers on network",
        "DNS resolver changes on endpoints",
        "Unexpected name resolution results",
        "Authentication failures to unexpected hosts"
      ],

      defenseStrategies: [
        { strategy: "Disable LLMNR on Windows", command: "GPO: Turn off multicast name resolution" },
        { strategy: "Disable NetBIOS over TCP/IP", command: "Network adapter advanced settings" },
        { strategy: "Implement DNSSEC", command: "Sign zones, enable validation on resolvers" },
        { strategy: "Enable DHCP snooping", command: "Configure switches to trust only real DHCP server" }
      ]
    }
  };

  const exploitationPatterns = [
    {
      title: "State Exhaustion",
      desc: "Consume server resources by creating many partial or long-lived sessions.",
      impact: "Service slowdown, dropped connections, noisy alerts.",
      signals: "High SYN_RECV, backlog full, spikes in half-open connections.",
      defense: "Enable SYN cookies and apply connection limits.",
    },
    {
      title: "Reflection and Amplification",
      desc: "Abuse UDP services to multiply traffic using spoofed source IPs.",
      impact: "Bandwidth saturation and upstream throttling.",
      signals: "Large response bursts, asymmetric traffic, spikes from UDP services.",
      defense: "Disable amplification vectors and enforce egress filtering.",
    },
    {
      title: "Downgrade Paths",
      desc: "Force older protocol versions or weaker ciphers.",
      impact: "Weaker encryption and easier interception.",
      signals: "Legacy negotiation, weak cipher usage, TLS alerts.",
      defense: "Disable legacy versions and enforce modern suites.",
    },
    {
      title: "Parser Mismatch",
      desc: "Exploit inconsistent protocol parsing between systems.",
      impact: "Desync between proxy and backend, policy bypass.",
      signals: "Conflicting length headers, malformed requests, proxy errors.",
      defense: "Keep parsers aligned and patch gateway software.",
    },
    {
      title: "Unauthenticated Management",
      desc: "Expose admin or control planes without strong auth.",
      impact: "Config changes, data exposure, or service takeover.",
      signals: "Access to management ports from untrusted ranges.",
      defense: "Restrict management interfaces and require MFA.",
    },
    {
      title: "Cleartext Authentication",
      desc: "Credentials sent without encryption on legacy services.",
      impact: "Credentials visible on the wire and easy to reuse.",
      signals: "Credentials visible in packet captures, basic auth usage.",
      defense: "Require TLS and disable cleartext protocols.",
    },
    {
      title: "Name Resolution Manipulation",
      desc: "Abuse DNS or DHCP behavior to redirect traffic.",
      impact: "Users connect to unintended hosts or services.",
      signals: "Resolver changes, DNS anomalies, rogue DHCP offers.",
      defense: "DHCP snooping, DNSSEC, trusted resolvers.",
    },
    {
      title: "Weak Signing or Integrity",
      desc: "Traffic without signing can be modified or replayed.",
      impact: "Session tampering, relay, or unauthorized actions.",
      signals: "Unsigned sessions, policy downgrades, integrity alerts.",
      defense: "Require signing and strong integrity settings.",
    },
  ];

  // ===========================================
  // PART 3: DETECTION METHODOLOGY DEEP DIVE
  // ===========================================

  const detectionMethodologyDetailed = {
    networkMonitoring: {
      title: "Network Traffic Analysis",
      icon: "üìä",
      description: "Understand what's actually happening on your network by capturing and analyzing packets.",
      
      concepts: [
        {
          name: "Packet Capture Basics",
          explanation: `Every packet on your network can be captured and analyzed. This is like wiretapping for data.

**What You Can See:**
‚Ä¢ Source and destination IP addresses
‚Ä¢ Protocols being used (TCP, UDP, ICMP)
‚Ä¢ Port numbers (services being accessed)
‚Ä¢ Packet contents (if not encrypted)
‚Ä¢ Timing and volume patterns

**Where to Capture:**
‚Ä¢ Network tap: Physical device that copies traffic
‚Ä¢ Port mirroring: Switch sends copy to monitoring port
‚Ä¢ Host-based: Software on the endpoint (tcpdump, Wireshark)

**Key Insight:** Even encrypted traffic reveals metadata - who's talking to whom, when, and how much.`,
          tools: ["Wireshark", "tcpdump", "NetworkMiner", "Zeek (Bro)"]
        },
        {
          name: "Flow Analysis",
          explanation: `Instead of storing every packet, flow analysis summarizes connections.

**A Flow Record Contains:**
‚Ä¢ Source/dest IPs and ports
‚Ä¢ Protocol
‚Ä¢ Start/end times
‚Ä¢ Byte and packet counts
‚Ä¢ TCP flags seen

**Why Flows Are Useful:**
‚Ä¢ Less storage than full packets
‚Ä¢ Easy to spot anomalies at scale
‚Ä¢ Show patterns over time
‚Ä¢ Can be retained longer for historical analysis

**NetFlow/IPFIX:**
Standard formats for flow data exported from routers and switches.
Most enterprise networks already generate this - you just need to collect it!`,
          tools: ["ntopng", "nfdump", "SiLK", "Elastic Stack"]
        },
        {
          name: "Deep Packet Inspection",
          explanation: `Look inside packets to understand application-layer behavior.

**What DPI Reveals:**
‚Ä¢ HTTP requests/responses
‚Ä¢ DNS queries and answers
‚Ä¢ File transfers
‚Ä¢ Application identification
‚Ä¢ Malware command & control

**Challenges:**
‚Ä¢ Encryption blinds DPI (TLS, HTTPS)
‚Ä¢ Performance overhead
‚Ä¢ Privacy concerns
‚Ä¢ Evasion techniques (tunneling, steganography)

**TLS Inspection:**
Some organizations decrypt TLS at a proxy to inspect content.
Controversial: breaks end-to-end encryption, adds attack surface.`,
          tools: ["Suricata", "Snort", "Zeek", "nDPI"]
        }
      ],

      practicalExamples: [
        {
          scenario: "Detecting SYN Floods",
          method: "Look for high ratio of SYN to SYN-ACK packets",
          query: "tcpdump -i eth0 'tcp[tcpflags] & tcp-syn != 0'"
        },
        {
          scenario: "Finding DNS Tunneling",
          method: "Unusually long DNS queries, high volume to single domain",
          query: "Look for TXT queries > 200 bytes or queries to unusual TLDs"
        },
        {
          scenario: "Spotting Beacons",
          method: "Regular interval connections to same destination",
          query: "Analyze connection intervals with statistical tools"
        }
      ]
    },

    logAnalysis: {
      title: "Log-Based Detection",
      icon: "üìù",
      description: "Systems generate logs about their activity. Correlating logs reveals attacks.",

      concepts: [
        {
          name: "Log Sources",
          explanation: `Different systems log different things. Each has value for detection.

**Network Devices:**
‚Ä¢ Firewall: Allowed/blocked connections, NAT translations
‚Ä¢ IDS/IPS: Signature matches, anomalies
‚Ä¢ Proxy: URLs accessed, content types

**Servers:**
‚Ä¢ Authentication: Login attempts, failures, account changes
‚Ä¢ Application: Errors, transactions, user actions
‚Ä¢ System: Process creation, file access, privilege changes

**Endpoints:**
‚Ä¢ Windows Event Logs: Security, System, Application
‚Ä¢ Sysmon: Detailed process, network, file activity
‚Ä¢ EDR: Real-time behavioral analysis

**Key Principle:** Attackers leave traces across multiple log sources. Correlation is key!`,
          importance: "Logs are often the only evidence of an attack, especially if network capture wasn't running."
        },
        {
          name: "SIEM Fundamentals",
          explanation: `Security Information and Event Management systems collect, normalize, and analyze logs.

**What a SIEM Does:**
1. Collects logs from everywhere
2. Normalizes to common format
3. Enriches with context (geo, threat intel)
4. Correlates across sources
5. Alerts on rules/anomalies
6. Enables investigation and hunting

**Correlation Example:**
Single event: "Failed login" - probably nothing
Correlated events:
- 100 failed logins from same IP
- Followed by successful login
- Then access to sensitive file
- Then data upload to external site

The pattern reveals the attack!`,
          importance: "Without correlation, you're drowning in individual events."
        },
        {
          name: "Detection Rules vs Anomaly Detection",
          explanation: `Two approaches to finding bad things in logs.

**Signature/Rule-Based:**
‚Ä¢ Define specific patterns to match
‚Ä¢ "If source_country != company_locations AND login_success THEN alert"
‚Ä¢ Low false positives for known attacks
‚Ä¢ Blind to novel attacks

**Anomaly/Behavioral:**
‚Ä¢ Learn what's "normal"
‚Ä¢ Alert on deviations
‚Ä¢ "This user normally logs in 9-5 from New York, but just logged in at 3 AM from Russia"
‚Ä¢ Can detect unknown attacks
‚Ä¢ Higher false positive rate

**Best Practice:** Use both! Rules for known-bad, anomalies for unknown.`,
          importance: "Attackers know signature-based detection; anomaly detection catches them off guard."
        }
      ],

      practicalExamples: [
        {
          scenario: "Detecting Kerberoasting",
          method: "Look for TGS requests for service accounts from non-service hosts",
          query: "EventID 4769 with encryption type 0x17 (RC4) and unusual source hosts"
        },
        {
          scenario: "Finding Lateral Movement",
          method: "Track authentication across systems",
          query: "Correlate EventID 4624 (logon) across hosts with timeline analysis"
        },
        {
          scenario: "Spotting Data Exfiltration",
          method: "Monitor for unusual data transfers",
          query: "Large uploads, connections to cloud storage, encoded/compressed traffic"
        }
      ]
    },

    threatHunting: {
      title: "Proactive Threat Hunting",
      icon: "üîç",
      description: "Don't wait for alerts - actively search for attackers who evaded detection.",

      concepts: [
        {
          name: "Hunt Hypothesis",
          explanation: `Start with an educated guess about what attackers might do.

**Building Hypotheses:**
‚Ä¢ Study recent attacks on similar organizations
‚Ä¢ Review threat intelligence for relevant actors
‚Ä¢ Consider your critical assets - how would attackers target them?
‚Ä¢ Think about gaps in your detection

**Example Hypothesis:**
"Attackers may have compromised credentials and are moving laterally via RDP to reach database servers."

**Testing the Hypothesis:**
1. Identify all RDP connections to database servers
2. Check if source hosts normally connect via RDP
3. Validate user accounts are legitimate
4. Look for suspicious timing or volume

**Document Everything:** Even finding nothing is valuable - it builds confidence and baseline.`,
          importance: "Hypothesis-driven hunting is more efficient than looking for 'anything suspicious'."
        },
        {
          name: "MITRE ATT&CK Framework",
          explanation: `A comprehensive catalog of attacker techniques used in real intrusions.

**Structure:**
‚Ä¢ Tactics: The attacker's goal (e.g., "Lateral Movement", "Exfiltration")
‚Ä¢ Techniques: How they achieve the goal (e.g., "Pass the Hash", "Data Encrypted")
‚Ä¢ Procedures: Specific implementation details from real attacks

**Using ATT&CK for Hunting:**
1. Pick a technique you haven't hunted recently
2. Read about detection methods in the ATT&CK page
3. Search your logs/traffic for those indicators
4. Document findings and improve detection

**Example:** Technique T1003 - OS Credential Dumping
Hunt for: LSASS access, suspicious process spawning from lsass.exe, memory dump files

**Value:** Ensures you're hunting for techniques real attackers use, not theoretical attacks.`,
          importance: "ATT&CK provides structure and shared vocabulary for threat hunting."
        },
        {
          name: "Behavioral Indicators",
          explanation: `Instead of signatures, look for behaviors that indicate malicious activity.

**Process Behaviors:**
‚Ä¢ PowerShell spawning from Word/Excel
‚Ä¢ Command shells from web servers
‚Ä¢ Services starting at unusual times
‚Ä¢ Process hollowing (image mismatch)

**Network Behaviors:**
‚Ä¢ Regular beacon intervals
‚Ä¢ Long DNS queries (tunneling)
‚Ä¢ Connections to newly registered domains
‚Ä¢ Large data transfers at night

**Account Behaviors:**
‚Ä¢ Service accounts logging in interactively
‚Ä¢ Admin accounts used from non-admin workstations
‚Ä¢ Accounts used from multiple locations simultaneously

**Key Insight:** Behaviors are harder to change than indicators (IPs, hashes). Attackers who change tactics are slowed down.`,
          importance: "Behavioral detection is more durable than IOC-based detection."
        }
      ],

      practicalExamples: [
        {
          scenario: "Hunt for Living-off-the-Land",
          method: "Find misuse of legitimate admin tools",
          query: "Look for certutil downloading files, PowerShell encoded commands, mshta.exe execution"
        },
        {
          scenario: "Hunt for Persistence",
          method: "Check common persistence locations",
          query: "Registry Run keys, scheduled tasks, service installations, WMI subscriptions"
        },
        {
          scenario: "Hunt for C2",
          method: "Find beaconing traffic",
          query: "Statistical analysis of connection intervals, connections to rare destinations"
        }
      ]
    }
  };

  const detectionSignals = [
    "Unusual spikes in half-open TCP connections.",
    "Large UDP responses to small requests.",
    "Legacy protocol versions negotiated unexpectedly.",
    "Repeated parser or handshake errors in logs.",
    "Management services reachable from the wrong networks.",
    "Unexpected broadcast or multicast traffic.",
    "Authentication attempts on legacy services.",
    "Sudden increase in DNS NXDOMAIN or SERVFAIL responses.",
    "New services listening on critical ports.",
    "Handshake retries or resets outside normal baselines.",
  ];

  const telemetrySources = [
    "Firewall and load balancer logs for connection patterns.",
    "Packet captures (Wireshark, tcpdump) for protocol anomalies.",
    "TLS termination logs for negotiated ciphers and versions.",
    "DNS resolver logs for recursion and response size spikes.",
    "EDR or host logs for service restarts and crashes.",
    "NetFlow or sFlow summaries for traffic volume changes.",
    "IDS/IPS alerts for malformed packets or protocol abuse.",
  ];

  const detectionMatrix = [
    {
      stage: "Discovery",
      signal: "Burst of scans or probes to protocol-specific ports.",
      evidence: "Firewall logs and flow data.",
    },
    {
      stage: "Negotiation",
      signal: "Downgrade attempts or handshake failures.",
      evidence: "TLS logs, proxy errors, server logs.",
    },
    {
      stage: "Abuse",
      signal: "Resource spikes or malformed packets.",
      evidence: "System metrics, IDS alerts, packet captures.",
    },
    {
      stage: "Impact",
      signal: "Service instability or access anomalies.",
      evidence: "Service health checks and incident tickets.",
    },
  ];

  const baselineMetrics = [
    {
      metric: "Half-open TCP connections",
      normal: "Low and stable for each service.",
      investigate: "Sustained spike or backlog warnings.",
    },
    {
      metric: "UDP response size",
      normal: "Consistent with known services.",
      investigate: "Large bursts or sudden growth in size.",
    },
    {
      metric: "TLS version usage",
      normal: "Mostly TLS 1.2+ with modern ciphers.",
      investigate: "Unexpected TLS 1.0/1.1 or weak cipher use.",
    },
    {
      metric: "DNS error rates",
      normal: "Stable NXDOMAIN and SERVFAIL rates.",
      investigate: "Sudden spikes or resolver changes.",
    },
    {
      metric: "Auth failures by service",
      normal: "Predictable pattern per business hours.",
      investigate: "Sudden bursts or new source IPs.",
    },
    {
      metric: "Protocol parsing errors",
      normal: "Low and consistent error rate.",
      investigate: "Repeated 400/431 or protocol errors.",
    },
  ];

  const triageSteps = [
    "Confirm the affected service and scope (which ports, which hosts).",
    "Compare to baseline for the same time window.",
    "Review the last 24 hours of configuration changes.",
    "Check upstream devices (load balancers, firewalls) for errors.",
    "Capture a small packet sample for validation if approved.",
  ];

  const logQueries = [
    {
      label: "Splunk: legacy TLS versions",
      language: "splunk",
      query:
        "index=tls (ssl_version=\"TLS 1.0\" OR ssl_version=\"TLS 1.1\") | stats count by dest, ssl_version",
    },
    {
      label: "KQL: large UDP responses",
      language: "kql",
      query:
        "DeviceNetworkEvents\n| where Protocol == \"Udp\"\n| where SentBytes > 5000 and ReceivedBytes < 200\n| summarize count() by RemotePort, RemoteIP",
    },
    {
      label: "Nginx: parsing errors",
      language: "bash",
      query: "awk '$9 ~ /400|414|431/' /var/log/nginx/access.log | head -n 20",
    },
    {
      label: "DNS logs: response size spike",
      language: "text",
      query:
        "Filter on response size and error codes.\nLook for large answers, SERVFAIL spikes, or new resolvers.",
    },
  ];

  const hardeningChecklist = [
    "Disable legacy protocols and weak cipher suites.",
    "Limit management services to dedicated admin networks.",
    "Apply protocol-aware rate limits and connection caps.",
    "Patch gateways, proxies, and protocol libraries regularly.",
    "Enable authentication and signing where supported.",
    "Use segmentation to reduce lateral movement paths.",
    "Monitor protocol negotiation and error rates.",
    "Document normal protocol baselines for quick detection.",
    "Enable egress filtering to reduce spoofing risk.",
    "Standardize TLS policy across all entry points.",
  ];

  const hardeningTracks = [
    {
      title: "Transport Layer",
      items: [
        "Enable SYN cookies and tune timeouts.",
        "Set connection and rate limits for exposed services.",
        "Drop malformed packets early at the edge.",
      ],
    },
    {
      title: "Name Resolution",
      items: [
        "Restrict DNS recursion to trusted clients.",
        "Enable DNSSEC validation where possible.",
        "Monitor resolver changes and response size.",
      ],
    },
    {
      title: "Identity and Auth",
      items: [
        "Require LDAPS and disable anonymous binds.",
        "Enforce Kerberos time sync and limit delegation.",
        "Disable weak auth or legacy fallback methods.",
      ],
    },
    {
      title: "Management and Remote Access",
      items: [
        "Place SSH/RDP behind a jump host or VPN.",
        "Require MFA for admin access.",
        "Restrict management ports to admin networks.",
      ],
    },
    {
      title: "Monitoring and Logging",
      items: [
        "Log protocol version and cipher usage.",
        "Alert on parsing errors and handshake failures.",
        "Keep flow baselines for critical services.",
      ],
    },
  ];

  const legacyDeprecations = [
    {
      protocol: "SMBv1",
      risk: "Legacy protocol with weak security controls.",
      action: "Disable across clients and servers.",
    },
    {
      protocol: "TLS 1.0/1.1",
      risk: "Weak ciphers and downgrade exposure.",
      action: "Disable at load balancers and servers.",
    },
    {
      protocol: "SNMPv1/v2c",
      risk: "Unauthenticated community strings.",
      action: "Move to SNMPv3 and restrict access.",
    },
    {
      protocol: "Telnet/FTP",
      risk: "Cleartext credentials and data.",
      action: "Replace with SSH/SFTP.",
    },
    {
      protocol: "LLMNR/NBT-NS",
      risk: "Name resolution abuse on local networks.",
      action: "Disable where policy allows.",
    },
  ];

  const safeChecks = `# Windows: summarize TCP states
Get-NetTCPConnection | Group-Object State | Sort-Object Count -Descending

# Windows: show listening ports (top 10)
Get-NetTCPConnection -State Listen | Select-Object -First 10

# Windows: show UDP listeners (top 10)
Get-NetUDPEndpoint | Select-Object -First 10

# Linux: socket summary
ss -s

# Linux: list half-open connections
ss -ant state syn-recv

# Linux: list listening TCP and UDP ports
ss -lntup

# macOS: protocol statistics (summary)
netstat -s | head -n 20`;

  // ===========================================
  // PART 3: HANDS-ON LAB DEEP DIVE
  // ===========================================

  const labExercisesDetailed = {
    packetAnalysisLab: {
      title: "Packet Capture & Analysis Fundamentals",
      difficulty: "Beginner",
      estimatedTime: "45 minutes",
      objectives: [
        "Learn to capture network traffic with tcpdump and Wireshark",
        "Understand TCP three-way handshake in real packets",
        "Identify different protocol types in captures",
        "Extract useful information from packet headers"
      ],
      
      prerequisites: [
        "Wireshark installed",
        "tcpdump available (Linux/Mac) or Npcap (Windows)",
        "Basic understanding of TCP/IP from Fundamentals tab"
      ],

      steps: [
        {
          number: 1,
          title: "Start a Basic Capture",
          explanation: "First, let's capture some traffic to analyze. We'll use tcpdump for command-line capture.",
          commands: [
            "# List available interfaces",
            "tcpdump -D",
            "",
            "# Start capture on your main interface (replace eth0)",
            "sudo tcpdump -i eth0 -w /tmp/first_capture.pcap",
            "",
            "# Generate some traffic by browsing web",
            "# Then press Ctrl+C to stop capture"
          ],
          expectedOutput: "You should see packet count increasing as you browse. File saved when you stop.",
          tips: [
            "Use '-c 100' to auto-stop after 100 packets",
            "Add '-nn' to disable DNS resolution for faster output",
            "If no traffic appears, verify you're on the right interface"
          ]
        },
        {
          number: 2,
          title: "Open Capture in Wireshark",
          explanation: "Wireshark provides visual analysis of captured packets with protocol decoding.",
          commands: [
            "# Open the capture file",
            "wireshark /tmp/first_capture.pcap",
            "",
            "# Or start live capture from Wireshark GUI:",
            "# 1. Select your interface",
            "# 2. Click the blue shark fin to start"
          ],
          expectedOutput: "Wireshark window with colored packets. Different colors = different protocols.",
          tips: [
            "Green = HTTP traffic",
            "Blue = DNS traffic", 
            "Black = TCP problems (errors, retransmits)",
            "Light purple = TCP handshake packets"
          ]
        },
        {
          number: 3,
          title: "Find and Follow a TCP Handshake",
          explanation: "Let's see the three-way handshake in action by filtering for a specific connection.",
          commands: [
            "# In Wireshark filter bar, enter:",
            "tcp.flags.syn == 1",
            "",
            "# Click on any SYN packet",
            "# Right-click ‚Üí Follow ‚Üí TCP Stream",
            "# This shows the entire conversation"
          ],
          expectedOutput: "You should see SYN ‚Üí SYN-ACK ‚Üí ACK sequence. Stream dialog shows application data.",
          tips: [
            "Note the sequence numbers in each packet",
            "SEQ in SYN, SEQ+1 acknowledged in ACK",
            "This is how TCP ensures reliable delivery"
          ]
        },
        {
          number: 4,
          title: "Extract DNS Queries",
          explanation: "Every website visit starts with DNS. Let's see what your computer is looking up.",
          commands: [
            "# Filter for DNS only",
            "dns",
            "",
            "# Or more specific - DNS queries only",
            "dns.flags.response == 0",
            "",
            "# Export DNS data",
            "# File ‚Üí Export Packet Dissections ‚Üí As CSV"
          ],
          expectedOutput: "List of all DNS queries showing domains your computer looked up.",
          tips: [
            "Look at the 'Answers' section for resolved IPs",
            "Multiple queries for same domain? That's TTL expiring",
            "Queries to unusual domains? Could be malware"
          ]
        }
      ],

      practiceExercise: {
        title: "Find the Hidden Protocol",
        instructions: "Download a sample PCAP and answer these questions:",
        questions: [
          "How many TCP connections were established?",
          "What DNS name was queried most frequently?",
          "Can you find any HTTP requests? What was requested?",
          "Are there any failed connections (RST packets)?"
        ],
        hints: [
          "Use 'Statistics ‚Üí Conversations' for connection counts",
          "Use 'Statistics ‚Üí DNS' for query analysis",
          "Filter 'http.request' for HTTP requests",
          "Filter 'tcp.flags.reset == 1' for RST packets"
        ]
      }
    },

    arpPoisoningLab: {
      title: "ARP Poisoning & Detection",
      difficulty: "Intermediate",
      estimatedTime: "60 minutes",
      objectives: [
        "Understand how ARP poisoning works at packet level",
        "Perform a safe ARP spoofing exercise",
        "Learn to detect ARP poisoning attacks",
        "Implement defensive measures"
      ],

      prerequisites: [
        "Isolated lab network (VMs recommended)",
        "Kali Linux or system with arpspoof",
        "Wireshark for monitoring",
        "TWO other machines/VMs to test with"
      ],

      safetyWarning: "‚ö†Ô∏è ONLY perform on networks you own or have written permission to test. ARP spoofing on production networks is illegal and harmful.",

      steps: [
        {
          number: 1,
          title: "Understand Normal ARP",
          explanation: "First, observe how ARP normally works on your network.",
          commands: [
            "# View your ARP cache",
            "arp -a",
            "",
            "# Clear the cache and watch it rebuild",
            "# On Linux:",
            "sudo ip -s -s neigh flush all",
            "",
            "# Ping another machine on your network",
            "ping 192.168.1.1",
            "",
            "# Check ARP cache again - new entry appeared!"
          ],
          expectedOutput: "ARP cache shows MAC address associated with each IP.",
          tips: [
            "Notice the ARP cache has a timeout",
            "Entries are created by ARP requests/replies",
            "Gateway's MAC is particularly important"
          ]
        },
        {
          number: 2,
          title: "Watch ARP Traffic",
          explanation: "Capture ARP to see the request/reply pattern.",
          commands: [
            "# Filter for ARP in Wireshark",
            "arp",
            "",
            "# Or with tcpdump",
            "sudo tcpdump -i eth0 arp -vvv",
            "",
            "# Generate ARP by pinging unknown host",
            "ping 192.168.1.254"
          ],
          expectedOutput: "ARP Request: 'Who has 192.168.1.254?' followed by ARP Reply with MAC address.",
          tips: [
            "ARP requests are broadcast to all hosts",
            "ARP replies are unicast to requester",
            "Gratuitous ARP: host announces its own mapping"
          ]
        },
        {
          number: 3,
          title: "Perform ARP Spoofing (Lab Only!)",
          explanation: "On your isolated lab, become a man-in-the-middle using ARP spoofing.",
          commands: [
            "# Enable IP forwarding so traffic flows through you",
            "sudo sysctl -w net.ipv4.ip_forward=1",
            "",
            "# Tell victim that you are the gateway",
            "sudo arpspoof -i eth0 -t 192.168.1.100 192.168.1.1",
            "",
            "# In another terminal, tell gateway you are the victim",
            "sudo arpspoof -i eth0 -t 192.168.1.1 192.168.1.100",
            "",
            "# Now victim's traffic flows: Victim ‚Üí You ‚Üí Gateway"
          ],
          expectedOutput: "Victim's ARP cache now has YOUR MAC for the gateway IP.",
          tips: [
            "Check victim's ARP cache to confirm spoofing worked",
            "Without IP forwarding, you'd just DoS the victim",
            "This is how attackers intercept traffic"
          ]
        },
        {
          number: 4,
          title: "Detect the Attack",
          explanation: "Learn what ARP poisoning looks like in Wireshark and system logs.",
          commands: [
            "# In Wireshark, enable ARP anomaly detection",
            "# Edit ‚Üí Preferences ‚Üí Protocols ‚Üí ARP",
            "# Check 'Detect ARP storms'",
            "",
            "# Look for these Wireshark warnings:",
            "# - Duplicate use of IP address",
            "# - ARP reply seen without request",
            "",
            "# On Linux, use arpwatch",
            "sudo apt install arpwatch",
            "sudo arpwatch -i eth0"
          ],
          expectedOutput: "Wireshark shows warnings about duplicate IP-MAC mappings. Arpwatch logs the change.",
          tips: [
            "Legitimate networks have stable ARP mappings",
            "Changes should be investigated",
            "Gateway MAC changing is especially suspicious"
          ]
        }
      ],

      practiceExercise: {
        title: "Build an ARP Monitor",
        instructions: "Write a Python script that detects ARP spoofing:",
        questions: [
          "Monitor ARP traffic using Scapy",
          "Track known IP-MAC mappings",
          "Alert when a MAC address changes for a known IP",
          "Bonus: Identify gratuitous ARP floods"
        ],
        hints: [
          "from scapy.all import sniff, ARP",
          "Store mappings in a dictionary",
          "filter='arp' in sniff() call",
          "Check if op field is 2 (reply)"
        ]
      }
    },

    dnsAnalysisLab: {
      title: "DNS Security Analysis",
      difficulty: "Intermediate",
      estimatedTime: "60 minutes",
      objectives: [
        "Analyze DNS traffic patterns",
        "Detect DNS tunneling attempts",
        "Identify suspicious DNS behavior",
        "Understand DNSSEC validation"
      ],

      prerequisites: [
        "Wireshark with DNS packets",
        "dig command available",
        "Sample DNS pcaps (malware, tunneling)"
      ],

      steps: [
        {
          number: 1,
          title: "Understand DNS Query Types",
          explanation: "Learn the different DNS record types and what they reveal.",
          commands: [
            "# Query different record types",
            "dig example.com A      # IPv4 address",
            "dig example.com AAAA   # IPv6 address",
            "dig example.com MX     # Mail servers",
            "dig example.com TXT    # Text records (often SPF, DKIM)",
            "dig example.com NS     # Name servers",
            "",
            "# See the full DNS response",
            "dig example.com +noall +answer +additional"
          ],
          expectedOutput: "Different record types return different information. Note response sizes vary.",
          tips: [
            "TXT records can be very large - used for tunneling",
            "ANY queries return all records - good for recon",
            "Check response sizes for anomaly detection"
          ]
        },
        {
          number: 2,
          title: "Detect DNS Tunneling Indicators",
          explanation: "DNS tunneling hides data in DNS queries. Learn the signs.",
          commands: [
            "# In Wireshark, look for:",
            "# 1. Long query names (> 50 chars in subdomain)",
            "dns.qry.name matches '.{50,}'",
            "",
            "# 2. High volume of TXT queries",
            "dns.qry.type == 16",
            "",
            "# 3. Base64/hex patterns in subdomains",
            "# aGVsbG8gd29ybGQ.tunnel.evil.com",
            "",
            "# Baseline normal DNS volume first!"
          ],
          expectedOutput: "Tunneling traffic has unusual query patterns: long names, high volume, strange encoding.",
          tips: [
            "Normal domains rarely have subdomains > 20 chars",
            "Lots of TXT queries to one domain = suspicious",
            "Calculate query entropy - random = tunneling"
          ]
        },
        {
          number: 3,
          title: "DNSSEC Validation Check",
          explanation: "See how DNSSEC protects DNS integrity.",
          commands: [
            "# Query with DNSSEC requested",
            "dig example.com +dnssec",
            "",
            "# Look for RRSIG records (signatures)",
            "# AD flag means Answer Authenticated",
            "",
            "# Check chain of trust",
            "dig DS example.com @8.8.8.8",
            "",
            "# Validate explicitly",
            "delv example.com @8.8.8.8"
          ],
          expectedOutput: "DNSSEC-signed domains return RRSIG records. AD flag indicates validation passed.",
          tips: [
            "Not all domains have DNSSEC",
            "Validation happens at resolver level",
            "DNSSEC prevents cache poisoning"
          ]
        }
      ],

      practiceExercise: {
        title: "DNS Threat Hunter",
        instructions: "Analyze a suspicious DNS pcap and answer:",
        questions: [
          "What domains have unusually long subdomains?",
          "Calculate the ratio of TXT queries to A queries",
          "Find the domain with most queries - is it suspicious?",
          "Are any responses NXDOMAIN that should exist?"
        ],
        hints: [
          "Use tshark for CLI analysis",
          "tshark -r capture.pcap -T fields -e dns.qry.name",
          "Sort unique queries to find top talkers",
          "NXDOMAIN for legit domains = DNS hijacking"
        ]
      }
    }
  };

  const labSteps = [
    "Create an isolated lab with two VMs (client and server).",
    "Record baseline listening ports and services.",
    "Generate normal traffic: ping, DNS lookup, and a simple HTTP request.",
    "Capture traffic in Wireshark or tcpdump for 1-2 minutes.",
    "Label handshake stages in the capture (SYN, SYN-ACK, ACK).",
    "Find a DNS query and note response size and TTL.",
    "Identify a TLS handshake and record version and cipher (if present).",
    "Compare how TCP and UDP handle state and retransmissions.",
    "Write down what normal looks like for future baselines.",
  ];
  const labExercises = [
    "Locate one TCP handshake and one UDP exchange in the capture.",
    "Measure the largest UDP response and document the service.",
    "List all unique destination ports seen in 2 minutes.",
    "Note any malformed or reset connections and their source.",
  ];
  const pcapChecklist = [
    "Handshake packets labeled and annotated.",
    "DNS query and response pair recorded.",
    "TLS version and cipher recorded if applicable.",
    "Top talkers by bytes listed.",
    "Any errors or resets noted with timestamps.",
  ];
  const labArtifacts = [
    "lab.pcap",
    "baseline-notes.md",
    "screenshot of key Wireshark filters",
  ];
  const baselineTemplate = `# Protocol Baseline Notes
Date:
Environment:

Listening services (host:port):
- 

TLS policy observed:
- Versions:
- Ciphers:

DNS baseline:
- Resolver IPs:
- Typical response size range:

Anomalies observed:
- 
`;
  const safeBoundaries = [
    "Only test in a lab or with explicit written authorization.",
    "Do not run exploit tools on production or public networks.",
    "Avoid scanning external IP ranges without approval.",
    "Focus on observation, logging, and defensive verification.",
    "Use synthetic traffic and lab-only accounts.",
  ];

  const pageContext = `This page covers network protocol exploitation techniques including attacks on TCP/IP, DNS, DHCP, SMB, SNMP, and other common protocols. Topics include protocol weaknesses, man-in-the-middle attacks, spoofing, injection, and defensive hardening measures.`;

  return (
    <LearnPageLayout pageTitle="Network Protocol Exploitation" pageContext={pageContext}>
    <Box sx={{ minHeight: "100vh", bgcolor: "#0b101a", py: 4 }}>
      <Container maxWidth="lg">
        <Chip
          component={Link}
          to="/learn"
          icon={<ArrowBackIcon />}
          label="Back to Learning Hub"
          clickable
          variant="outlined"
          sx={{ borderRadius: 2, mb: 2 }}
        />

        <Box sx={{ display: "flex", alignItems: "center", gap: 2, mb: 2 }}>
          <RouterIcon sx={{ fontSize: 42, color: "#0ea5e9" }} />
          <Typography
            variant="h3"
            sx={{
              fontWeight: 700,
              background: "linear-gradient(135deg, #0ea5e9 0%, #f59e0b 100%)",
              backgroundClip: "text",
              WebkitBackgroundClip: "text",
              color: "transparent",
            }}
          >
            Network Protocol Exploitation
          </Typography>
        </Box>
        <Typography variant="h6" sx={{ color: "grey.400", mb: 2 }}>
          Learn how protocol weaknesses are abused and how to detect and harden against them.
        </Typography>

        <Alert severity="warning" sx={{ mb: 3 }}>
          This page is for defensive education and authorized security testing only.
        </Alert>

        <Paper sx={{ p: 2.5, mb: 3, bgcolor: "#0f1422", borderRadius: 2 }}>
          <Typography variant="body1" sx={{ color: "grey.300", mb: 1 }}>
            Network protocols are designed for reliability and interoperability, not for security first. Attackers
            exploit those design gaps by abusing state, forcing downgrades, or leveraging inconsistent parsing. This
            guide focuses on the most common protocol exploitation themes and how to defend against them.
          </Typography>
          <Typography variant="body2" sx={{ color: "grey.400" }}>
            The goal is not to teach offensive tradecraft. Instead, you will learn what to monitor, how to harden
            services, and how to validate configurations safely in a lab.
          </Typography>
        </Paper>

        <Box sx={{ display: "flex", gap: 1, flexWrap: "wrap", mb: 3 }}>
          <Chip icon={<RouterIcon />} label="TCP" size="small" />
          <Chip icon={<RouterIcon />} label="UDP" size="small" />
          <Chip icon={<StorageIcon />} label="DNS" size="small" />
          <Chip icon={<SecurityIcon />} label="TLS" size="small" />
          <Chip icon={<ShieldIcon />} label="SMB" size="small" />
          <Chip icon={<RouterIcon />} label="RDP" size="small" />
          <Chip icon={<RouterIcon />} label="SSH" size="small" />
          <Chip icon={<SearchIcon />} label="Detection" size="small" />
        </Box>

        <Paper sx={{ bgcolor: "#111826", borderRadius: 2 }}>
          <Tabs
            value={tabValue}
            onChange={(_, v) => setTabValue(v)}
            variant="scrollable"
            scrollButtons="auto"
            sx={{
              borderBottom: "1px solid rgba(255,255,255,0.08)",
              "& .MuiTab-root": { color: "grey.400" },
              "& .Mui-selected": { color: "#0ea5e9" },
            }}
          >
            <Tab icon={<SchoolIcon />} label="Fundamentals" />
            <Tab icon={<SecurityIcon />} label="Overview" />
            <Tab icon={<StorageIcon />} label="Protocol Map" />
            <Tab icon={<TuneIcon />} label="Exploitation Patterns" />
            <Tab icon={<SearchIcon />} label="Detection" />
            <Tab icon={<ShieldIcon />} label="Hardening" />
            <Tab icon={<BuildIcon />} label="Safe Lab" />
          </Tabs>

          {/* ============================================ */}
          {/* TAB 0: FUNDAMENTALS - New comprehensive tab */}
          {/* ============================================ */}
          <TabPanel value={tabValue} index={0}>
            <Box sx={{ p: 3 }} ref={contentRef}>
              {/* Introduction for absolute beginners */}
              <Alert severity="info" sx={{ mb: 3 }}>
                <Typography variant="body2">
                  <strong>New to networking?</strong> Start here! This section explains the fundamental concepts 
                  you need to understand before diving into protocol exploitation. Take your time with each section - 
                  these concepts are the foundation for everything else on this page.
                </Typography>
              </Alert>

              {/* What is Networking */}
              <Paper sx={{ p: 3, mb: 3, bgcolor: "#0f1422", borderRadius: 2, border: "1px solid rgba(14, 165, 233, 0.2)" }}>
                <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 2 }}>
                  <LanIcon sx={{ color: "#0ea5e9" }} />
                  <Typography variant="h5" sx={{ color: "#0ea5e9", fontWeight: 600 }}>
                    {networkingFundamentals.whatIsNetworking.title}
                  </Typography>
                </Box>
                <Typography 
                  variant="body1" 
                  sx={{ 
                    color: "grey.300", 
                    whiteSpace: "pre-line", 
                    lineHeight: 1.8,
                    '& strong': { color: '#f59e0b' }
                  }}
                  dangerouslySetInnerHTML={{ 
                    __html: networkingFundamentals.whatIsNetworking.content
                      .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                      .replace(/‚Ä¢/g, '<br/>‚Ä¢')
                  }}
                />
              </Paper>

              {/* What is a Packet */}
              <Paper sx={{ p: 3, mb: 3, bgcolor: "#0f1422", borderRadius: 2, border: "1px solid rgba(14, 165, 233, 0.2)" }}>
                <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 2 }}>
                  <NetworkCheckIcon sx={{ color: "#0ea5e9" }} />
                  <Typography variant="h5" sx={{ color: "#0ea5e9", fontWeight: 600 }}>
                    {networkingFundamentals.packetsExplained.title}
                  </Typography>
                </Box>
                <Typography 
                  variant="body1" 
                  sx={{ 
                    color: "grey.300", 
                    whiteSpace: "pre-line", 
                    lineHeight: 1.8,
                    '& strong': { color: '#f59e0b' }
                  }}
                  dangerouslySetInnerHTML={{ 
                    __html: networkingFundamentals.packetsExplained.content
                      .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                  }}
                />
              </Paper>

              {/* OSI Model */}
              <Paper sx={{ p: 3, mb: 3, bgcolor: "#0f1422", borderRadius: 2, border: "1px solid rgba(245, 158, 11, 0.2)" }}>
                <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 2 }}>
                  <StorageIcon sx={{ color: "#f59e0b" }} />
                  <Typography variant="h5" sx={{ color: "#f59e0b", fontWeight: 600 }}>
                    {networkingFundamentals.osiModel.title}
                  </Typography>
                </Box>
                <Typography 
                  variant="body1" 
                  sx={{ 
                    color: "grey.300", 
                    whiteSpace: "pre-line", 
                    lineHeight: 1.8,
                    '& strong': { color: '#0ea5e9' }
                  }}
                  dangerouslySetInnerHTML={{ 
                    __html: networkingFundamentals.osiModel.content
                      .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                  }}
                />
              </Paper>

              {/* TCP/IP Stack */}
              <Paper sx={{ p: 3, mb: 3, bgcolor: "#0f1422", borderRadius: 2, border: "1px solid rgba(14, 165, 233, 0.2)" }}>
                <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 2 }}>
                  <RouterIcon sx={{ color: "#0ea5e9" }} />
                  <Typography variant="h5" sx={{ color: "#0ea5e9", fontWeight: 600 }}>
                    {networkingFundamentals.tcpIpStack.title}
                  </Typography>
                </Box>
                <Typography 
                  variant="body1" 
                  sx={{ 
                    color: "grey.300", 
                    whiteSpace: "pre-line", 
                    lineHeight: 1.8,
                    fontFamily: "inherit",
                    '& strong': { color: '#f59e0b' }
                  }}
                  dangerouslySetInnerHTML={{ 
                    __html: networkingFundamentals.tcpIpStack.content
                      .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                  }}
                />
              </Paper>

              {/* IP Addressing */}
              <Paper sx={{ p: 3, mb: 3, bgcolor: "#0f1422", borderRadius: 2, border: "1px solid rgba(245, 158, 11, 0.2)" }}>
                <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 2 }}>
                  <DnsIcon sx={{ color: "#f59e0b" }} />
                  <Typography variant="h5" sx={{ color: "#f59e0b", fontWeight: 600 }}>
                    {networkingFundamentals.ipAddressing.title}
                  </Typography>
                </Box>
                <Typography 
                  variant="body1" 
                  sx={{ 
                    color: "grey.300", 
                    whiteSpace: "pre-line", 
                    lineHeight: 1.8,
                    '& strong': { color: '#0ea5e9' }
                  }}
                  dangerouslySetInnerHTML={{ 
                    __html: networkingFundamentals.ipAddressing.content
                      .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                  }}
                />
              </Paper>

              {/* How Data Flows */}
              <Paper sx={{ p: 3, mb: 3, bgcolor: "#0f1422", borderRadius: 2, border: "1px solid rgba(16, 185, 129, 0.2)" }}>
                <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 2 }}>
                  <HttpIcon sx={{ color: "#10b981" }} />
                  <Typography variant="h5" sx={{ color: "#10b981", fontWeight: 600 }}>
                    {networkingFundamentals.howDataFlows.title}
                  </Typography>
                </Box>
                <Typography 
                  variant="body1" 
                  sx={{ 
                    color: "grey.300", 
                    whiteSpace: "pre-line", 
                    lineHeight: 1.8,
                    fontFamily: "inherit",
                    '& strong': { color: '#f59e0b' }
                  }}
                  dangerouslySetInnerHTML={{ 
                    __html: networkingFundamentals.howDataFlows.content
                      .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                  }}
                />
              </Paper>

              {/* Attack Surfaces Section */}
              <Typography variant="h5" sx={{ color: "#f59e0b", mb: 2, mt: 4 }}>
                üéØ Understanding Attack Surfaces
              </Typography>
              <Typography variant="body1" sx={{ color: "grey.400", mb: 3 }}>
                An "attack surface" is any point where an attacker might try to enter or extract data from your network. 
                Understanding these surfaces helps you know what to protect and monitor.
              </Typography>

              <Grid container spacing={2} sx={{ mb: 4 }}>
                {attackSurfaces.map((surface) => (
                  <Grid item xs={12} md={6} key={surface.surface}>
                    <Paper sx={{ p: 2.5, bgcolor: "#0f1422", borderRadius: 2, height: "100%", border: "1px solid rgba(255,255,255,0.05)" }}>
                      <Typography variant="h6" sx={{ color: "#0ea5e9", mb: 1 }}>
                        {surface.surface}
                      </Typography>
                      <Typography variant="body2" sx={{ color: "grey.300", mb: 1.5 }}>
                        {surface.description}
                      </Typography>
                      <Typography variant="body2" sx={{ color: "#f59e0b", mb: 1 }}>
                        <strong>Risks:</strong> {surface.risks}
                      </Typography>
                      <Typography variant="body2" sx={{ color: "#10b981" }}>
                        <strong>Defenses:</strong> {surface.defenses}
                      </Typography>
                    </Paper>
                  </Grid>
                ))}
              </Grid>

              {/* Real World Scenarios */}
              <Typography variant="h5" sx={{ color: "#ef4444", mb: 2 }}>
                üî• Real-World Attack Scenarios
              </Typography>
              <Typography variant="body1" sx={{ color: "grey.400", mb: 3 }}>
                These examples show how network protocol weaknesses are exploited in practice. 
                Understanding these helps you recognize and defend against similar attacks.
              </Typography>

              {realWorldScenarios.map((scenario, index) => (
                <Accordion key={index} sx={{ bgcolor: "#0f1422", mb: 1, '&:before': { display: 'none' } }}>
                  <AccordionSummary expandIcon={<ExpandMoreIcon sx={{ color: "grey.400" }} />}>
                    <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
                      <BugReportIcon sx={{ color: "#ef4444" }} />
                      <Box>
                        <Typography variant="subtitle1" sx={{ color: "#e2e8f0", fontWeight: 600 }}>
                          {scenario.title}
                        </Typography>
                        <Chip 
                          label={scenario.difficulty} 
                          size="small" 
                          sx={{ 
                            mt: 0.5,
                            bgcolor: scenario.difficulty.includes('Beginner') ? '#22c55e' : 
                                    scenario.difficulty.includes('Intermediate') ? '#f59e0b' : '#ef4444',
                            color: '#000'
                          }} 
                        />
                      </Box>
                    </Box>
                  </AccordionSummary>
                  <AccordionDetails>
                    <Typography variant="body2" sx={{ color: "grey.300", mb: 2 }}>
                      <strong style={{ color: '#0ea5e9' }}>Scenario:</strong> {scenario.scenario}
                    </Typography>
                    <Typography variant="body2" sx={{ color: "grey.300", mb: 2 }}>
                      <strong style={{ color: '#f59e0b' }}>Techniques Used:</strong> {scenario.techniques}
                    </Typography>
                    <Alert severity="success" sx={{ bgcolor: 'rgba(16, 185, 129, 0.1)' }}>
                      <Typography variant="body2">
                        <strong>Key Lesson:</strong> {scenario.lesson}
                      </Typography>
                    </Alert>
                  </AccordionDetails>
                </Accordion>
              ))}

              {/* Expanded Glossary */}
              <Typography variant="h5" sx={{ color: "#0ea5e9", mb: 2, mt: 4 }}>
                üìö Comprehensive Glossary
              </Typography>
              <Typography variant="body1" sx={{ color: "grey.400", mb: 3 }}>
                Master these terms to understand network security discussions. Click each term for a detailed explanation.
              </Typography>

              {expandedGlossary.map((item, index) => (
                <Accordion key={index} sx={{ bgcolor: "#0f1422", mb: 1, '&:before': { display: 'none' } }}>
                  <AccordionSummary expandIcon={<ExpandMoreIcon sx={{ color: "grey.400" }} />}>
                    <Box sx={{ display: 'flex', alignItems: 'center', gap: 2, width: '100%' }}>
                      <MenuBookIcon sx={{ color: "#0ea5e9" }} />
                      <Box sx={{ flex: 1 }}>
                        <Typography variant="subtitle1" sx={{ color: "#f59e0b", fontWeight: 600 }}>
                          {item.term}
                        </Typography>
                        <Typography variant="body2" sx={{ color: "grey.400" }}>
                          {item.shortDesc}
                        </Typography>
                      </Box>
                    </Box>
                  </AccordionSummary>
                  <AccordionDetails>
                    <Typography 
                      variant="body2" 
                      sx={{ color: "grey.300", lineHeight: 1.8, whiteSpace: "pre-line" }}
                    >
                      {item.fullExplanation}
                    </Typography>
                  </AccordionDetails>
                </Accordion>
              ))}

              {/* Next Steps */}
              <Paper sx={{ p: 3, mt: 4, bgcolor: "rgba(14, 165, 233, 0.1)", borderRadius: 2, border: "1px solid rgba(14, 165, 233, 0.3)" }}>
                <Typography variant="h6" sx={{ color: "#0ea5e9", mb: 2 }}>
                  ‚úÖ Ready for the Next Step?
                </Typography>
                <Typography variant="body1" sx={{ color: "grey.300", mb: 2 }}>
                  Once you understand these fundamentals, you're ready to explore specific protocols and their vulnerabilities. 
                  Head to the <strong style={{ color: '#f59e0b' }}>Overview</strong> tab for learning objectives, then dive into the 
                  <strong style={{ color: '#f59e0b' }}> Protocol Map</strong> to see how different protocols can be exploited.
                </Typography>
                <Button 
                  variant="contained" 
                  onClick={() => setTabValue(1)}
                  sx={{ bgcolor: "#0ea5e9", '&:hover': { bgcolor: "#0284c7" } }}
                >
                  Continue to Overview ‚Üí
                </Button>
              </Paper>
            </Box>
          </TabPanel>

          <TabPanel value={tabValue} index={1}>
            <Box sx={{ p: 3 }}>
              <Paper sx={{ p: 2.5, mb: 3, bgcolor: "#0f1422", borderRadius: 2 }}>
                <Typography variant="h6" sx={{ color: "#0ea5e9", mb: 1 }}>
                  Learning Objectives
                </Typography>
                <List dense>
                  {objectives.map((item) => (
                    <ListItem key={item}>
                      <ListItemIcon>
                        <CheckCircleIcon color="info" fontSize="small" />
                      </ListItemIcon>
                      <ListItemText primary={item} sx={{ "& .MuiListItemText-primary": { color: "grey.300" } }} />
                    </ListItem>
                  ))}
                </List>
              </Paper>

              <Paper sx={{ p: 2.5, mb: 3, bgcolor: "#0f1422", borderRadius: 2 }}>
                <Typography variant="h6" sx={{ color: "#0ea5e9", mb: 1 }}>
                  Beginner Path
                </Typography>
                <List dense>
                  {beginnerPath.map((item) => (
                    <ListItem key={item}>
                      <ListItemIcon>
                        <CheckCircleIcon color="info" fontSize="small" />
                      </ListItemIcon>
                      <ListItemText primary={item} sx={{ "& .MuiListItemText-primary": { color: "grey.300" } }} />
                    </ListItem>
                  ))}
                </List>
              </Paper>

              <Paper sx={{ p: 2.5, mb: 3, bgcolor: "#0f1422", borderRadius: 2 }}>
                <Typography variant="h6" sx={{ color: "#f59e0b", mb: 1 }}>
                  Quick Glossary
                </Typography>
                <TableContainer>
                  <Table size="small">
                    <TableHead>
                      <TableRow>
                        <TableCell sx={{ color: "#f59e0b" }}>Term</TableCell>
                        <TableCell sx={{ color: "#f59e0b" }}>Meaning</TableCell>
                      </TableRow>
                    </TableHead>
                    <TableBody>
                      {glossary.map((item) => (
                        <TableRow key={item.term}>
                          <TableCell sx={{ color: "grey.200", fontWeight: 600 }}>{item.term}</TableCell>
                          <TableCell sx={{ color: "grey.400" }}>{item.desc}</TableCell>
                        </TableRow>
                      ))}
                    </TableBody>
                  </Table>
                </TableContainer>
              </Paper>

              <Paper sx={{ p: 2.5, bgcolor: "#0f1422", borderRadius: 2 }}>
                <Typography variant="h6" sx={{ color: "#0ea5e9", mb: 1 }}>
                  Where Protocol Exploitation Shows Up
                </Typography>
                <List dense>
                  {scenarios.map((item) => (
                    <ListItem key={item}>
                      <ListItemIcon>
                        <WarningIcon color="warning" fontSize="small" />
                      </ListItemIcon>
                      <ListItemText primary={item} sx={{ "& .MuiListItemText-primary": { color: "grey.300" } }} />
                    </ListItem>
                  ))}
                </List>
              </Paper>
            </Box>
          </TabPanel>

          <TabPanel value={tabValue} index={2}>
            <Box sx={{ p: 3 }}>
              {/* Quick Reference Table */}
              <Typography variant="h5" sx={{ color: "#0ea5e9", mb: 2 }}>
                üìä Protocol Quick Reference
              </Typography>
              <Typography variant="body1" sx={{ color: "grey.400", mb: 3 }}>
                This table provides a quick overview of common protocols, their weaknesses, and defenses. 
                Scroll down for detailed deep-dives into each protocol.
              </Typography>

              <TableContainer sx={{ mb: 4, overflowX: "auto" }}>
                <Table size="small">
                  <TableHead>
                    <TableRow>
                      <TableCell sx={{ color: "#0ea5e9" }}>Protocol</TableCell>
                      <TableCell sx={{ color: "#0ea5e9" }}>Layer</TableCell>
                      <TableCell sx={{ color: "#0ea5e9" }}>Ports</TableCell>
                      <TableCell sx={{ color: "#0ea5e9" }}>Common Weakness</TableCell>
                      <TableCell sx={{ color: "#0ea5e9" }}>Defensive Focus</TableCell>
                      <TableCell sx={{ color: "#0ea5e9" }}>Detection Focus</TableCell>
                    </TableRow>
                  </TableHead>
                  <TableBody>
                    {protocolMap.map((item) => (
                      <TableRow key={item.protocol}>
                        <TableCell sx={{ color: "grey.200", fontWeight: 600 }}>{item.protocol}</TableCell>
                        <TableCell sx={{ color: "grey.400" }}>{item.layer}</TableCell>
                        <TableCell sx={{ color: "grey.400" }}>{item.ports}</TableCell>
                        <TableCell sx={{ color: "grey.400" }}>{item.weakness}</TableCell>
                        <TableCell sx={{ color: "grey.400" }}>{item.defense}</TableCell>
                        <TableCell sx={{ color: "grey.400" }}>{item.detection}</TableCell>
                      </TableRow>
                    ))}
                  </TableBody>
                </Table>
              </TableContainer>

              {/* Protocol Deep Dives */}
              <Divider sx={{ my: 4, borderColor: 'rgba(14, 165, 233, 0.3)' }} />
              
              <Typography variant="h5" sx={{ color: "#f59e0b", mb: 2 }}>
                üî¨ Protocol Deep Dives
              </Typography>
              <Typography variant="body1" sx={{ color: "grey.400", mb: 3 }}>
                Click on each protocol to learn how it works, its security weaknesses, real-world attack examples, 
                and how to defend against exploitation. These explanations are written for beginners but include 
                enough technical detail for practical application.
              </Typography>

              {/* TCP Deep Dive */}
              <Accordion sx={{ bgcolor: "#0f1422", mb: 2, '&:before': { display: 'none' }, borderRadius: 2 }}>
                <AccordionSummary expandIcon={<ExpandMoreIcon sx={{ color: "grey.400" }} />}>
                  <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
                    <RouterIcon sx={{ color: "#0ea5e9", fontSize: 28 }} />
                    <Box>
                      <Typography variant="h6" sx={{ color: "#0ea5e9", fontWeight: 600 }}>
                        TCP - {protocolDeepDives.TCP.fullName}
                      </Typography>
                      <Typography variant="body2" sx={{ color: "grey.500" }}>
                        Layer 4 ‚Ä¢ Reliable delivery ‚Ä¢ The foundation of most internet traffic
                      </Typography>
                    </Box>
                  </Box>
                </AccordionSummary>
                <AccordionDetails>
                  <Box sx={{ p: 1 }}>
                    <Typography variant="subtitle1" sx={{ color: "#10b981", mb: 1, fontWeight: 600 }}>
                      What It Does
                    </Typography>
                    <Typography variant="body2" sx={{ color: "grey.300", mb: 3, lineHeight: 1.8 }}>
                      {protocolDeepDives.TCP.whatItDoes}
                    </Typography>

                    <Typography variant="subtitle1" sx={{ color: "#10b981", mb: 1, fontWeight: 600 }}>
                      How It Works
                    </Typography>
                    <Typography 
                      variant="body2" 
                      sx={{ color: "grey.300", mb: 3, lineHeight: 1.8, whiteSpace: "pre-line" }}
                      dangerouslySetInnerHTML={{ 
                        __html: protocolDeepDives.TCP.howItWorks.replace(/\*\*(.*?)\*\*/g, '<strong style="color: #f59e0b">$1</strong>')
                      }}
                    />

                    <Typography variant="subtitle1" sx={{ color: "#ef4444", mb: 1, fontWeight: 600 }}>
                      üéØ Security Weaknesses
                    </Typography>
                    <List dense>
                      {protocolDeepDives.TCP.securityWeaknesses.map((weakness, idx) => (
                        <ListItem key={idx}>
                          <ListItemIcon><WarningIcon color="error" fontSize="small" /></ListItemIcon>
                          <ListItemText 
                            primary={<span dangerouslySetInnerHTML={{ 
                              __html: weakness.replace(/\*\*(.*?)\*\*/g, '<strong style="color: #f59e0b">$1</strong>')
                            }} />}
                            sx={{ "& .MuiListItemText-primary": { color: "grey.300" } }}
                          />
                        </ListItem>
                      ))}
                    </List>

                    <Typography variant="subtitle1" sx={{ color: "#f59e0b", mb: 1, mt: 2, fontWeight: 600 }}>
                      üî• Real-World Examples
                    </Typography>
                    <List dense>
                      {protocolDeepDives.TCP.realWorldExamples.map((example, idx) => (
                        <ListItem key={idx}>
                          <ListItemIcon><BugReportIcon color="warning" fontSize="small" /></ListItemIcon>
                          <ListItemText 
                            primary={<span dangerouslySetInnerHTML={{ 
                              __html: example.replace(/\*\*(.*?)\*\*/g, '<strong style="color: #0ea5e9">$1</strong>')
                            }} />}
                            sx={{ "& .MuiListItemText-primary": { color: "grey.300" } }}
                          />
                        </ListItem>
                      ))}
                    </List>

                    <Grid container spacing={2} sx={{ mt: 2 }}>
                      <Grid item xs={12} md={6}>
                        <Paper sx={{ p: 2, bgcolor: "rgba(16, 185, 129, 0.1)", borderRadius: 2 }}>
                          <Typography variant="subtitle2" sx={{ color: "#10b981", mb: 1 }}>
                            üõ°Ô∏è Defense Strategies
                          </Typography>
                          <List dense>
                            {protocolDeepDives.TCP.defenseStrategies.map((def, idx) => (
                              <ListItem key={idx} sx={{ py: 0.25 }}>
                                <ListItemIcon><CheckCircleIcon color="success" sx={{ fontSize: 16 }} /></ListItemIcon>
                                <ListItemText primary={def} sx={{ "& .MuiListItemText-primary": { color: "grey.300", fontSize: '0.85rem' } }} />
                              </ListItem>
                            ))}
                          </List>
                        </Paper>
                      </Grid>
                      <Grid item xs={12} md={6}>
                        <Paper sx={{ p: 2, bgcolor: "rgba(14, 165, 233, 0.1)", borderRadius: 2 }}>
                          <Typography variant="subtitle2" sx={{ color: "#0ea5e9", mb: 1 }}>
                            üîç Detection Methods
                          </Typography>
                          <List dense>
                            {protocolDeepDives.TCP.detectionMethods.map((det, idx) => (
                              <ListItem key={idx} sx={{ py: 0.25 }}>
                                <ListItemIcon><SearchIcon color="info" sx={{ fontSize: 16 }} /></ListItemIcon>
                                <ListItemText primary={det} sx={{ "& .MuiListItemText-primary": { color: "grey.300", fontSize: '0.85rem' } }} />
                              </ListItem>
                            ))}
                          </List>
                        </Paper>
                      </Grid>
                    </Grid>
                  </Box>
                </AccordionDetails>
              </Accordion>

              {/* UDP Deep Dive */}
              <Accordion sx={{ bgcolor: "#0f1422", mb: 2, '&:before': { display: 'none' }, borderRadius: 2 }}>
                <AccordionSummary expandIcon={<ExpandMoreIcon sx={{ color: "grey.400" }} />}>
                  <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
                    <NetworkCheckIcon sx={{ color: "#f59e0b", fontSize: 28 }} />
                    <Box>
                      <Typography variant="h6" sx={{ color: "#f59e0b", fontWeight: 600 }}>
                        UDP - {protocolDeepDives.UDP.fullName}
                      </Typography>
                      <Typography variant="body2" sx={{ color: "grey.500" }}>
                        Layer 4 ‚Ä¢ Fast, connectionless ‚Ä¢ Used for DNS, streaming, gaming
                      </Typography>
                    </Box>
                  </Box>
                </AccordionSummary>
                <AccordionDetails>
                  <Box sx={{ p: 1 }}>
                    <Typography variant="subtitle1" sx={{ color: "#10b981", mb: 1, fontWeight: 600 }}>
                      What It Does
                    </Typography>
                    <Typography variant="body2" sx={{ color: "grey.300", mb: 3, lineHeight: 1.8 }}>
                      {protocolDeepDives.UDP.whatItDoes}
                    </Typography>

                    <Typography variant="subtitle1" sx={{ color: "#10b981", mb: 1, fontWeight: 600 }}>
                      How It Works
                    </Typography>
                    <Typography variant="body2" sx={{ color: "grey.300", mb: 3, lineHeight: 1.8, whiteSpace: "pre-line" }}>
                      {protocolDeepDives.UDP.howItWorks}
                    </Typography>

                    <Typography variant="subtitle1" sx={{ color: "#ef4444", mb: 1, fontWeight: 600 }}>
                      üéØ Security Weaknesses
                    </Typography>
                    <List dense>
                      {protocolDeepDives.UDP.securityWeaknesses.map((weakness, idx) => (
                        <ListItem key={idx}>
                          <ListItemIcon><WarningIcon color="error" fontSize="small" /></ListItemIcon>
                          <ListItemText 
                            primary={<span dangerouslySetInnerHTML={{ 
                              __html: weakness.replace(/\*\*(.*?)\*\*/g, '<strong style="color: #f59e0b">$1</strong>')
                            }} />}
                            sx={{ "& .MuiListItemText-primary": { color: "grey.300" } }}
                          />
                        </ListItem>
                      ))}
                    </List>

                    <Typography variant="subtitle1" sx={{ color: "#f59e0b", mb: 1, mt: 2, fontWeight: 600 }}>
                      üî• Real-World Examples
                    </Typography>
                    <List dense>
                      {protocolDeepDives.UDP.realWorldExamples.map((example, idx) => (
                        <ListItem key={idx}>
                          <ListItemIcon><BugReportIcon color="warning" fontSize="small" /></ListItemIcon>
                          <ListItemText 
                            primary={<span dangerouslySetInnerHTML={{ 
                              __html: example.replace(/\*\*(.*?)\*\*/g, '<strong style="color: #0ea5e9">$1</strong>')
                            }} />}
                            sx={{ "& .MuiListItemText-primary": { color: "grey.300" } }}
                          />
                        </ListItem>
                      ))}
                    </List>

                    <Grid container spacing={2} sx={{ mt: 2 }}>
                      <Grid item xs={12} md={6}>
                        <Paper sx={{ p: 2, bgcolor: "rgba(16, 185, 129, 0.1)", borderRadius: 2 }}>
                          <Typography variant="subtitle2" sx={{ color: "#10b981", mb: 1 }}>
                            üõ°Ô∏è Defense Strategies
                          </Typography>
                          <List dense>
                            {protocolDeepDives.UDP.defenseStrategies.map((def, idx) => (
                              <ListItem key={idx} sx={{ py: 0.25 }}>
                                <ListItemIcon><CheckCircleIcon color="success" sx={{ fontSize: 16 }} /></ListItemIcon>
                                <ListItemText primary={def} sx={{ "& .MuiListItemText-primary": { color: "grey.300", fontSize: '0.85rem' } }} />
                              </ListItem>
                            ))}
                          </List>
                        </Paper>
                      </Grid>
                      <Grid item xs={12} md={6}>
                        <Paper sx={{ p: 2, bgcolor: "rgba(14, 165, 233, 0.1)", borderRadius: 2 }}>
                          <Typography variant="subtitle2" sx={{ color: "#0ea5e9", mb: 1 }}>
                            üîç Detection Methods
                          </Typography>
                          <List dense>
                            {protocolDeepDives.UDP.detectionMethods.map((det, idx) => (
                              <ListItem key={idx} sx={{ py: 0.25 }}>
                                <ListItemIcon><SearchIcon color="info" sx={{ fontSize: 16 }} /></ListItemIcon>
                                <ListItemText primary={det} sx={{ "& .MuiListItemText-primary": { color: "grey.300", fontSize: '0.85rem' } }} />
                              </ListItem>
                            ))}
                          </List>
                        </Paper>
                      </Grid>
                    </Grid>
                  </Box>
                </AccordionDetails>
              </Accordion>

              {/* DNS Deep Dive */}
              <Accordion sx={{ bgcolor: "#0f1422", mb: 2, '&:before': { display: 'none' }, borderRadius: 2 }}>
                <AccordionSummary expandIcon={<ExpandMoreIcon sx={{ color: "grey.400" }} />}>
                  <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
                    <DnsIcon sx={{ color: "#10b981", fontSize: 28 }} />
                    <Box>
                      <Typography variant="h6" sx={{ color: "#10b981", fontWeight: 600 }}>
                        DNS - {protocolDeepDives.DNS.fullName}
                      </Typography>
                      <Typography variant="body2" sx={{ color: "grey.500" }}>
                        Layer 7 ‚Ä¢ Port 53 ‚Ä¢ The internet's phone book
                      </Typography>
                    </Box>
                  </Box>
                </AccordionSummary>
                <AccordionDetails>
                  <Box sx={{ p: 1 }}>
                    <Typography variant="subtitle1" sx={{ color: "#10b981", mb: 1, fontWeight: 600 }}>
                      What It Does
                    </Typography>
                    <Typography variant="body2" sx={{ color: "grey.300", mb: 3, lineHeight: 1.8 }}>
                      {protocolDeepDives.DNS.whatItDoes}
                    </Typography>

                    <Typography variant="subtitle1" sx={{ color: "#10b981", mb: 1, fontWeight: 600 }}>
                      How It Works
                    </Typography>
                    <Typography variant="body2" sx={{ color: "grey.300", mb: 3, lineHeight: 1.8, whiteSpace: "pre-line" }}>
                      {protocolDeepDives.DNS.howItWorks}
                    </Typography>

                    <Typography variant="subtitle1" sx={{ color: "#ef4444", mb: 1, fontWeight: 600 }}>
                      üéØ Security Weaknesses
                    </Typography>
                    <List dense>
                      {protocolDeepDives.DNS.securityWeaknesses.map((weakness, idx) => (
                        <ListItem key={idx}>
                          <ListItemIcon><WarningIcon color="error" fontSize="small" /></ListItemIcon>
                          <ListItemText 
                            primary={<span dangerouslySetInnerHTML={{ 
                              __html: weakness.replace(/\*\*(.*?)\*\*/g, '<strong style="color: #f59e0b">$1</strong>')
                            }} />}
                            sx={{ "& .MuiListItemText-primary": { color: "grey.300" } }}
                          />
                        </ListItem>
                      ))}
                    </List>

                    <Typography variant="subtitle1" sx={{ color: "#f59e0b", mb: 1, mt: 2, fontWeight: 600 }}>
                      üî• Real-World Examples
                    </Typography>
                    <List dense>
                      {protocolDeepDives.DNS.realWorldExamples.map((example, idx) => (
                        <ListItem key={idx}>
                          <ListItemIcon><BugReportIcon color="warning" fontSize="small" /></ListItemIcon>
                          <ListItemText 
                            primary={<span dangerouslySetInnerHTML={{ 
                              __html: example.replace(/\*\*(.*?)\*\*/g, '<strong style="color: #0ea5e9">$1</strong>')
                            }} />}
                            sx={{ "& .MuiListItemText-primary": { color: "grey.300" } }}
                          />
                        </ListItem>
                      ))}
                    </List>

                    <Grid container spacing={2} sx={{ mt: 2 }}>
                      <Grid item xs={12} md={6}>
                        <Paper sx={{ p: 2, bgcolor: "rgba(16, 185, 129, 0.1)", borderRadius: 2 }}>
                          <Typography variant="subtitle2" sx={{ color: "#10b981", mb: 1 }}>
                            üõ°Ô∏è Defense Strategies
                          </Typography>
                          <List dense>
                            {protocolDeepDives.DNS.defenseStrategies.map((def, idx) => (
                              <ListItem key={idx} sx={{ py: 0.25 }}>
                                <ListItemIcon><CheckCircleIcon color="success" sx={{ fontSize: 16 }} /></ListItemIcon>
                                <ListItemText primary={def} sx={{ "& .MuiListItemText-primary": { color: "grey.300", fontSize: '0.85rem' } }} />
                              </ListItem>
                            ))}
                          </List>
                        </Paper>
                      </Grid>
                      <Grid item xs={12} md={6}>
                        <Paper sx={{ p: 2, bgcolor: "rgba(14, 165, 233, 0.1)", borderRadius: 2 }}>
                          <Typography variant="subtitle2" sx={{ color: "#0ea5e9", mb: 1 }}>
                            üîç Detection Methods
                          </Typography>
                          <List dense>
                            {protocolDeepDives.DNS.detectionMethods.map((det, idx) => (
                              <ListItem key={idx} sx={{ py: 0.25 }}>
                                <ListItemIcon><SearchIcon color="info" sx={{ fontSize: 16 }} /></ListItemIcon>
                                <ListItemText primary={det} sx={{ "& .MuiListItemText-primary": { color: "grey.300", fontSize: '0.85rem' } }} />
                              </ListItem>
                            ))}
                          </List>
                        </Paper>
                      </Grid>
                    </Grid>
                  </Box>
                </AccordionDetails>
              </Accordion>

              {/* TLS Deep Dive */}
              <Accordion sx={{ bgcolor: "#0f1422", mb: 2, '&:before': { display: 'none' }, borderRadius: 2 }}>
                <AccordionSummary expandIcon={<ExpandMoreIcon sx={{ color: "grey.400" }} />}>
                  <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
                    <VpnKeyIcon sx={{ color: "#a855f7", fontSize: 28 }} />
                    <Box>
                      <Typography variant="h6" sx={{ color: "#a855f7", fontWeight: 600 }}>
                        TLS - {protocolDeepDives.TLS.fullName}
                      </Typography>
                      <Typography variant="body2" sx={{ color: "grey.500" }}>
                        Layer 7 ‚Ä¢ Ports 443, 465, 993 ‚Ä¢ Encryption for the web
                      </Typography>
                    </Box>
                  </Box>
                </AccordionSummary>
                <AccordionDetails>
                  <Box sx={{ p: 1 }}>
                    <Typography variant="subtitle1" sx={{ color: "#10b981", mb: 1, fontWeight: 600 }}>
                      What It Does
                    </Typography>
                    <Typography variant="body2" sx={{ color: "grey.300", mb: 3, lineHeight: 1.8 }}>
                      {protocolDeepDives.TLS.whatItDoes}
                    </Typography>

                    <Typography variant="subtitle1" sx={{ color: "#10b981", mb: 1, fontWeight: 600 }}>
                      How It Works
                    </Typography>
                    <Typography 
                      variant="body2" 
                      sx={{ color: "grey.300", mb: 3, lineHeight: 1.8, whiteSpace: "pre-line" }}
                      dangerouslySetInnerHTML={{ 
                        __html: protocolDeepDives.TLS.howItWorks.replace(/\*\*(.*?)\*\*/g, '<strong style="color: #f59e0b">$1</strong>')
                      }}
                    />

                    <Typography variant="subtitle1" sx={{ color: "#ef4444", mb: 1, fontWeight: 600 }}>
                      üéØ Security Weaknesses
                    </Typography>
                    <List dense>
                      {protocolDeepDives.TLS.securityWeaknesses.map((weakness, idx) => (
                        <ListItem key={idx}>
                          <ListItemIcon><WarningIcon color="error" fontSize="small" /></ListItemIcon>
                          <ListItemText 
                            primary={<span dangerouslySetInnerHTML={{ 
                              __html: weakness.replace(/\*\*(.*?)\*\*/g, '<strong style="color: #f59e0b">$1</strong>')
                            }} />}
                            sx={{ "& .MuiListItemText-primary": { color: "grey.300" } }}
                          />
                        </ListItem>
                      ))}
                    </List>

                    <Typography variant="subtitle1" sx={{ color: "#f59e0b", mb: 1, mt: 2, fontWeight: 600 }}>
                      üî• Real-World Examples
                    </Typography>
                    <List dense>
                      {protocolDeepDives.TLS.realWorldExamples.map((example, idx) => (
                        <ListItem key={idx}>
                          <ListItemIcon><BugReportIcon color="warning" fontSize="small" /></ListItemIcon>
                          <ListItemText 
                            primary={<span dangerouslySetInnerHTML={{ 
                              __html: example.replace(/\*\*(.*?)\*\*/g, '<strong style="color: #0ea5e9">$1</strong>')
                            }} />}
                            sx={{ "& .MuiListItemText-primary": { color: "grey.300" } }}
                          />
                        </ListItem>
                      ))}
                    </List>

                    <Grid container spacing={2} sx={{ mt: 2 }}>
                      <Grid item xs={12} md={6}>
                        <Paper sx={{ p: 2, bgcolor: "rgba(16, 185, 129, 0.1)", borderRadius: 2 }}>
                          <Typography variant="subtitle2" sx={{ color: "#10b981", mb: 1 }}>
                            üõ°Ô∏è Defense Strategies
                          </Typography>
                          <List dense>
                            {protocolDeepDives.TLS.defenseStrategies.map((def, idx) => (
                              <ListItem key={idx} sx={{ py: 0.25 }}>
                                <ListItemIcon><CheckCircleIcon color="success" sx={{ fontSize: 16 }} /></ListItemIcon>
                                <ListItemText primary={def} sx={{ "& .MuiListItemText-primary": { color: "grey.300", fontSize: '0.85rem' } }} />
                              </ListItem>
                            ))}
                          </List>
                        </Paper>
                      </Grid>
                      <Grid item xs={12} md={6}>
                        <Paper sx={{ p: 2, bgcolor: "rgba(14, 165, 233, 0.1)", borderRadius: 2 }}>
                          <Typography variant="subtitle2" sx={{ color: "#0ea5e9", mb: 1 }}>
                            üîç Detection Methods
                          </Typography>
                          <List dense>
                            {protocolDeepDives.TLS.detectionMethods.map((det, idx) => (
                              <ListItem key={idx} sx={{ py: 0.25 }}>
                                <ListItemIcon><SearchIcon color="info" sx={{ fontSize: 16 }} /></ListItemIcon>
                                <ListItemText primary={det} sx={{ "& .MuiListItemText-primary": { color: "grey.300", fontSize: '0.85rem' } }} />
                              </ListItem>
                            ))}
                          </List>
                        </Paper>
                      </Grid>
                    </Grid>
                  </Box>
                </AccordionDetails>
              </Accordion>

              {/* SMB Deep Dive */}
              <Accordion sx={{ bgcolor: "#0f1422", mb: 2, '&:before': { display: 'none' }, borderRadius: 2 }}>
                <AccordionSummary expandIcon={<ExpandMoreIcon sx={{ color: "grey.400" }} />}>
                  <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
                    <StorageIcon sx={{ color: "#ef4444", fontSize: 28 }} />
                    <Box>
                      <Typography variant="h6" sx={{ color: "#ef4444", fontWeight: 600 }}>
                        SMB - {protocolDeepDives.SMB.fullName}
                      </Typography>
                      <Typography variant="body2" sx={{ color: "grey.500" }}>
                        Layer 7 ‚Ä¢ Port 445 ‚Ä¢ Windows file sharing
                      </Typography>
                    </Box>
                  </Box>
                </AccordionSummary>
                <AccordionDetails>
                  <Box sx={{ p: 1 }}>
                    <Typography variant="subtitle1" sx={{ color: "#10b981", mb: 1, fontWeight: 600 }}>
                      What It Does
                    </Typography>
                    <Typography variant="body2" sx={{ color: "grey.300", mb: 3, lineHeight: 1.8 }}>
                      {protocolDeepDives.SMB.whatItDoes}
                    </Typography>

                    <Typography variant="subtitle1" sx={{ color: "#10b981", mb: 1, fontWeight: 600 }}>
                      How It Works
                    </Typography>
                    <Typography variant="body2" sx={{ color: "grey.300", mb: 3, lineHeight: 1.8, whiteSpace: "pre-line" }}>
                      {protocolDeepDives.SMB.howItWorks}
                    </Typography>

                    <Alert severity="error" sx={{ mb: 2, bgcolor: 'rgba(239, 68, 68, 0.1)' }}>
                      <Typography variant="body2">
                        <strong>‚ö†Ô∏è SMBv1 Warning:</strong> SMBv1 is dangerously insecure and was exploited by WannaCry 
                        and NotPetya ransomware. It should be disabled on ALL systems.
                      </Typography>
                    </Alert>

                    <Typography variant="subtitle1" sx={{ color: "#ef4444", mb: 1, fontWeight: 600 }}>
                      üéØ Security Weaknesses
                    </Typography>
                    <List dense>
                      {protocolDeepDives.SMB.securityWeaknesses.map((weakness, idx) => (
                        <ListItem key={idx}>
                          <ListItemIcon><WarningIcon color="error" fontSize="small" /></ListItemIcon>
                          <ListItemText 
                            primary={<span dangerouslySetInnerHTML={{ 
                              __html: weakness.replace(/\*\*(.*?)\*\*/g, '<strong style="color: #f59e0b">$1</strong>')
                            }} />}
                            sx={{ "& .MuiListItemText-primary": { color: "grey.300" } }}
                          />
                        </ListItem>
                      ))}
                    </List>

                    <Typography variant="subtitle1" sx={{ color: "#f59e0b", mb: 1, mt: 2, fontWeight: 600 }}>
                      üî• Real-World Examples
                    </Typography>
                    <List dense>
                      {protocolDeepDives.SMB.realWorldExamples.map((example, idx) => (
                        <ListItem key={idx}>
                          <ListItemIcon><BugReportIcon color="warning" fontSize="small" /></ListItemIcon>
                          <ListItemText 
                            primary={<span dangerouslySetInnerHTML={{ 
                              __html: example.replace(/\*\*(.*?)\*\*/g, '<strong style="color: #0ea5e9">$1</strong>')
                            }} />}
                            sx={{ "& .MuiListItemText-primary": { color: "grey.300" } }}
                          />
                        </ListItem>
                      ))}
                    </List>

                    <Grid container spacing={2} sx={{ mt: 2 }}>
                      <Grid item xs={12} md={6}>
                        <Paper sx={{ p: 2, bgcolor: "rgba(16, 185, 129, 0.1)", borderRadius: 2 }}>
                          <Typography variant="subtitle2" sx={{ color: "#10b981", mb: 1 }}>
                            üõ°Ô∏è Defense Strategies
                          </Typography>
                          <List dense>
                            {protocolDeepDives.SMB.defenseStrategies.map((def, idx) => (
                              <ListItem key={idx} sx={{ py: 0.25 }}>
                                <ListItemIcon><CheckCircleIcon color="success" sx={{ fontSize: 16 }} /></ListItemIcon>
                                <ListItemText primary={def} sx={{ "& .MuiListItemText-primary": { color: "grey.300", fontSize: '0.85rem' } }} />
                              </ListItem>
                            ))}
                          </List>
                        </Paper>
                      </Grid>
                      <Grid item xs={12} md={6}>
                        <Paper sx={{ p: 2, bgcolor: "rgba(14, 165, 233, 0.1)", borderRadius: 2 }}>
                          <Typography variant="subtitle2" sx={{ color: "#0ea5e9", mb: 1 }}>
                            üîç Detection Methods
                          </Typography>
                          <List dense>
                            {protocolDeepDives.SMB.detectionMethods.map((det, idx) => (
                              <ListItem key={idx} sx={{ py: 0.25 }}>
                                <ListItemIcon><SearchIcon color="info" sx={{ fontSize: 16 }} /></ListItemIcon>
                                <ListItemText primary={det} sx={{ "& .MuiListItemText-primary": { color: "grey.300", fontSize: '0.85rem' } }} />
                              </ListItem>
                            ))}
                          </List>
                        </Paper>
                      </Grid>
                    </Grid>
                  </Box>
                </AccordionDetails>
              </Accordion>

              {/* SSH Deep Dive */}
              <Accordion sx={{ bgcolor: "#0f1422", mb: 2, '&:before': { display: 'none' }, borderRadius: 2 }}>
                <AccordionSummary expandIcon={<ExpandMoreIcon sx={{ color: "grey.400" }} />}>
                  <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
                    <SecurityIcon sx={{ color: "#22c55e", fontSize: 28 }} />
                    <Box>
                      <Typography variant="h6" sx={{ color: "#22c55e", fontWeight: 600 }}>
                        SSH - {protocolDeepDives.SSH.fullName}
                      </Typography>
                      <Typography variant="body2" sx={{ color: "grey.500" }}>
                        Layer 7 ‚Ä¢ Port 22 ‚Ä¢ Secure remote access
                      </Typography>
                    </Box>
                  </Box>
                </AccordionSummary>
                <AccordionDetails>
                  <Box sx={{ p: 1 }}>
                    <Typography variant="subtitle1" sx={{ color: "#10b981", mb: 1, fontWeight: 600 }}>
                      What It Does
                    </Typography>
                    <Typography variant="body2" sx={{ color: "grey.300", mb: 3, lineHeight: 1.8 }}>
                      {protocolDeepDives.SSH.whatItDoes}
                    </Typography>

                    <Typography variant="subtitle1" sx={{ color: "#10b981", mb: 1, fontWeight: 600 }}>
                      How It Works
                    </Typography>
                    <Typography variant="body2" sx={{ color: "grey.300", mb: 3, lineHeight: 1.8, whiteSpace: "pre-line" }}>
                      {protocolDeepDives.SSH.howItWorks}
                    </Typography>

                    <Typography variant="subtitle1" sx={{ color: "#ef4444", mb: 1, fontWeight: 600 }}>
                      üéØ Security Weaknesses
                    </Typography>
                    <List dense>
                      {protocolDeepDives.SSH.securityWeaknesses.map((weakness, idx) => (
                        <ListItem key={idx}>
                          <ListItemIcon><WarningIcon color="error" fontSize="small" /></ListItemIcon>
                          <ListItemText 
                            primary={<span dangerouslySetInnerHTML={{ 
                              __html: weakness.replace(/\*\*(.*?)\*\*/g, '<strong style="color: #f59e0b">$1</strong>')
                            }} />}
                            sx={{ "& .MuiListItemText-primary": { color: "grey.300" } }}
                          />
                        </ListItem>
                      ))}
                    </List>

                    <Typography variant="subtitle1" sx={{ color: "#f59e0b", mb: 1, mt: 2, fontWeight: 600 }}>
                      üî• Real-World Examples
                    </Typography>
                    <List dense>
                      {protocolDeepDives.SSH.realWorldExamples.map((example, idx) => (
                        <ListItem key={idx}>
                          <ListItemIcon><BugReportIcon color="warning" fontSize="small" /></ListItemIcon>
                          <ListItemText 
                            primary={<span dangerouslySetInnerHTML={{ 
                              __html: example.replace(/\*\*(.*?)\*\*/g, '<strong style="color: #0ea5e9">$1</strong>')
                            }} />}
                            sx={{ "& .MuiListItemText-primary": { color: "grey.300" } }}
                          />
                        </ListItem>
                      ))}
                    </List>

                    <Grid container spacing={2} sx={{ mt: 2 }}>
                      <Grid item xs={12} md={6}>
                        <Paper sx={{ p: 2, bgcolor: "rgba(16, 185, 129, 0.1)", borderRadius: 2 }}>
                          <Typography variant="subtitle2" sx={{ color: "#10b981", mb: 1 }}>
                            üõ°Ô∏è Defense Strategies
                          </Typography>
                          <List dense>
                            {protocolDeepDives.SSH.defenseStrategies.map((def, idx) => (
                              <ListItem key={idx} sx={{ py: 0.25 }}>
                                <ListItemIcon><CheckCircleIcon color="success" sx={{ fontSize: 16 }} /></ListItemIcon>
                                <ListItemText primary={def} sx={{ "& .MuiListItemText-primary": { color: "grey.300", fontSize: '0.85rem' } }} />
                              </ListItem>
                            ))}
                          </List>
                        </Paper>
                      </Grid>
                      <Grid item xs={12} md={6}>
                        <Paper sx={{ p: 2, bgcolor: "rgba(14, 165, 233, 0.1)", borderRadius: 2 }}>
                          <Typography variant="subtitle2" sx={{ color: "#0ea5e9", mb: 1 }}>
                            üîç Detection Methods
                          </Typography>
                          <List dense>
                            {protocolDeepDives.SSH.detectionMethods.map((det, idx) => (
                              <ListItem key={idx} sx={{ py: 0.25 }}>
                                <ListItemIcon><SearchIcon color="info" sx={{ fontSize: 16 }} /></ListItemIcon>
                                <ListItemText primary={det} sx={{ "& .MuiListItemText-primary": { color: "grey.300", fontSize: '0.85rem' } }} />
                              </ListItem>
                            ))}
                          </List>
                        </Paper>
                      </Grid>
                    </Grid>
                  </Box>
                </AccordionDetails>
              </Accordion>

              {/* Kerberos Deep Dive */}
              <Accordion sx={{ bgcolor: "#0f1422", mb: 2, '&:before': { display: 'none' }, borderRadius: 2 }}>
                <AccordionSummary expandIcon={<ExpandMoreIcon sx={{ color: "grey.400" }} />}>
                  <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
                    <VpnKeyIcon sx={{ color: "#eab308", fontSize: 28 }} />
                    <Box>
                      <Typography variant="h6" sx={{ color: "#eab308", fontWeight: 600 }}>
                        Kerberos - {protocolDeepDives.Kerberos.fullName}
                      </Typography>
                      <Typography variant="body2" sx={{ color: "grey.500" }}>
                        Layer 7 ‚Ä¢ Port 88 ‚Ä¢ Active Directory authentication
                      </Typography>
                    </Box>
                  </Box>
                </AccordionSummary>
                <AccordionDetails>
                  <Box sx={{ p: 1 }}>
                    <Typography variant="subtitle1" sx={{ color: "#10b981", mb: 1, fontWeight: 600 }}>
                      What It Does
                    </Typography>
                    <Typography variant="body2" sx={{ color: "grey.300", mb: 3, lineHeight: 1.8 }}>
                      {protocolDeepDives.Kerberos.whatItDoes}
                    </Typography>

                    <Typography variant="subtitle1" sx={{ color: "#10b981", mb: 1, fontWeight: 600 }}>
                      How It Works
                    </Typography>
                    <Typography variant="body2" sx={{ color: "grey.300", mb: 3, lineHeight: 1.8, whiteSpace: "pre-line" }}>
                      {protocolDeepDives.Kerberos.howItWorks}
                    </Typography>

                    <Typography variant="subtitle1" sx={{ color: "#ef4444", mb: 1, fontWeight: 600 }}>
                      üéØ Security Weaknesses
                    </Typography>
                    <List dense>
                      {protocolDeepDives.Kerberos.securityWeaknesses.map((weakness, idx) => (
                        <ListItem key={idx}>
                          <ListItemIcon><WarningIcon color="error" fontSize="small" /></ListItemIcon>
                          <ListItemText 
                            primary={<span dangerouslySetInnerHTML={{ 
                              __html: weakness.replace(/\*\*(.*?)\*\*/g, '<strong style="color: #f59e0b">$1</strong>')
                            }} />}
                            sx={{ "& .MuiListItemText-primary": { color: "grey.300" } }}
                          />
                        </ListItem>
                      ))}
                    </List>

                    <Typography variant="subtitle1" sx={{ color: "#f59e0b", mb: 1, mt: 2, fontWeight: 600 }}>
                      üî• Real-World Examples
                    </Typography>
                    <List dense>
                      {protocolDeepDives.Kerberos.realWorldExamples.map((example, idx) => (
                        <ListItem key={idx}>
                          <ListItemIcon><BugReportIcon color="warning" fontSize="small" /></ListItemIcon>
                          <ListItemText 
                            primary={<span dangerouslySetInnerHTML={{ 
                              __html: example.replace(/\*\*(.*?)\*\*/g, '<strong style="color: #0ea5e9">$1</strong>')
                            }} />}
                            sx={{ "& .MuiListItemText-primary": { color: "grey.300" } }}
                          />
                        </ListItem>
                      ))}
                    </List>

                    <Grid container spacing={2} sx={{ mt: 2 }}>
                      <Grid item xs={12} md={6}>
                        <Paper sx={{ p: 2, bgcolor: "rgba(16, 185, 129, 0.1)", borderRadius: 2 }}>
                          <Typography variant="subtitle2" sx={{ color: "#10b981", mb: 1 }}>
                            üõ°Ô∏è Defense Strategies
                          </Typography>
                          <List dense>
                            {protocolDeepDives.Kerberos.defenseStrategies.map((def, idx) => (
                              <ListItem key={idx} sx={{ py: 0.25 }}>
                                <ListItemIcon><CheckCircleIcon color="success" sx={{ fontSize: 16 }} /></ListItemIcon>
                                <ListItemText primary={def} sx={{ "& .MuiListItemText-primary": { color: "grey.300", fontSize: '0.85rem' } }} />
                              </ListItem>
                            ))}
                          </List>
                        </Paper>
                      </Grid>
                      <Grid item xs={12} md={6}>
                        <Paper sx={{ p: 2, bgcolor: "rgba(14, 165, 233, 0.1)", borderRadius: 2 }}>
                          <Typography variant="subtitle2" sx={{ color: "#0ea5e9", mb: 1 }}>
                            üîç Detection Methods
                          </Typography>
                          <List dense>
                            {protocolDeepDives.Kerberos.detectionMethods.map((det, idx) => (
                              <ListItem key={idx} sx={{ py: 0.25 }}>
                                <ListItemIcon><SearchIcon color="info" sx={{ fontSize: 16 }} /></ListItemIcon>
                                <ListItemText primary={det} sx={{ "& .MuiListItemText-primary": { color: "grey.300", fontSize: '0.85rem' } }} />
                              </ListItem>
                            ))}
                          </List>
                        </Paper>
                      </Grid>
                    </Grid>
                  </Box>
                </AccordionDetails>
              </Accordion>

              {/* HTTP Deep Dive */}
              <Accordion sx={{ bgcolor: "#0f1422", mb: 2, '&:before': { display: 'none' }, borderRadius: 2 }}>
                <AccordionSummary expandIcon={<ExpandMoreIcon sx={{ color: "grey.400" }} />}>
                  <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
                    <HttpIcon sx={{ color: "#06b6d4", fontSize: 28 }} />
                    <Box>
                      <Typography variant="h6" sx={{ color: "#06b6d4", fontWeight: 600 }}>
                        HTTP - {protocolDeepDives.HTTP.fullName}
                      </Typography>
                      <Typography variant="body2" sx={{ color: "grey.500" }}>
                        Layer 7 ‚Ä¢ Ports 80/443 ‚Ä¢ Web communication protocol
                      </Typography>
                    </Box>
                  </Box>
                </AccordionSummary>
                <AccordionDetails>
                  <Box sx={{ p: 1 }}>
                    <Typography variant="subtitle1" sx={{ color: "#10b981", mb: 1, fontWeight: 600 }}>
                      What It Does
                    </Typography>
                    <Typography variant="body2" sx={{ color: "grey.300", mb: 3, lineHeight: 1.8 }}>
                      {protocolDeepDives.HTTP.whatItDoes}
                    </Typography>

                    <Typography variant="subtitle1" sx={{ color: "#10b981", mb: 1, fontWeight: 600 }}>
                      How It Works
                    </Typography>
                    <CodeBlock code={protocolDeepDives.HTTP.howItWorks} language="http" />

                    <Typography variant="subtitle1" sx={{ color: "#ef4444", mb: 1, mt: 2, fontWeight: 600 }}>
                      üéØ Security Weaknesses
                    </Typography>
                    <List dense>
                      {protocolDeepDives.HTTP.securityWeaknesses.map((weakness, idx) => (
                        <ListItem key={idx}>
                          <ListItemIcon><WarningIcon color="error" fontSize="small" /></ListItemIcon>
                          <ListItemText 
                            primary={<span dangerouslySetInnerHTML={{ 
                              __html: weakness.replace(/\*\*(.*?)\*\*/g, '<strong style="color: #f59e0b">$1</strong>')
                            }} />}
                            sx={{ "& .MuiListItemText-primary": { color: "grey.300" } }}
                          />
                        </ListItem>
                      ))}
                    </List>

                    <Typography variant="subtitle1" sx={{ color: "#f59e0b", mb: 1, mt: 2, fontWeight: 600 }}>
                      üî• Real-World Examples
                    </Typography>
                    <List dense>
                      {protocolDeepDives.HTTP.realWorldExamples.map((example, idx) => (
                        <ListItem key={idx}>
                          <ListItemIcon><BugReportIcon color="warning" fontSize="small" /></ListItemIcon>
                          <ListItemText 
                            primary={<span dangerouslySetInnerHTML={{ 
                              __html: example.replace(/\*\*(.*?)\*\*/g, '<strong style="color: #0ea5e9">$1</strong>')
                            }} />}
                            sx={{ "& .MuiListItemText-primary": { color: "grey.300" } }}
                          />
                        </ListItem>
                      ))}
                    </List>

                    <Grid container spacing={2} sx={{ mt: 2 }}>
                      <Grid item xs={12} md={6}>
                        <Paper sx={{ p: 2, bgcolor: "rgba(16, 185, 129, 0.1)", borderRadius: 2 }}>
                          <Typography variant="subtitle2" sx={{ color: "#10b981", mb: 1 }}>
                            üõ°Ô∏è Defense Strategies
                          </Typography>
                          <List dense>
                            {protocolDeepDives.HTTP.defenseStrategies.map((def, idx) => (
                              <ListItem key={idx} sx={{ py: 0.25 }}>
                                <ListItemIcon><CheckCircleIcon color="success" sx={{ fontSize: 16 }} /></ListItemIcon>
                                <ListItemText primary={def} sx={{ "& .MuiListItemText-primary": { color: "grey.300", fontSize: '0.85rem' } }} />
                              </ListItem>
                            ))}
                          </List>
                        </Paper>
                      </Grid>
                      <Grid item xs={12} md={6}>
                        <Paper sx={{ p: 2, bgcolor: "rgba(14, 165, 233, 0.1)", borderRadius: 2 }}>
                          <Typography variant="subtitle2" sx={{ color: "#0ea5e9", mb: 1 }}>
                            üîç Detection Methods
                          </Typography>
                          <List dense>
                            {protocolDeepDives.HTTP.detectionMethods.map((det, idx) => (
                              <ListItem key={idx} sx={{ py: 0.25 }}>
                                <ListItemIcon><SearchIcon color="info" sx={{ fontSize: 16 }} /></ListItemIcon>
                                <ListItemText primary={det} sx={{ "& .MuiListItemText-primary": { color: "grey.300", fontSize: '0.85rem' } }} />
                              </ListItem>
                            ))}
                          </List>
                        </Paper>
                      </Grid>
                    </Grid>
                  </Box>
                </AccordionDetails>
              </Accordion>

              <Divider sx={{ my: 4, borderColor: 'rgba(14, 165, 233, 0.3)' }} />

              {/* Exposure Checklist */}
              <Paper sx={{ p: 2.5, bgcolor: "#0f1422", borderRadius: 2 }}>
                <Typography variant="h6" sx={{ color: "#0ea5e9", mb: 1 }}>
                  ‚úÖ Exposure Checklist
                </Typography>
                <Typography variant="body2" sx={{ color: "grey.400", mb: 2 }}>
                  Use this checklist to evaluate your organization's protocol exposure:
                </Typography>
                <List dense>
                  {exposureChecklist.map((item) => (
                    <ListItem key={item}>
                      <ListItemIcon>
                        <CheckCircleIcon color="info" fontSize="small" />
                      </ListItemIcon>
                      <ListItemText primary={item} sx={{ "& .MuiListItemText-primary": { color: "grey.300" } }} />
                    </ListItem>
                  ))}
                </List>
              </Paper>
            </Box>
          </TabPanel>

          <TabPanel value={tabValue} index={3}>
            <Box sx={{ p: 3 }}>
              {/* Introduction */}
              <Alert severity="warning" sx={{ mb: 3, bgcolor: 'rgba(245, 158, 11, 0.1)', '& .MuiAlert-icon': { color: '#f59e0b' } }}>
                <Typography variant="body2" sx={{ color: '#fbbf24' }}>
                  <strong>Understanding Exploitation Patterns:</strong> Attackers follow predictable patterns when exploiting network protocols. 
                  Learning these patterns helps you defend against them and recognize attacks in progress.
                </Typography>
              </Alert>

              {/* Quick Reference Cards */}
              <Typography variant="h5" sx={{ color: '#f59e0b', mb: 2, fontWeight: 600 }}>
                üéØ Quick Pattern Reference
              </Typography>
              <Grid container spacing={2} sx={{ mb: 4 }}>
                {exploitationPatterns.map((item) => (
                  <Grid item xs={12} md={6} key={item.title}>
                    <Paper
                      sx={{
                        p: 2,
                        bgcolor: "#0f1422",
                        borderRadius: 2,
                        border: "1px solid rgba(245, 158, 11, 0.2)",
                        height: "100%",
                      }}
                    >
                      <Typography variant="subtitle1" sx={{ color: "#e2e8f0", fontWeight: 600 }}>
                        {item.title}
                      </Typography>
                      <Typography variant="body2" sx={{ color: "grey.400", mb: 1 }}>
                        {item.desc}
                      </Typography>
                      <Typography variant="caption" sx={{ color: "#f59e0b", display: "block" }}>
                        Impact: {item.impact}
                      </Typography>
                      <Typography variant="caption" sx={{ color: "#fbbf24", display: "block" }}>
                        Signals: {item.signals}
                      </Typography>
                      <Typography variant="caption" sx={{ color: "#94a3b8", display: "block" }}>
                        Defense: {item.defense}
                      </Typography>
                    </Paper>
                  </Grid>
                ))}
              </Grid>

              {/* Deep Dive Accordions */}
              <Typography variant="h5" sx={{ color: '#f59e0b', mb: 2, fontWeight: 600, display: 'flex', alignItems: 'center', gap: 1 }}>
                üìö Deep Dive: Attack Patterns Explained
              </Typography>
              <Typography variant="body2" sx={{ color: 'grey.400', mb: 3 }}>
                Click on each pattern to see detailed explanations, technical details, and real-world examples.
              </Typography>

              {/* State Exhaustion Deep Dive */}
              <Accordion 
                sx={{ 
                  bgcolor: '#0f1422', 
                  mb: 2, 
                  border: '1px solid rgba(220, 38, 38, 0.3)',
                  '&:before': { display: 'none' }
                }}
              >
                <AccordionSummary expandIcon={<ExpandMoreIcon sx={{ color: '#dc2626' }} />}>
                  <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
                    <Typography variant="h4" component="span">{exploitationPatternsDetailed.stateExhaustion.icon}</Typography>
                    <Box>
                      <Typography sx={{ color: '#dc2626', fontWeight: 600 }}>{exploitationPatternsDetailed.stateExhaustion.title}</Typography>
                      <Typography variant="body2" sx={{ color: 'grey.400' }}>{exploitationPatternsDetailed.stateExhaustion.summary}</Typography>
                    </Box>
                  </Box>
                </AccordionSummary>
                <AccordionDetails>
                  <Grid container spacing={3}>
                    <Grid item xs={12} md={6}>
                      <Typography variant="h6" sx={{ color: '#f87171', mb: 1 }}>Understanding the Attack</Typography>
                      <Typography variant="body2" sx={{ color: 'grey.300', whiteSpace: 'pre-line', lineHeight: 1.8 }}>
                        {exploitationPatternsDetailed.stateExhaustion.deepExplanation}
                      </Typography>
                    </Grid>
                    <Grid item xs={12} md={6}>
                      <Typography variant="h6" sx={{ color: '#f87171', mb: 1 }}>Technical Details</Typography>
                      <Paper sx={{ p: 2, bgcolor: '#1a1f2e', mb: 2 }}>
                        <Typography variant="body2" sx={{ color: 'grey.300', whiteSpace: 'pre-line', fontFamily: 'monospace', fontSize: '0.8rem' }}>
                          {exploitationPatternsDetailed.stateExhaustion.technicalDetails}
                        </Typography>
                      </Paper>
                      
                      <Typography variant="h6" sx={{ color: '#f87171', mb: 1 }}>Detection Signals</Typography>
                      <List dense>
                        {exploitationPatternsDetailed.stateExhaustion.detectionSignals.map((signal, idx) => (
                          <ListItem key={idx} sx={{ py: 0.25 }}>
                            <ListItemIcon sx={{ minWidth: 28 }}><WarningIcon sx={{ color: '#f59e0b', fontSize: 16 }} /></ListItemIcon>
                            <ListItemText primary={signal} sx={{ '& .MuiListItemText-primary': { color: 'grey.300', fontSize: '0.85rem' } }} />
                          </ListItem>
                        ))}
                      </List>
                    </Grid>
                    <Grid item xs={12}>
                      <Typography variant="h6" sx={{ color: '#f87171', mb: 1 }}>Real-World Examples</Typography>
                      <Grid container spacing={2}>
                        {exploitationPatternsDetailed.stateExhaustion.realExamples.map((example, idx) => (
                          <Grid item xs={12} md={6} key={idx}>
                            <Paper sx={{ p: 2, bgcolor: '#1a1f2e', border: '1px solid rgba(239, 68, 68, 0.2)' }}>
                              <Typography variant="subtitle2" sx={{ color: '#fca5a5', fontWeight: 600 }}>{example.name}</Typography>
                              <Typography variant="body2" sx={{ color: 'grey.400', mb: 1 }}>{example.description}</Typography>
                              <Typography variant="caption" sx={{ color: '#22c55e' }}>Outcome: {example.outcome}</Typography>
                            </Paper>
                          </Grid>
                        ))}
                      </Grid>
                    </Grid>
                    <Grid item xs={12}>
                      <Typography variant="h6" sx={{ color: '#22c55e', mb: 1 }}>Defense Strategies</Typography>
                      <Grid container spacing={1}>
                        {exploitationPatternsDetailed.stateExhaustion.defenseStrategies.map((defense, idx) => (
                          <Grid item xs={12} md={6} key={idx}>
                            <Paper sx={{ p: 1.5, bgcolor: '#0a2e1a' }}>
                              <Typography variant="body2" sx={{ color: '#4ade80', fontWeight: 600 }}>{defense.strategy}</Typography>
                              <Typography variant="caption" sx={{ color: 'grey.400', fontFamily: 'monospace' }}>{defense.command}</Typography>
                            </Paper>
                          </Grid>
                        ))}
                      </Grid>
                    </Grid>
                  </Grid>
                </AccordionDetails>
              </Accordion>

              {/* Amplification Deep Dive */}
              <Accordion 
                sx={{ 
                  bgcolor: '#0f1422', 
                  mb: 2, 
                  border: '1px solid rgba(168, 85, 247, 0.3)',
                  '&:before': { display: 'none' }
                }}
              >
                <AccordionSummary expandIcon={<ExpandMoreIcon sx={{ color: '#a855f7' }} />}>
                  <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
                    <Typography variant="h4" component="span">{exploitationPatternsDetailed.amplificationReflection.icon}</Typography>
                    <Box>
                      <Typography sx={{ color: '#a855f7', fontWeight: 600 }}>{exploitationPatternsDetailed.amplificationReflection.title}</Typography>
                      <Typography variant="body2" sx={{ color: 'grey.400' }}>{exploitationPatternsDetailed.amplificationReflection.summary}</Typography>
                    </Box>
                  </Box>
                </AccordionSummary>
                <AccordionDetails>
                  <Grid container spacing={3}>
                    <Grid item xs={12} md={6}>
                      <Typography variant="h6" sx={{ color: '#c084fc', mb: 1 }}>Understanding the Attack</Typography>
                      <Typography variant="body2" sx={{ color: 'grey.300', whiteSpace: 'pre-line', lineHeight: 1.8 }}>
                        {exploitationPatternsDetailed.amplificationReflection.deepExplanation}
                      </Typography>
                    </Grid>
                    <Grid item xs={12} md={6}>
                      <Typography variant="h6" sx={{ color: '#c084fc', mb: 1 }}>Technical Details</Typography>
                      <Paper sx={{ p: 2, bgcolor: '#1a1f2e', mb: 2 }}>
                        <Typography variant="body2" sx={{ color: 'grey.300', whiteSpace: 'pre-line', fontFamily: 'monospace', fontSize: '0.8rem' }}>
                          {exploitationPatternsDetailed.amplificationReflection.technicalDetails}
                        </Typography>
                      </Paper>
                      
                      <Typography variant="h6" sx={{ color: '#c084fc', mb: 1 }}>Detection Signals</Typography>
                      <List dense>
                        {exploitationPatternsDetailed.amplificationReflection.detectionSignals.map((signal, idx) => (
                          <ListItem key={idx} sx={{ py: 0.25 }}>
                            <ListItemIcon sx={{ minWidth: 28 }}><WarningIcon sx={{ color: '#f59e0b', fontSize: 16 }} /></ListItemIcon>
                            <ListItemText primary={signal} sx={{ '& .MuiListItemText-primary': { color: 'grey.300', fontSize: '0.85rem' } }} />
                          </ListItem>
                        ))}
                      </List>
                    </Grid>
                    <Grid item xs={12}>
                      <Typography variant="h6" sx={{ color: '#c084fc', mb: 1 }}>Real-World Examples</Typography>
                      <Grid container spacing={2}>
                        {exploitationPatternsDetailed.amplificationReflection.realExamples.map((example, idx) => (
                          <Grid item xs={12} md={6} key={idx}>
                            <Paper sx={{ p: 2, bgcolor: '#1a1f2e', border: '1px solid rgba(168, 85, 247, 0.2)' }}>
                              <Typography variant="subtitle2" sx={{ color: '#d8b4fe', fontWeight: 600 }}>{example.name}</Typography>
                              <Typography variant="body2" sx={{ color: 'grey.400', mb: 1 }}>{example.description}</Typography>
                              <Typography variant="caption" sx={{ color: '#22c55e' }}>Outcome: {example.outcome}</Typography>
                            </Paper>
                          </Grid>
                        ))}
                      </Grid>
                    </Grid>
                    <Grid item xs={12}>
                      <Typography variant="h6" sx={{ color: '#22c55e', mb: 1 }}>Defense Strategies</Typography>
                      <Grid container spacing={1}>
                        {exploitationPatternsDetailed.amplificationReflection.defenseStrategies.map((defense, idx) => (
                          <Grid item xs={12} md={6} key={idx}>
                            <Paper sx={{ p: 1.5, bgcolor: '#0a2e1a' }}>
                              <Typography variant="body2" sx={{ color: '#4ade80', fontWeight: 600 }}>{defense.strategy}</Typography>
                              <Typography variant="caption" sx={{ color: 'grey.400', fontFamily: 'monospace' }}>{defense.command}</Typography>
                            </Paper>
                          </Grid>
                        ))}
                      </Grid>
                    </Grid>
                  </Grid>
                </AccordionDetails>
              </Accordion>

              {/* Downgrade Attacks Deep Dive */}
              <Accordion 
                sx={{ 
                  bgcolor: '#0f1422', 
                  mb: 2, 
                  border: '1px solid rgba(245, 158, 11, 0.3)',
                  '&:before': { display: 'none' }
                }}
              >
                <AccordionSummary expandIcon={<ExpandMoreIcon sx={{ color: '#f59e0b' }} />}>
                  <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
                    <Typography variant="h4" component="span">{exploitationPatternsDetailed.downgradeAttacks.icon}</Typography>
                    <Box>
                      <Typography sx={{ color: '#f59e0b', fontWeight: 600 }}>{exploitationPatternsDetailed.downgradeAttacks.title}</Typography>
                      <Typography variant="body2" sx={{ color: 'grey.400' }}>{exploitationPatternsDetailed.downgradeAttacks.summary}</Typography>
                    </Box>
                  </Box>
                </AccordionSummary>
                <AccordionDetails>
                  <Grid container spacing={3}>
                    <Grid item xs={12} md={6}>
                      <Typography variant="h6" sx={{ color: '#fbbf24', mb: 1 }}>Understanding the Attack</Typography>
                      <Typography variant="body2" sx={{ color: 'grey.300', whiteSpace: 'pre-line', lineHeight: 1.8 }}>
                        {exploitationPatternsDetailed.downgradeAttacks.deepExplanation}
                      </Typography>
                    </Grid>
                    <Grid item xs={12} md={6}>
                      <Typography variant="h6" sx={{ color: '#fbbf24', mb: 1 }}>Technical Details</Typography>
                      <Paper sx={{ p: 2, bgcolor: '#1a1f2e', mb: 2 }}>
                        <Typography variant="body2" sx={{ color: 'grey.300', whiteSpace: 'pre-line', fontFamily: 'monospace', fontSize: '0.8rem' }}>
                          {exploitationPatternsDetailed.downgradeAttacks.technicalDetails}
                        </Typography>
                      </Paper>
                      
                      <Typography variant="h6" sx={{ color: '#fbbf24', mb: 1 }}>Detection Signals</Typography>
                      <List dense>
                        {exploitationPatternsDetailed.downgradeAttacks.detectionSignals.map((signal, idx) => (
                          <ListItem key={idx} sx={{ py: 0.25 }}>
                            <ListItemIcon sx={{ minWidth: 28 }}><WarningIcon sx={{ color: '#f59e0b', fontSize: 16 }} /></ListItemIcon>
                            <ListItemText primary={signal} sx={{ '& .MuiListItemText-primary': { color: 'grey.300', fontSize: '0.85rem' } }} />
                          </ListItem>
                        ))}
                      </List>
                    </Grid>
                    <Grid item xs={12}>
                      <Typography variant="h6" sx={{ color: '#fbbf24', mb: 1 }}>Real-World Examples</Typography>
                      <Grid container spacing={2}>
                        {exploitationPatternsDetailed.downgradeAttacks.realExamples.map((example, idx) => (
                          <Grid item xs={12} md={6} key={idx}>
                            <Paper sx={{ p: 2, bgcolor: '#1a1f2e', border: '1px solid rgba(245, 158, 11, 0.2)' }}>
                              <Typography variant="subtitle2" sx={{ color: '#fcd34d', fontWeight: 600 }}>{example.name}</Typography>
                              <Typography variant="body2" sx={{ color: 'grey.400', mb: 1 }}>{example.description}</Typography>
                              <Typography variant="caption" sx={{ color: '#22c55e' }}>Outcome: {example.outcome}</Typography>
                            </Paper>
                          </Grid>
                        ))}
                      </Grid>
                    </Grid>
                    <Grid item xs={12}>
                      <Typography variant="h6" sx={{ color: '#22c55e', mb: 1 }}>Defense Strategies</Typography>
                      <Grid container spacing={1}>
                        {exploitationPatternsDetailed.downgradeAttacks.defenseStrategies.map((defense, idx) => (
                          <Grid item xs={12} md={6} key={idx}>
                            <Paper sx={{ p: 1.5, bgcolor: '#0a2e1a' }}>
                              <Typography variant="body2" sx={{ color: '#4ade80', fontWeight: 600 }}>{defense.strategy}</Typography>
                              <Typography variant="caption" sx={{ color: 'grey.400', fontFamily: 'monospace' }}>{defense.command}</Typography>
                            </Paper>
                          </Grid>
                        ))}
                      </Grid>
                    </Grid>
                  </Grid>
                </AccordionDetails>
              </Accordion>

              {/* Parser Mismatch Deep Dive */}
              <Accordion 
                sx={{ 
                  bgcolor: '#0f1422', 
                  mb: 2, 
                  border: '1px solid rgba(14, 165, 233, 0.3)',
                  '&:before': { display: 'none' }
                }}
              >
                <AccordionSummary expandIcon={<ExpandMoreIcon sx={{ color: '#0ea5e9' }} />}>
                  <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
                    <Typography variant="h4" component="span">{exploitationPatternsDetailed.parserMismatch.icon}</Typography>
                    <Box>
                      <Typography sx={{ color: '#0ea5e9', fontWeight: 600 }}>{exploitationPatternsDetailed.parserMismatch.title}</Typography>
                      <Typography variant="body2" sx={{ color: 'grey.400' }}>{exploitationPatternsDetailed.parserMismatch.summary}</Typography>
                    </Box>
                  </Box>
                </AccordionSummary>
                <AccordionDetails>
                  <Grid container spacing={3}>
                    <Grid item xs={12} md={6}>
                      <Typography variant="h6" sx={{ color: '#38bdf8', mb: 1 }}>Understanding the Attack</Typography>
                      <Typography variant="body2" sx={{ color: 'grey.300', whiteSpace: 'pre-line', lineHeight: 1.8 }}>
                        {exploitationPatternsDetailed.parserMismatch.deepExplanation}
                      </Typography>
                    </Grid>
                    <Grid item xs={12} md={6}>
                      <Typography variant="h6" sx={{ color: '#38bdf8', mb: 1 }}>Technical Details</Typography>
                      <Paper sx={{ p: 2, bgcolor: '#1a1f2e', mb: 2 }}>
                        <Typography variant="body2" sx={{ color: 'grey.300', whiteSpace: 'pre-line', fontFamily: 'monospace', fontSize: '0.8rem' }}>
                          {exploitationPatternsDetailed.parserMismatch.technicalDetails}
                        </Typography>
                      </Paper>
                      
                      <Typography variant="h6" sx={{ color: '#38bdf8', mb: 1 }}>Detection Signals</Typography>
                      <List dense>
                        {exploitationPatternsDetailed.parserMismatch.detectionSignals.map((signal, idx) => (
                          <ListItem key={idx} sx={{ py: 0.25 }}>
                            <ListItemIcon sx={{ minWidth: 28 }}><WarningIcon sx={{ color: '#f59e0b', fontSize: 16 }} /></ListItemIcon>
                            <ListItemText primary={signal} sx={{ '& .MuiListItemText-primary': { color: 'grey.300', fontSize: '0.85rem' } }} />
                          </ListItem>
                        ))}
                      </List>
                    </Grid>
                    <Grid item xs={12}>
                      <Typography variant="h6" sx={{ color: '#38bdf8', mb: 1 }}>Real-World Examples</Typography>
                      <Grid container spacing={2}>
                        {exploitationPatternsDetailed.parserMismatch.realExamples.map((example, idx) => (
                          <Grid item xs={12} md={6} key={idx}>
                            <Paper sx={{ p: 2, bgcolor: '#1a1f2e', border: '1px solid rgba(14, 165, 233, 0.2)' }}>
                              <Typography variant="subtitle2" sx={{ color: '#7dd3fc', fontWeight: 600 }}>{example.name}</Typography>
                              <Typography variant="body2" sx={{ color: 'grey.400', mb: 1 }}>{example.description}</Typography>
                              <Typography variant="caption" sx={{ color: '#22c55e' }}>Outcome: {example.outcome}</Typography>
                            </Paper>
                          </Grid>
                        ))}
                      </Grid>
                    </Grid>
                    <Grid item xs={12}>
                      <Typography variant="h6" sx={{ color: '#22c55e', mb: 1 }}>Defense Strategies</Typography>
                      <Grid container spacing={1}>
                        {exploitationPatternsDetailed.parserMismatch.defenseStrategies.map((defense, idx) => (
                          <Grid item xs={12} md={6} key={idx}>
                            <Paper sx={{ p: 1.5, bgcolor: '#0a2e1a' }}>
                              <Typography variant="body2" sx={{ color: '#4ade80', fontWeight: 600 }}>{defense.strategy}</Typography>
                              <Typography variant="caption" sx={{ color: 'grey.400', fontFamily: 'monospace' }}>{defense.command}</Typography>
                            </Paper>
                          </Grid>
                        ))}
                      </Grid>
                    </Grid>
                  </Grid>
                </AccordionDetails>
              </Accordion>

              {/* Name Resolution Deep Dive */}
              <Accordion 
                sx={{ 
                  bgcolor: '#0f1422', 
                  mb: 2, 
                  border: '1px solid rgba(34, 197, 94, 0.3)',
                  '&:before': { display: 'none' }
                }}
              >
                <AccordionSummary expandIcon={<ExpandMoreIcon sx={{ color: '#22c55e' }} />}>
                  <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
                    <Typography variant="h4" component="span">{exploitationPatternsDetailed.nameResolutionAttacks.icon}</Typography>
                    <Box>
                      <Typography sx={{ color: '#22c55e', fontWeight: 600 }}>{exploitationPatternsDetailed.nameResolutionAttacks.title}</Typography>
                      <Typography variant="body2" sx={{ color: 'grey.400' }}>{exploitationPatternsDetailed.nameResolutionAttacks.summary}</Typography>
                    </Box>
                  </Box>
                </AccordionSummary>
                <AccordionDetails>
                  <Grid container spacing={3}>
                    <Grid item xs={12} md={6}>
                      <Typography variant="h6" sx={{ color: '#4ade80', mb: 1 }}>Understanding the Attack</Typography>
                      <Typography variant="body2" sx={{ color: 'grey.300', whiteSpace: 'pre-line', lineHeight: 1.8 }}>
                        {exploitationPatternsDetailed.nameResolutionAttacks.deepExplanation}
                      </Typography>
                    </Grid>
                    <Grid item xs={12} md={6}>
                      <Typography variant="h6" sx={{ color: '#4ade80', mb: 1 }}>Technical Details</Typography>
                      <Paper sx={{ p: 2, bgcolor: '#1a1f2e', mb: 2 }}>
                        <Typography variant="body2" sx={{ color: 'grey.300', whiteSpace: 'pre-line', fontFamily: 'monospace', fontSize: '0.8rem' }}>
                          {exploitationPatternsDetailed.nameResolutionAttacks.technicalDetails}
                        </Typography>
                      </Paper>
                      
                      <Typography variant="h6" sx={{ color: '#4ade80', mb: 1 }}>Detection Signals</Typography>
                      <List dense>
                        {exploitationPatternsDetailed.nameResolutionAttacks.detectionSignals.map((signal, idx) => (
                          <ListItem key={idx} sx={{ py: 0.25 }}>
                            <ListItemIcon sx={{ minWidth: 28 }}><WarningIcon sx={{ color: '#f59e0b', fontSize: 16 }} /></ListItemIcon>
                            <ListItemText primary={signal} sx={{ '& .MuiListItemText-primary': { color: 'grey.300', fontSize: '0.85rem' } }} />
                          </ListItem>
                        ))}
                      </List>
                    </Grid>
                    <Grid item xs={12}>
                      <Typography variant="h6" sx={{ color: '#4ade80', mb: 1 }}>Real-World Examples</Typography>
                      <Grid container spacing={2}>
                        {exploitationPatternsDetailed.nameResolutionAttacks.realExamples.map((example, idx) => (
                          <Grid item xs={12} md={6} key={idx}>
                            <Paper sx={{ p: 2, bgcolor: '#1a1f2e', border: '1px solid rgba(34, 197, 94, 0.2)' }}>
                              <Typography variant="subtitle2" sx={{ color: '#86efac', fontWeight: 600 }}>{example.name}</Typography>
                              <Typography variant="body2" sx={{ color: 'grey.400', mb: 1 }}>{example.description}</Typography>
                              <Typography variant="caption" sx={{ color: '#22c55e' }}>Outcome: {example.outcome}</Typography>
                            </Paper>
                          </Grid>
                        ))}
                      </Grid>
                    </Grid>
                    <Grid item xs={12}>
                      <Typography variant="h6" sx={{ color: '#22c55e', mb: 1 }}>Defense Strategies</Typography>
                      <Grid container spacing={1}>
                        {exploitationPatternsDetailed.nameResolutionAttacks.defenseStrategies.map((defense, idx) => (
                          <Grid item xs={12} md={6} key={idx}>
                            <Paper sx={{ p: 1.5, bgcolor: '#0a2e1a' }}>
                              <Typography variant="body2" sx={{ color: '#4ade80', fontWeight: 600 }}>{defense.strategy}</Typography>
                              <Typography variant="caption" sx={{ color: 'grey.400', fontFamily: 'monospace' }}>{defense.command}</Typography>
                            </Paper>
                          </Grid>
                        ))}
                      </Grid>
                    </Grid>
                  </Grid>
                </AccordionDetails>
              </Accordion>
            </Box>
          </TabPanel>

          <TabPanel value={tabValue} index={4}>
            <Box sx={{ p: 3 }}>
              {/* Introduction to Detection */}
              <Alert severity="info" sx={{ mb: 3, bgcolor: 'rgba(14, 165, 233, 0.1)', '& .MuiAlert-icon': { color: '#0ea5e9' } }}>
                <Typography variant="body2" sx={{ color: '#7dd3fc' }}>
                  <strong>Detection Fundamentals:</strong> Finding attackers requires understanding what "normal" looks like, 
                  then spotting deviations. This section teaches you the tools, techniques, and thought processes for effective detection.
                </Typography>
              </Alert>

              {/* Detection Methodology Deep Dives */}
              <Typography variant="h5" sx={{ color: '#0ea5e9', mb: 2, fontWeight: 600, display: 'flex', alignItems: 'center', gap: 1 }}>
                üìö Detection Methodology Deep Dives
              </Typography>

              {/* Network Monitoring Deep Dive */}
              <Accordion 
                sx={{ 
                  bgcolor: '#0f1422', 
                  mb: 2, 
                  border: '1px solid rgba(14, 165, 233, 0.3)',
                  '&:before': { display: 'none' }
                }}
              >
                <AccordionSummary expandIcon={<ExpandMoreIcon sx={{ color: '#0ea5e9' }} />}>
                  <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
                    <Typography variant="h4" component="span">{detectionMethodologyDetailed.networkMonitoring.icon}</Typography>
                    <Box>
                      <Typography sx={{ color: '#0ea5e9', fontWeight: 600 }}>{detectionMethodologyDetailed.networkMonitoring.title}</Typography>
                      <Typography variant="body2" sx={{ color: 'grey.400' }}>{detectionMethodologyDetailed.networkMonitoring.description}</Typography>
                    </Box>
                  </Box>
                </AccordionSummary>
                <AccordionDetails>
                  <Grid container spacing={3}>
                    {detectionMethodologyDetailed.networkMonitoring.concepts.map((concept, idx) => (
                      <Grid item xs={12} key={idx}>
                        <Paper sx={{ p: 2, bgcolor: '#1a1f2e', border: '1px solid rgba(14, 165, 233, 0.2)' }}>
                          <Typography variant="h6" sx={{ color: '#38bdf8', mb: 1 }}>{concept.name}</Typography>
                          <Typography variant="body2" sx={{ color: 'grey.300', whiteSpace: 'pre-line', lineHeight: 1.8, mb: 2 }}>
                            {concept.explanation}
                          </Typography>
                          <Box sx={{ display: 'flex', gap: 1, flexWrap: 'wrap' }}>
                            {concept.tools.map((tool, tidx) => (
                              <Chip key={tidx} label={tool} size="small" sx={{ bgcolor: 'rgba(14, 165, 233, 0.2)', color: '#7dd3fc' }} />
                            ))}
                          </Box>
                        </Paper>
                      </Grid>
                    ))}
                    <Grid item xs={12}>
                      <Typography variant="h6" sx={{ color: '#38bdf8', mb: 1 }}>Practical Examples</Typography>
                      <Grid container spacing={2}>
                        {detectionMethodologyDetailed.networkMonitoring.practicalExamples.map((example, idx) => (
                          <Grid item xs={12} md={4} key={idx}>
                            <Paper sx={{ p: 2, bgcolor: '#0a2e1a', border: '1px solid rgba(34, 197, 94, 0.2)' }}>
                              <Typography variant="subtitle2" sx={{ color: '#4ade80', fontWeight: 600 }}>{example.scenario}</Typography>
                              <Typography variant="body2" sx={{ color: 'grey.400', mb: 1 }}>{example.method}</Typography>
                              <Typography variant="caption" sx={{ color: 'grey.500', fontFamily: 'monospace', display: 'block' }}>{example.query}</Typography>
                            </Paper>
                          </Grid>
                        ))}
                      </Grid>
                    </Grid>
                  </Grid>
                </AccordionDetails>
              </Accordion>

              {/* Log Analysis Deep Dive */}
              <Accordion 
                sx={{ 
                  bgcolor: '#0f1422', 
                  mb: 2, 
                  border: '1px solid rgba(168, 85, 247, 0.3)',
                  '&:before': { display: 'none' }
                }}
              >
                <AccordionSummary expandIcon={<ExpandMoreIcon sx={{ color: '#a855f7' }} />}>
                  <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
                    <Typography variant="h4" component="span">{detectionMethodologyDetailed.logAnalysis.icon}</Typography>
                    <Box>
                      <Typography sx={{ color: '#a855f7', fontWeight: 600 }}>{detectionMethodologyDetailed.logAnalysis.title}</Typography>
                      <Typography variant="body2" sx={{ color: 'grey.400' }}>{detectionMethodologyDetailed.logAnalysis.description}</Typography>
                    </Box>
                  </Box>
                </AccordionSummary>
                <AccordionDetails>
                  <Grid container spacing={3}>
                    {detectionMethodologyDetailed.logAnalysis.concepts.map((concept, idx) => (
                      <Grid item xs={12} key={idx}>
                        <Paper sx={{ p: 2, bgcolor: '#1a1f2e', border: '1px solid rgba(168, 85, 247, 0.2)' }}>
                          <Typography variant="h6" sx={{ color: '#c084fc', mb: 1 }}>{concept.name}</Typography>
                          <Typography variant="body2" sx={{ color: 'grey.300', whiteSpace: 'pre-line', lineHeight: 1.8, mb: 2 }}>
                            {concept.explanation}
                          </Typography>
                          <Alert severity="success" sx={{ bgcolor: 'rgba(34, 197, 94, 0.1)', '& .MuiAlert-icon': { color: '#22c55e' } }}>
                            <Typography variant="body2" sx={{ color: '#86efac' }}><strong>Why It Matters:</strong> {concept.importance}</Typography>
                          </Alert>
                        </Paper>
                      </Grid>
                    ))}
                    <Grid item xs={12}>
                      <Typography variant="h6" sx={{ color: '#c084fc', mb: 1 }}>Practical Examples</Typography>
                      <Grid container spacing={2}>
                        {detectionMethodologyDetailed.logAnalysis.practicalExamples.map((example, idx) => (
                          <Grid item xs={12} md={4} key={idx}>
                            <Paper sx={{ p: 2, bgcolor: '#0a2e1a', border: '1px solid rgba(34, 197, 94, 0.2)' }}>
                              <Typography variant="subtitle2" sx={{ color: '#4ade80', fontWeight: 600 }}>{example.scenario}</Typography>
                              <Typography variant="body2" sx={{ color: 'grey.400', mb: 1 }}>{example.method}</Typography>
                              <Typography variant="caption" sx={{ color: 'grey.500', fontFamily: 'monospace', display: 'block' }}>{example.query}</Typography>
                            </Paper>
                          </Grid>
                        ))}
                      </Grid>
                    </Grid>
                  </Grid>
                </AccordionDetails>
              </Accordion>

              {/* Threat Hunting Deep Dive */}
              <Accordion 
                sx={{ 
                  bgcolor: '#0f1422', 
                  mb: 3, 
                  border: '1px solid rgba(245, 158, 11, 0.3)',
                  '&:before': { display: 'none' }
                }}
              >
                <AccordionSummary expandIcon={<ExpandMoreIcon sx={{ color: '#f59e0b' }} />}>
                  <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
                    <Typography variant="h4" component="span">{detectionMethodologyDetailed.threatHunting.icon}</Typography>
                    <Box>
                      <Typography sx={{ color: '#f59e0b', fontWeight: 600 }}>{detectionMethodologyDetailed.threatHunting.title}</Typography>
                      <Typography variant="body2" sx={{ color: 'grey.400' }}>{detectionMethodologyDetailed.threatHunting.description}</Typography>
                    </Box>
                  </Box>
                </AccordionSummary>
                <AccordionDetails>
                  <Grid container spacing={3}>
                    {detectionMethodologyDetailed.threatHunting.concepts.map((concept, idx) => (
                      <Grid item xs={12} key={idx}>
                        <Paper sx={{ p: 2, bgcolor: '#1a1f2e', border: '1px solid rgba(245, 158, 11, 0.2)' }}>
                          <Typography variant="h6" sx={{ color: '#fbbf24', mb: 1 }}>{concept.name}</Typography>
                          <Typography variant="body2" sx={{ color: 'grey.300', whiteSpace: 'pre-line', lineHeight: 1.8, mb: 2 }}>
                            {concept.explanation}
                          </Typography>
                          <Alert severity="warning" sx={{ bgcolor: 'rgba(245, 158, 11, 0.1)', '& .MuiAlert-icon': { color: '#f59e0b' } }}>
                            <Typography variant="body2" sx={{ color: '#fcd34d' }}><strong>Key Insight:</strong> {concept.importance}</Typography>
                          </Alert>
                        </Paper>
                      </Grid>
                    ))}
                    <Grid item xs={12}>
                      <Typography variant="h6" sx={{ color: '#fbbf24', mb: 1 }}>Practical Hunt Examples</Typography>
                      <Grid container spacing={2}>
                        {detectionMethodologyDetailed.threatHunting.practicalExamples.map((example, idx) => (
                          <Grid item xs={12} md={4} key={idx}>
                            <Paper sx={{ p: 2, bgcolor: '#0a2e1a', border: '1px solid rgba(34, 197, 94, 0.2)' }}>
                              <Typography variant="subtitle2" sx={{ color: '#4ade80', fontWeight: 600 }}>{example.scenario}</Typography>
                              <Typography variant="body2" sx={{ color: 'grey.400', mb: 1 }}>{example.method}</Typography>
                              <Typography variant="caption" sx={{ color: 'grey.500', fontFamily: 'monospace', display: 'block' }}>{example.query}</Typography>
                            </Paper>
                          </Grid>
                        ))}
                      </Grid>
                    </Grid>
                  </Grid>
                </AccordionDetails>
              </Accordion>

              <Divider sx={{ my: 4, borderColor: 'rgba(148, 163, 184, 0.2)' }} />

              {/* Original Quick Reference Content */}
              <Typography variant="h5" sx={{ color: '#0ea5e9', mb: 2, fontWeight: 600 }}>
                üìã Quick Reference
              </Typography>

              <Paper sx={{ p: 2.5, mb: 3, bgcolor: "#0f1422", borderRadius: 2 }}>
                <Typography variant="h6" sx={{ color: "#0ea5e9", mb: 1 }}>
                  Detection Signals
                </Typography>
                <List dense>
                  {detectionSignals.map((item) => (
                    <ListItem key={item}>
                      <ListItemIcon>
                        <CheckCircleIcon color="info" fontSize="small" />
                      </ListItemIcon>
                      <ListItemText primary={item} sx={{ "& .MuiListItemText-primary": { color: "grey.300" } }} />
                    </ListItem>
                  ))}
                </List>
              </Paper>

              <Paper sx={{ p: 2.5, mb: 3, bgcolor: "#0f1422", borderRadius: 2 }}>
                <Typography variant="h6" sx={{ color: "#0ea5e9", mb: 1 }}>
                  Telemetry Sources
                </Typography>
                <List dense>
                  {telemetrySources.map((item) => (
                    <ListItem key={item}>
                      <ListItemIcon>
                        <CheckCircleIcon color="success" fontSize="small" />
                      </ListItemIcon>
                      <ListItemText primary={item} sx={{ "& .MuiListItemText-primary": { color: "grey.300" } }} />
                    </ListItem>
                  ))}
                </List>
              </Paper>

              <Paper sx={{ p: 2.5, mb: 3, bgcolor: "#0f1422", borderRadius: 2 }}>
                <Typography variant="h6" sx={{ color: "#0ea5e9", mb: 1 }}>
                  Detection Matrix (Simple)
                </Typography>
                <TableContainer>
                  <Table size="small">
                    <TableHead>
                      <TableRow>
                        <TableCell sx={{ color: "#93c5fd" }}>Stage</TableCell>
                        <TableCell sx={{ color: "#93c5fd" }}>Signal</TableCell>
                        <TableCell sx={{ color: "#93c5fd" }}>Evidence</TableCell>
                      </TableRow>
                    </TableHead>
                    <TableBody>
                      {detectionMatrix.map((item) => (
                        <TableRow key={item.stage}>
                          <TableCell sx={{ color: "grey.200", fontWeight: 600 }}>{item.stage}</TableCell>
                          <TableCell sx={{ color: "grey.400" }}>{item.signal}</TableCell>
                          <TableCell sx={{ color: "grey.400" }}>{item.evidence}</TableCell>
                        </TableRow>
                      ))}
                    </TableBody>
                  </Table>
                </TableContainer>
              </Paper>

              <Paper sx={{ p: 2.5, mb: 3, bgcolor: "#0f1422", borderRadius: 2 }}>
                <Typography variant="h6" sx={{ color: "#0ea5e9", mb: 1 }}>
                  Baseline Metrics to Track
                </Typography>
                <TableContainer>
                  <Table size="small">
                    <TableHead>
                      <TableRow>
                        <TableCell sx={{ color: "#93c5fd" }}>Metric</TableCell>
                        <TableCell sx={{ color: "#93c5fd" }}>Normal</TableCell>
                        <TableCell sx={{ color: "#93c5fd" }}>Investigate When</TableCell>
                      </TableRow>
                    </TableHead>
                    <TableBody>
                      {baselineMetrics.map((item) => (
                        <TableRow key={item.metric}>
                          <TableCell sx={{ color: "grey.200", fontWeight: 600 }}>{item.metric}</TableCell>
                          <TableCell sx={{ color: "grey.400" }}>{item.normal}</TableCell>
                          <TableCell sx={{ color: "grey.400" }}>{item.investigate}</TableCell>
                        </TableRow>
                      ))}
                    </TableBody>
                  </Table>
                </TableContainer>
              </Paper>

              <Paper sx={{ p: 2.5, mb: 3, bgcolor: "#0f1422", borderRadius: 2 }}>
                <Typography variant="h6" sx={{ color: "#0ea5e9", mb: 1 }}>
                  Quick Triage Steps
                </Typography>
                <List dense>
                  {triageSteps.map((item) => (
                    <ListItem key={item}>
                      <ListItemIcon>
                        <CheckCircleIcon color="info" fontSize="small" />
                      </ListItemIcon>
                      <ListItemText primary={item} sx={{ "& .MuiListItemText-primary": { color: "grey.300" } }} />
                    </ListItem>
                  ))}
                </List>
              </Paper>

              {logQueries.map((item) => (
                <Accordion key={item.label} sx={{ bgcolor: "#0f1422", borderRadius: 2, mb: 1 }}>
                  <AccordionSummary expandIcon={<ExpandMoreIcon />}>
                    <Typography variant="h6">{item.label}</Typography>
                  </AccordionSummary>
                  <AccordionDetails>
                    <CodeBlock code={item.query} language={item.language} />
                  </AccordionDetails>
                </Accordion>
              ))}

              <Accordion>
                <AccordionSummary expandIcon={<ExpandMoreIcon />}>
                  <Typography variant="h6">Safe Read-only Checks</Typography>
                </AccordionSummary>
                <AccordionDetails>
                  <CodeBlock code={safeChecks} language="powershell" />
                </AccordionDetails>
              </Accordion>
            </Box>
          </TabPanel>

          <TabPanel value={tabValue} index={5}>
            <Box sx={{ p: 3 }}>
              <Paper sx={{ p: 2.5, mb: 3, bgcolor: "#0f1422", borderRadius: 2 }}>
                <Typography variant="h6" sx={{ color: "#0ea5e9", mb: 1 }}>
                  Hardening Checklist
                </Typography>
                <List dense>
                  {hardeningChecklist.map((item) => (
                    <ListItem key={item}>
                      <ListItemIcon>
                        <CheckCircleIcon color="info" fontSize="small" />
                      </ListItemIcon>
                      <ListItemText primary={item} sx={{ "& .MuiListItemText-primary": { color: "grey.300" } }} />
                    </ListItem>
                  ))}
                </List>
              </Paper>

              <Grid container spacing={2} sx={{ mb: 3 }}>
                {hardeningTracks.map((track) => (
                  <Grid item xs={12} md={6} key={track.title}>
                    <Paper sx={{ p: 2, bgcolor: "#0f1422", borderRadius: 2, height: "100%" }}>
                      <Typography variant="subtitle1" sx={{ color: "#e2e8f0", fontWeight: 600, mb: 1 }}>
                        {track.title}
                      </Typography>
                      <List dense>
                        {track.items.map((item) => (
                          <ListItem key={item}>
                            <ListItemIcon>
                              <CheckCircleIcon color="info" fontSize="small" />
                            </ListItemIcon>
                            <ListItemText primary={item} sx={{ "& .MuiListItemText-primary": { color: "grey.300" } }} />
                          </ListItem>
                        ))}
                      </List>
                    </Paper>
                  </Grid>
                ))}
              </Grid>

              <Paper sx={{ p: 2.5, mb: 3, bgcolor: "#0f1422", borderRadius: 2 }}>
                <Typography variant="h6" sx={{ color: "#0ea5e9", mb: 1 }}>
                  Legacy Deprecations to Plan
                </Typography>
                <TableContainer>
                  <Table size="small">
                    <TableHead>
                      <TableRow>
                        <TableCell sx={{ color: "#93c5fd" }}>Protocol</TableCell>
                        <TableCell sx={{ color: "#93c5fd" }}>Risk</TableCell>
                        <TableCell sx={{ color: "#93c5fd" }}>Recommended Action</TableCell>
                      </TableRow>
                    </TableHead>
                    <TableBody>
                      {legacyDeprecations.map((item) => (
                        <TableRow key={item.protocol}>
                          <TableCell sx={{ color: "grey.200", fontWeight: 600 }}>{item.protocol}</TableCell>
                          <TableCell sx={{ color: "grey.400" }}>{item.risk}</TableCell>
                          <TableCell sx={{ color: "grey.400" }}>{item.action}</TableCell>
                        </TableRow>
                      ))}
                    </TableBody>
                  </Table>
                </TableContainer>
              </Paper>

              <Paper sx={{ p: 2.5, bgcolor: "#0f1422", borderRadius: 2 }}>
                <Typography variant="h6" sx={{ color: "#f59e0b", mb: 1 }}>
                  Protocol Hardening Priorities
                </Typography>
                <List dense>
                  {[
                    "Remove unused services and close unused ports.",
                    "Enforce modern TLS policies and disable fallback.",
                    "Require signing and strong auth on internal protocols.",
                    "Put management services behind VPN or jump hosts.",
                    "Review firewall rules for protocol-specific exposure.",
                  ].map((item) => (
                    <ListItem key={item}>
                      <ListItemIcon>
                        <ShieldIcon color="warning" fontSize="small" />
                      </ListItemIcon>
                      <ListItemText primary={item} sx={{ "& .MuiListItemText-primary": { color: "grey.300" } }} />
                    </ListItem>
                  ))}
                </List>
              </Paper>
            </Box>
          </TabPanel>

          <TabPanel value={tabValue} index={6}>
            <Box sx={{ p: 3 }}>
              {/* Safety Warning */}
              <Alert severity="error" sx={{ mb: 3, bgcolor: 'rgba(220, 38, 38, 0.1)', '& .MuiAlert-icon': { color: '#dc2626' } }}>
                <Typography variant="body2" sx={{ color: '#fca5a5' }}>
                  <strong>‚ö†Ô∏è SAFETY FIRST:</strong> These labs involve techniques that can disrupt networks. 
                  ONLY perform exercises in isolated lab environments you own. Never test on production networks or systems without explicit written permission.
                </Typography>
              </Alert>

              {/* Detailed Lab Exercises */}
              <Typography variant="h5" sx={{ color: '#0ea5e9', mb: 2, fontWeight: 600, display: 'flex', alignItems: 'center', gap: 1 }}>
                üî¨ Hands-On Lab Exercises
              </Typography>
              <Typography variant="body2" sx={{ color: 'grey.400', mb: 3 }}>
                Step-by-step exercises to practice network protocol analysis in a safe environment. Each lab includes detailed instructions, expected outputs, and troubleshooting tips.
              </Typography>

              {/* Packet Analysis Lab */}
              <Accordion 
                sx={{ 
                  bgcolor: '#0f1422', 
                  mb: 2, 
                  border: '1px solid rgba(14, 165, 233, 0.3)',
                  '&:before': { display: 'none' }
                }}
              >
                <AccordionSummary expandIcon={<ExpandMoreIcon sx={{ color: '#0ea5e9' }} />}>
                  <Box sx={{ display: 'flex', alignItems: 'center', gap: 2, width: '100%' }}>
                    <Typography variant="h4" component="span">üì¶</Typography>
                    <Box sx={{ flex: 1 }}>
                      <Typography sx={{ color: '#0ea5e9', fontWeight: 600 }}>{labExercisesDetailed.packetAnalysisLab.title}</Typography>
                      <Box sx={{ display: 'flex', gap: 2, mt: 0.5 }}>
                        <Chip label={labExercisesDetailed.packetAnalysisLab.difficulty} size="small" sx={{ bgcolor: 'rgba(34, 197, 94, 0.2)', color: '#4ade80' }} />
                        <Typography variant="caption" sx={{ color: 'grey.500' }}>‚è±Ô∏è {labExercisesDetailed.packetAnalysisLab.estimatedTime}</Typography>
                      </Box>
                    </Box>
                  </Box>
                </AccordionSummary>
                <AccordionDetails>
                  <Grid container spacing={3}>
                    {/* Objectives */}
                    <Grid item xs={12} md={6}>
                      <Typography variant="h6" sx={{ color: '#38bdf8', mb: 1 }}>Learning Objectives</Typography>
                      <List dense>
                        {labExercisesDetailed.packetAnalysisLab.objectives.map((obj, idx) => (
                          <ListItem key={idx} sx={{ py: 0.25 }}>
                            <ListItemIcon sx={{ minWidth: 28 }}><CheckCircleIcon sx={{ color: '#22c55e', fontSize: 16 }} /></ListItemIcon>
                            <ListItemText primary={obj} sx={{ '& .MuiListItemText-primary': { color: 'grey.300', fontSize: '0.85rem' } }} />
                          </ListItem>
                        ))}
                      </List>
                    </Grid>
                    <Grid item xs={12} md={6}>
                      <Typography variant="h6" sx={{ color: '#38bdf8', mb: 1 }}>Prerequisites</Typography>
                      <List dense>
                        {labExercisesDetailed.packetAnalysisLab.prerequisites.map((prereq, idx) => (
                          <ListItem key={idx} sx={{ py: 0.25 }}>
                            <ListItemIcon sx={{ minWidth: 28 }}><SecurityIcon sx={{ color: '#f59e0b', fontSize: 16 }} /></ListItemIcon>
                            <ListItemText primary={prereq} sx={{ '& .MuiListItemText-primary': { color: 'grey.300', fontSize: '0.85rem' } }} />
                          </ListItem>
                        ))}
                      </List>
                    </Grid>

                    {/* Step-by-Step Instructions */}
                    <Grid item xs={12}>
                      <Typography variant="h6" sx={{ color: '#38bdf8', mb: 2 }}>Step-by-Step Instructions</Typography>
                      {labExercisesDetailed.packetAnalysisLab.steps.map((step, idx) => (
                        <Paper key={idx} sx={{ p: 2, mb: 2, bgcolor: '#1a1f2e', border: '1px solid rgba(14, 165, 233, 0.2)' }}>
                          <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 1 }}>
                            <Chip label={`Step ${step.number}`} size="small" sx={{ bgcolor: '#0ea5e9', color: 'white', fontWeight: 600 }} />
                            <Typography variant="subtitle1" sx={{ color: '#e2e8f0', fontWeight: 600 }}>{step.title}</Typography>
                          </Box>
                          <Typography variant="body2" sx={{ color: 'grey.400', mb: 2 }}>{step.explanation}</Typography>
                          <CodeBlock code={step.commands.join('\n')} language="bash" />
                          <Box sx={{ mt: 2 }}>
                            <Typography variant="subtitle2" sx={{ color: '#4ade80', mb: 0.5 }}>Expected Output:</Typography>
                            <Typography variant="body2" sx={{ color: 'grey.400' }}>{step.expectedOutput}</Typography>
                          </Box>
                          <Box sx={{ mt: 2, p: 1.5, bgcolor: 'rgba(245, 158, 11, 0.1)', borderRadius: 1 }}>
                            <Typography variant="subtitle2" sx={{ color: '#fbbf24', mb: 0.5 }}>üí° Tips:</Typography>
                            <List dense sx={{ py: 0 }}>
                              {step.tips.map((tip, tidx) => (
                                <ListItem key={tidx} sx={{ py: 0, pl: 0 }}>
                                  <ListItemText primary={`‚Ä¢ ${tip}`} sx={{ '& .MuiListItemText-primary': { color: 'grey.400', fontSize: '0.8rem' } }} />
                                </ListItem>
                              ))}
                            </List>
                          </Box>
                        </Paper>
                      ))}
                    </Grid>

                    {/* Practice Exercise */}
                    <Grid item xs={12}>
                      <Paper sx={{ p: 2, bgcolor: '#0a2e1a', border: '1px solid rgba(34, 197, 94, 0.3)' }}>
                        <Typography variant="h6" sx={{ color: '#4ade80', mb: 1 }}>üéØ {labExercisesDetailed.packetAnalysisLab.practiceExercise.title}</Typography>
                        <Typography variant="body2" sx={{ color: 'grey.300', mb: 2 }}>{labExercisesDetailed.packetAnalysisLab.practiceExercise.instructions}</Typography>
                        <Grid container spacing={2}>
                          <Grid item xs={12} md={6}>
                            <Typography variant="subtitle2" sx={{ color: '#86efac', mb: 1 }}>Questions:</Typography>
                            <List dense>
                              {labExercisesDetailed.packetAnalysisLab.practiceExercise.questions.map((q, idx) => (
                                <ListItem key={idx} sx={{ py: 0.25 }}>
                                  <ListItemText primary={`${idx + 1}. ${q}`} sx={{ '& .MuiListItemText-primary': { color: 'grey.300', fontSize: '0.85rem' } }} />
                                </ListItem>
                              ))}
                            </List>
                          </Grid>
                          <Grid item xs={12} md={6}>
                            <Typography variant="subtitle2" sx={{ color: '#fbbf24', mb: 1 }}>Hints:</Typography>
                            <List dense>
                              {labExercisesDetailed.packetAnalysisLab.practiceExercise.hints.map((hint, idx) => (
                                <ListItem key={idx} sx={{ py: 0.25 }}>
                                  <ListItemText primary={`‚Ä¢ ${hint}`} sx={{ '& .MuiListItemText-primary': { color: 'grey.400', fontSize: '0.8rem', fontFamily: 'monospace' } }} />
                                </ListItem>
                              ))}
                            </List>
                          </Grid>
                        </Grid>
                      </Paper>
                    </Grid>
                  </Grid>
                </AccordionDetails>
              </Accordion>

              {/* ARP Poisoning Lab */}
              <Accordion 
                sx={{ 
                  bgcolor: '#0f1422', 
                  mb: 2, 
                  border: '1px solid rgba(220, 38, 38, 0.3)',
                  '&:before': { display: 'none' }
                }}
              >
                <AccordionSummary expandIcon={<ExpandMoreIcon sx={{ color: '#dc2626' }} />}>
                  <Box sx={{ display: 'flex', alignItems: 'center', gap: 2, width: '100%' }}>
                    <Typography variant="h4" component="span">üïµÔ∏è</Typography>
                    <Box sx={{ flex: 1 }}>
                      <Typography sx={{ color: '#dc2626', fontWeight: 600 }}>{labExercisesDetailed.arpPoisoningLab.title}</Typography>
                      <Box sx={{ display: 'flex', gap: 2, mt: 0.5 }}>
                        <Chip label={labExercisesDetailed.arpPoisoningLab.difficulty} size="small" sx={{ bgcolor: 'rgba(245, 158, 11, 0.2)', color: '#fbbf24' }} />
                        <Typography variant="caption" sx={{ color: 'grey.500' }}>‚è±Ô∏è {labExercisesDetailed.arpPoisoningLab.estimatedTime}</Typography>
                      </Box>
                    </Box>
                  </Box>
                </AccordionSummary>
                <AccordionDetails>
                  {/* Safety Warning */}
                  <Alert severity="error" sx={{ mb: 3, bgcolor: 'rgba(220, 38, 38, 0.2)', '& .MuiAlert-icon': { color: '#dc2626' } }}>
                    <Typography variant="body2" sx={{ color: '#fca5a5' }}>{labExercisesDetailed.arpPoisoningLab.safetyWarning}</Typography>
                  </Alert>

                  <Grid container spacing={3}>
                    <Grid item xs={12} md={6}>
                      <Typography variant="h6" sx={{ color: '#f87171', mb: 1 }}>Learning Objectives</Typography>
                      <List dense>
                        {labExercisesDetailed.arpPoisoningLab.objectives.map((obj, idx) => (
                          <ListItem key={idx} sx={{ py: 0.25 }}>
                            <ListItemIcon sx={{ minWidth: 28 }}><CheckCircleIcon sx={{ color: '#22c55e', fontSize: 16 }} /></ListItemIcon>
                            <ListItemText primary={obj} sx={{ '& .MuiListItemText-primary': { color: 'grey.300', fontSize: '0.85rem' } }} />
                          </ListItem>
                        ))}
                      </List>
                    </Grid>
                    <Grid item xs={12} md={6}>
                      <Typography variant="h6" sx={{ color: '#f87171', mb: 1 }}>Prerequisites</Typography>
                      <List dense>
                        {labExercisesDetailed.arpPoisoningLab.prerequisites.map((prereq, idx) => (
                          <ListItem key={idx} sx={{ py: 0.25 }}>
                            <ListItemIcon sx={{ minWidth: 28 }}><WarningIcon sx={{ color: '#f59e0b', fontSize: 16 }} /></ListItemIcon>
                            <ListItemText primary={prereq} sx={{ '& .MuiListItemText-primary': { color: 'grey.300', fontSize: '0.85rem' } }} />
                          </ListItem>
                        ))}
                      </List>
                    </Grid>

                    <Grid item xs={12}>
                      <Typography variant="h6" sx={{ color: '#f87171', mb: 2 }}>Step-by-Step Instructions</Typography>
                      {labExercisesDetailed.arpPoisoningLab.steps.map((step, idx) => (
                        <Paper key={idx} sx={{ p: 2, mb: 2, bgcolor: '#1a1f2e', border: '1px solid rgba(220, 38, 38, 0.2)' }}>
                          <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 1 }}>
                            <Chip label={`Step ${step.number}`} size="small" sx={{ bgcolor: '#dc2626', color: 'white', fontWeight: 600 }} />
                            <Typography variant="subtitle1" sx={{ color: '#e2e8f0', fontWeight: 600 }}>{step.title}</Typography>
                          </Box>
                          <Typography variant="body2" sx={{ color: 'grey.400', mb: 2 }}>{step.explanation}</Typography>
                          <CodeBlock code={step.commands.join('\n')} language="bash" />
                          <Box sx={{ mt: 2 }}>
                            <Typography variant="subtitle2" sx={{ color: '#4ade80', mb: 0.5 }}>Expected Output:</Typography>
                            <Typography variant="body2" sx={{ color: 'grey.400' }}>{step.expectedOutput}</Typography>
                          </Box>
                          <Box sx={{ mt: 2, p: 1.5, bgcolor: 'rgba(245, 158, 11, 0.1)', borderRadius: 1 }}>
                            <Typography variant="subtitle2" sx={{ color: '#fbbf24', mb: 0.5 }}>üí° Tips:</Typography>
                            <List dense sx={{ py: 0 }}>
                              {step.tips.map((tip, tidx) => (
                                <ListItem key={tidx} sx={{ py: 0, pl: 0 }}>
                                  <ListItemText primary={`‚Ä¢ ${tip}`} sx={{ '& .MuiListItemText-primary': { color: 'grey.400', fontSize: '0.8rem' } }} />
                                </ListItem>
                              ))}
                            </List>
                          </Box>
                        </Paper>
                      ))}
                    </Grid>

                    <Grid item xs={12}>
                      <Paper sx={{ p: 2, bgcolor: '#0a2e1a', border: '1px solid rgba(34, 197, 94, 0.3)' }}>
                        <Typography variant="h6" sx={{ color: '#4ade80', mb: 1 }}>üéØ {labExercisesDetailed.arpPoisoningLab.practiceExercise.title}</Typography>
                        <Typography variant="body2" sx={{ color: 'grey.300', mb: 2 }}>{labExercisesDetailed.arpPoisoningLab.practiceExercise.instructions}</Typography>
                        <Grid container spacing={2}>
                          <Grid item xs={12} md={6}>
                            <Typography variant="subtitle2" sx={{ color: '#86efac', mb: 1 }}>Tasks:</Typography>
                            <List dense>
                              {labExercisesDetailed.arpPoisoningLab.practiceExercise.questions.map((q, idx) => (
                                <ListItem key={idx} sx={{ py: 0.25 }}>
                                  <ListItemText primary={`${idx + 1}. ${q}`} sx={{ '& .MuiListItemText-primary': { color: 'grey.300', fontSize: '0.85rem' } }} />
                                </ListItem>
                              ))}
                            </List>
                          </Grid>
                          <Grid item xs={12} md={6}>
                            <Typography variant="subtitle2" sx={{ color: '#fbbf24', mb: 1 }}>Code Hints:</Typography>
                            <List dense>
                              {labExercisesDetailed.arpPoisoningLab.practiceExercise.hints.map((hint, idx) => (
                                <ListItem key={idx} sx={{ py: 0.25 }}>
                                  <ListItemText primary={hint} sx={{ '& .MuiListItemText-primary': { color: 'grey.400', fontSize: '0.8rem', fontFamily: 'monospace' } }} />
                                </ListItem>
                              ))}
                            </List>
                          </Grid>
                        </Grid>
                      </Paper>
                    </Grid>
                  </Grid>
                </AccordionDetails>
              </Accordion>

              {/* DNS Analysis Lab */}
              <Accordion 
                sx={{ 
                  bgcolor: '#0f1422', 
                  mb: 3, 
                  border: '1px solid rgba(168, 85, 247, 0.3)',
                  '&:before': { display: 'none' }
                }}
              >
                <AccordionSummary expandIcon={<ExpandMoreIcon sx={{ color: '#a855f7' }} />}>
                  <Box sx={{ display: 'flex', alignItems: 'center', gap: 2, width: '100%' }}>
                    <Typography variant="h4" component="span">üîç</Typography>
                    <Box sx={{ flex: 1 }}>
                      <Typography sx={{ color: '#a855f7', fontWeight: 600 }}>{labExercisesDetailed.dnsAnalysisLab.title}</Typography>
                      <Box sx={{ display: 'flex', gap: 2, mt: 0.5 }}>
                        <Chip label={labExercisesDetailed.dnsAnalysisLab.difficulty} size="small" sx={{ bgcolor: 'rgba(245, 158, 11, 0.2)', color: '#fbbf24' }} />
                        <Typography variant="caption" sx={{ color: 'grey.500' }}>‚è±Ô∏è {labExercisesDetailed.dnsAnalysisLab.estimatedTime}</Typography>
                      </Box>
                    </Box>
                  </Box>
                </AccordionSummary>
                <AccordionDetails>
                  <Grid container spacing={3}>
                    <Grid item xs={12} md={6}>
                      <Typography variant="h6" sx={{ color: '#c084fc', mb: 1 }}>Learning Objectives</Typography>
                      <List dense>
                        {labExercisesDetailed.dnsAnalysisLab.objectives.map((obj, idx) => (
                          <ListItem key={idx} sx={{ py: 0.25 }}>
                            <ListItemIcon sx={{ minWidth: 28 }}><CheckCircleIcon sx={{ color: '#22c55e', fontSize: 16 }} /></ListItemIcon>
                            <ListItemText primary={obj} sx={{ '& .MuiListItemText-primary': { color: 'grey.300', fontSize: '0.85rem' } }} />
                          </ListItem>
                        ))}
                      </List>
                    </Grid>
                    <Grid item xs={12} md={6}>
                      <Typography variant="h6" sx={{ color: '#c084fc', mb: 1 }}>Prerequisites</Typography>
                      <List dense>
                        {labExercisesDetailed.dnsAnalysisLab.prerequisites.map((prereq, idx) => (
                          <ListItem key={idx} sx={{ py: 0.25 }}>
                            <ListItemIcon sx={{ minWidth: 28 }}><SecurityIcon sx={{ color: '#f59e0b', fontSize: 16 }} /></ListItemIcon>
                            <ListItemText primary={prereq} sx={{ '& .MuiListItemText-primary': { color: 'grey.300', fontSize: '0.85rem' } }} />
                          </ListItem>
                        ))}
                      </List>
                    </Grid>

                    <Grid item xs={12}>
                      <Typography variant="h6" sx={{ color: '#c084fc', mb: 2 }}>Step-by-Step Instructions</Typography>
                      {labExercisesDetailed.dnsAnalysisLab.steps.map((step, idx) => (
                        <Paper key={idx} sx={{ p: 2, mb: 2, bgcolor: '#1a1f2e', border: '1px solid rgba(168, 85, 247, 0.2)' }}>
                          <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 1 }}>
                            <Chip label={`Step ${step.number}`} size="small" sx={{ bgcolor: '#a855f7', color: 'white', fontWeight: 600 }} />
                            <Typography variant="subtitle1" sx={{ color: '#e2e8f0', fontWeight: 600 }}>{step.title}</Typography>
                          </Box>
                          <Typography variant="body2" sx={{ color: 'grey.400', mb: 2 }}>{step.explanation}</Typography>
                          <CodeBlock code={step.commands.join('\n')} language="bash" />
                          <Box sx={{ mt: 2 }}>
                            <Typography variant="subtitle2" sx={{ color: '#4ade80', mb: 0.5 }}>Expected Output:</Typography>
                            <Typography variant="body2" sx={{ color: 'grey.400' }}>{step.expectedOutput}</Typography>
                          </Box>
                          <Box sx={{ mt: 2, p: 1.5, bgcolor: 'rgba(245, 158, 11, 0.1)', borderRadius: 1 }}>
                            <Typography variant="subtitle2" sx={{ color: '#fbbf24', mb: 0.5 }}>üí° Tips:</Typography>
                            <List dense sx={{ py: 0 }}>
                              {step.tips.map((tip, tidx) => (
                                <ListItem key={tidx} sx={{ py: 0, pl: 0 }}>
                                  <ListItemText primary={`‚Ä¢ ${tip}`} sx={{ '& .MuiListItemText-primary': { color: 'grey.400', fontSize: '0.8rem' } }} />
                                </ListItem>
                              ))}
                            </List>
                          </Box>
                        </Paper>
                      ))}
                    </Grid>

                    <Grid item xs={12}>
                      <Paper sx={{ p: 2, bgcolor: '#0a2e1a', border: '1px solid rgba(34, 197, 94, 0.3)' }}>
                        <Typography variant="h6" sx={{ color: '#4ade80', mb: 1 }}>üéØ {labExercisesDetailed.dnsAnalysisLab.practiceExercise.title}</Typography>
                        <Typography variant="body2" sx={{ color: 'grey.300', mb: 2 }}>{labExercisesDetailed.dnsAnalysisLab.practiceExercise.instructions}</Typography>
                        <Grid container spacing={2}>
                          <Grid item xs={12} md={6}>
                            <Typography variant="subtitle2" sx={{ color: '#86efac', mb: 1 }}>Questions:</Typography>
                            <List dense>
                              {labExercisesDetailed.dnsAnalysisLab.practiceExercise.questions.map((q, idx) => (
                                <ListItem key={idx} sx={{ py: 0.25 }}>
                                  <ListItemText primary={`${idx + 1}. ${q}`} sx={{ '& .MuiListItemText-primary': { color: 'grey.300', fontSize: '0.85rem' } }} />
                                </ListItem>
                              ))}
                            </List>
                          </Grid>
                          <Grid item xs={12} md={6}>
                            <Typography variant="subtitle2" sx={{ color: '#fbbf24', mb: 1 }}>Hints:</Typography>
                            <List dense>
                              {labExercisesDetailed.dnsAnalysisLab.practiceExercise.hints.map((hint, idx) => (
                                <ListItem key={idx} sx={{ py: 0.25 }}>
                                  <ListItemText primary={`‚Ä¢ ${hint}`} sx={{ '& .MuiListItemText-primary': { color: 'grey.400', fontSize: '0.8rem', fontFamily: 'monospace' } }} />
                                </ListItem>
                              ))}
                            </List>
                          </Grid>
                        </Grid>
                      </Paper>
                    </Grid>
                  </Grid>
                </AccordionDetails>
              </Accordion>

              <Divider sx={{ my: 4, borderColor: 'rgba(148, 163, 184, 0.2)' }} />

              {/* Original Quick Reference Content */}
              <Typography variant="h5" sx={{ color: '#0ea5e9', mb: 2, fontWeight: 600 }}>
                üìã Quick Reference Checklists
              </Typography>

              <Paper sx={{ p: 2.5, mb: 3, bgcolor: "#0f1422", borderRadius: 2 }}>
                <Typography variant="h6" sx={{ color: "#0ea5e9", mb: 1 }}>
                  Safe Lab Walkthrough
                </Typography>
                <List dense>
                  {labSteps.map((item) => (
                    <ListItem key={item}>
                      <ListItemIcon>
                        <CheckCircleIcon color="info" fontSize="small" />
                      </ListItemIcon>
                      <ListItemText primary={item} sx={{ "& .MuiListItemText-primary": { color: "grey.300" } }} />
                    </ListItem>
                  ))}
                </List>
              </Paper>

              <Paper sx={{ p: 2.5, mb: 3, bgcolor: "#0f1422", borderRadius: 2 }}>
                <Typography variant="h6" sx={{ color: "#0ea5e9", mb: 1 }}>
                  Mini Exercises
                </Typography>
                <List dense>
                  {labExercises.map((item) => (
                    <ListItem key={item}>
                      <ListItemIcon>
                        <CheckCircleIcon color="info" fontSize="small" />
                      </ListItemIcon>
                      <ListItemText primary={item} sx={{ "& .MuiListItemText-primary": { color: "grey.300" } }} />
                    </ListItem>
                  ))}
                </List>
              </Paper>

              <Paper sx={{ p: 2.5, mb: 3, bgcolor: "#0f1422", borderRadius: 2 }}>
                <Typography variant="h6" sx={{ color: "#0ea5e9", mb: 1 }}>
                  PCAP Checklist
                </Typography>
                <List dense>
                  {pcapChecklist.map((item) => (
                    <ListItem key={item}>
                      <ListItemIcon>
                        <CheckCircleIcon color="success" fontSize="small" />
                      </ListItemIcon>
                      <ListItemText primary={item} sx={{ "& .MuiListItemText-primary": { color: "grey.300" } }} />
                    </ListItem>
                  ))}
                </List>
              </Paper>

              <Paper sx={{ p: 2.5, mb: 3, bgcolor: "#0f1422", borderRadius: 2 }}>
                <Typography variant="h6" sx={{ color: "#0ea5e9", mb: 1 }}>
                  Artifacts to Save
                </Typography>
                <List dense>
                  {labArtifacts.map((item) => (
                    <ListItem key={item}>
                      <ListItemIcon>
                        <CheckCircleIcon color="info" fontSize="small" />
                      </ListItemIcon>
                      <ListItemText primary={item} sx={{ "& .MuiListItemText-primary": { color: "grey.300" } }} />
                    </ListItem>
                  ))}
                </List>
              </Paper>

              <Paper sx={{ p: 2.5, mb: 3, bgcolor: "#0f1422", borderRadius: 2 }}>
                <Typography variant="h6" sx={{ color: "#f59e0b", mb: 1 }}>
                  Safe Boundaries
                </Typography>
                <List dense>
                  {safeBoundaries.map((item) => (
                    <ListItem key={item}>
                      <ListItemIcon>
                        <WarningIcon color="warning" fontSize="small" />
                      </ListItemIcon>
                      <ListItemText primary={item} sx={{ "& .MuiListItemText-primary": { color: "grey.300" } }} />
                    </ListItem>
                  ))}
                </List>
              </Paper>

              <Accordion sx={{ bgcolor: "#0f1422", borderRadius: 2, mb: 1 }}>
                <AccordionSummary expandIcon={<ExpandMoreIcon />}>
                  <Typography variant="h6">Baseline Notes Template</Typography>
                </AccordionSummary>
                <AccordionDetails>
                  <CodeBlock code={baselineTemplate} language="markdown" />
                </AccordionDetails>
              </Accordion>

              <Accordion>
                <AccordionSummary expandIcon={<ExpandMoreIcon />}>
                  <Typography variant="h6">Capture Commands (Read-only)</Typography>
                </AccordionSummary>
                <AccordionDetails>
                  <CodeBlock
                    language="bash"
                    code={`# Capture lab traffic for review (Linux/macOS)
sudo tcpdump -i eth0 -w lab.pcap

# Filter for TCP handshakes in a capture
tshark -r lab.pcap -Y "tcp.flags.syn==1 && tcp.flags.ack==0" -T fields -e ip.src -e ip.dst

# DNS response size review
tshark -r lab.pcap -Y "dns.flags.response==1" -T fields -e dns.qry.name -e dns.len`}
                  />
                </AccordionDetails>
              </Accordion>
            </Box>
          </TabPanel>
        </Paper>

        <Box sx={{ mt: 4, textAlign: "center" }}>
          <Button
            variant="outlined"
            startIcon={<ArrowBackIcon />}
            onClick={() => navigate("/learn")}
            sx={{ borderColor: "#0ea5e9", color: "#0ea5e9" }}
          >
            Back to Learning Hub
          </Button>
        </Box>

        {/* Scroll to Top Button */}
        <Zoom in={showScrollTop}>
          <Fab
            color="primary"
            size="small"
            onClick={scrollToTop}
            sx={{
              position: 'fixed',
              bottom: 24,
              right: 24,
              bgcolor: '#0ea5e9',
              '&:hover': { bgcolor: '#0284c7' }
            }}
          >
            <KeyboardArrowUp />
          </Fab>
        </Zoom>
      </Container>
    </Box>
    </LearnPageLayout>
  );
};

export default NetworkProtocolExploitationPage;
