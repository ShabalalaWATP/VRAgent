import React, { useState } from "react";
import {
  Box,
  Container,
  Typography,
  Paper,
  Tabs,
  Tab,
  Chip,
  Button,
  Accordion,
  AccordionSummary,
  AccordionDetails,
  Grid,
  List,
  ListItem,
  ListItemIcon,
  ListItemText,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  IconButton,
  Tooltip,
  Alert,
} from "@mui/material";
import ArrowBackIcon from "@mui/icons-material/ArrowBack";
import ExpandMoreIcon from "@mui/icons-material/ExpandMore";
import ContentCopyIcon from "@mui/icons-material/ContentCopy";
import RouterIcon from "@mui/icons-material/Router";
import SecurityIcon from "@mui/icons-material/Security";
import ShieldIcon from "@mui/icons-material/Shield";
import WarningIcon from "@mui/icons-material/Warning";
import CheckCircleIcon from "@mui/icons-material/CheckCircle";
import SearchIcon from "@mui/icons-material/Search";
import TuneIcon from "@mui/icons-material/Tune";
import StorageIcon from "@mui/icons-material/Storage";
import BuildIcon from "@mui/icons-material/Build";
import { useNavigate } from "react-router-dom";
import LearnPageLayout from "../components/LearnPageLayout";

interface TabPanelProps {
  children?: React.ReactNode;
  index: number;
  value: number;
}

function TabPanel(props: TabPanelProps) {
  const { children, value, index, ...other } = props;
  return (
    <div role="tabpanel" hidden={value !== index} {...other}>
      {value === index && <Box sx={{ py: 3 }}>{children}</Box>}
    </div>
  );
}

const CodeBlock: React.FC<{ code: string; language?: string }> = ({
  code,
  language = "bash",
}) => {
  const [copied, setCopied] = useState(false);

  const handleCopy = () => {
    navigator.clipboard.writeText(code);
    setCopied(true);
    setTimeout(() => setCopied(false), 2000);
  };

  return (
    <Paper
      sx={{
        p: 2,
        bgcolor: "#101626",
        borderRadius: 2,
        position: "relative",
        my: 2,
        border: "1px solid rgba(14, 165, 233, 0.3)",
      }}
    >
      <Box sx={{ position: "absolute", top: 8, right: 8, display: "flex", gap: 1 }}>
        <Chip label={language} size="small" sx={{ bgcolor: "#0ea5e9", color: "#0b1020" }} />
        <Tooltip title={copied ? "Copied!" : "Copy"}>
          <IconButton size="small" onClick={handleCopy} sx={{ color: "#e2e8f0" }}>
            <ContentCopyIcon fontSize="small" />
          </IconButton>
        </Tooltip>
      </Box>
      <Box
        component="pre"
        sx={{
          m: 0,
          overflow: "auto",
          fontFamily: "monospace",
          fontSize: "0.85rem",
          color: "#e2e8f0",
          pt: 2,
        }}
      >
        {code}
      </Box>
    </Paper>
  );
};

const NetworkProtocolExploitationPage: React.FC = () => {
  const navigate = useNavigate();
  const [tabValue, setTabValue] = useState(0);

  const objectives = [
    "Explain how protocol design choices create security risk.",
    "Recognize common exploitation themes across TCP, UDP, DNS, TLS, and SMB.",
    "Map weaknesses to detection signals and logging sources.",
    "Prioritize hardening actions that reduce protocol attack surface.",
    "Practice safe, read-only analysis in a lab environment.",
  ];
  const beginnerPath = [
    "1) Review the glossary and protocol map.",
    "2) Learn the top exploitation patterns at a high level.",
    "3) Connect each pattern to a detection signal.",
    "4) Apply the hardening checklist to your environment.",
    "5) Run the safe lab walkthrough and document normal baselines.",
  ];
  const glossary = [
    { term: "Handshake", desc: "Initial exchange that sets up a connection or session." },
    { term: "Stateful", desc: "Protocol that tracks session state on both ends." },
    { term: "Stateless", desc: "Protocol with no session memory between packets." },
    { term: "Downgrade", desc: "Forcing a weaker protocol version or cipher." },
    { term: "Amplification", desc: "Small request triggers a much larger response." },
    { term: "Parsing", desc: "How a system reads and interprets protocol data." },
    { term: "ALPN", desc: "TLS extension used to negotiate application protocols (HTTP/2 vs HTTP/1.1)." },
    { term: "Fragmentation", desc: "Splitting packets across the network to fit MTU limits." },
    { term: "Replay", desc: "Reusing captured traffic to impersonate a valid session." },
    { term: "Signature", desc: "Cryptographic integrity check that proves data was not modified." },
    { term: "Session resumption", desc: "Reusing prior TLS session parameters to reduce handshake overhead." },
  ];
  const scenarios = [
    "Legacy protocols left enabled for convenience.",
    "Management services exposed to untrusted networks.",
    "Inconsistent parsing between proxies and backends.",
    "Weak authentication on internal protocols.",
    "Misconfigured DNS or UDP services allowing amplification.",
    "Overly permissive firewall rules for internal services.",
    "Outdated appliances or firmware with protocol bugs.",
  ];

  const protocolMap = [
    {
      protocol: "TCP",
      layer: "L4",
      ports: "Any",
      weakness: "State exhaustion, weak timeouts, backlog pressure.",
      defense: "SYN cookies, connection limits, tuned timeouts.",
      detection: "SYN_RECV spikes, retransmits, backlog drops.",
    },
    {
      protocol: "UDP",
      layer: "L4",
      ports: "Any",
      weakness: "Spoofing, reflection, no handshake.",
      defense: "Ingress filtering, rate limits, restrict exposure.",
      detection: "Asymmetric traffic, response size spikes.",
    },
    {
      protocol: "ICMP",
      layer: "L3",
      ports: "N/A",
      weakness: "Recon, abuse of error messages, floods.",
      defense: "Rate limit, monitor, block where unnecessary.",
      detection: "ICMP bursts, unreachable storms.",
    },
    {
      protocol: "DNS",
      layer: "L7",
      ports: "53 UDP/TCP",
      weakness: "Open recursion, cache poisoning, large responses.",
      defense: "Restrict recursion, DNSSEC, response rate limiting.",
      detection: "Large responses, NXDOMAIN spikes, resolver changes.",
    },
    {
      protocol: "TLS",
      layer: "L7",
      ports: "443, 465, 993",
      weakness: "Downgrade, weak ciphers, expired certs.",
      defense: "Disable legacy, enforce strong cipher suites.",
      detection: "Legacy versions, handshake failures, cert errors.",
    },
    {
      protocol: "HTTP",
      layer: "L7",
      ports: "80/443",
      weakness: "Parser confusion, header ambiguity, smuggling risk.",
      defense: "Normalize proxies, strict parsing, patch gateways.",
      detection: "400/431 errors, conflicting length headers.",
    },
    {
      protocol: "HTTP/2",
      layer: "L7",
      ports: "443",
      weakness: "Stream abuse, header compression edge cases.",
      defense: "Limit streams, patch proxies, enforce H2 settings.",
      detection: "RST_STREAM spikes, H2 errors in logs.",
    },
    {
      protocol: "SMB",
      layer: "L7",
      ports: "445",
      weakness: "Legacy versions, weak signing, lateral movement.",
      defense: "Disable SMBv1, enforce signing, limit exposure.",
      detection: "Unsigned sessions, new SMB access paths.",
    },
    {
      protocol: "Kerberos",
      layer: "L7",
      ports: "88 TCP/UDP",
      weakness: "Ticket abuse, time sync issues, delegation misconfig.",
      defense: "Harden time sync, limit delegation, monitor tickets.",
      detection: "Pre-auth failures, unusual ticket lifetimes.",
    },
    {
      protocol: "LDAP",
      layer: "L7",
      ports: "389/636",
      weakness: "Cleartext binds, anonymous access, overbroad reads.",
      defense: "Require LDAPS, disable anonymous, least privilege.",
      detection: "Simple binds from new hosts, large directory reads.",
    },
    {
      protocol: "SSH",
      layer: "L7",
      ports: "22",
      weakness: "Weak keys, password brute force, legacy ciphers.",
      defense: "Disable password auth, enforce strong keys, rate limit.",
      detection: "Auth failures, new key usage, new source IPs.",
    },
    {
      protocol: "RDP",
      layer: "L7",
      ports: "3389",
      weakness: "Exposed service, weak auth, NLA disabled.",
      defense: "Restrict access, enforce NLA, MFA, jump hosts.",
      detection: "Failed logons, lockouts, new source IPs.",
    },
    {
      protocol: "SNMP",
      layer: "L7",
      ports: "161/162 UDP",
      weakness: "Default communities, unauth management.",
      defense: "Use SNMPv3, restrict to management VLANs.",
      detection: "Community use, queries from unknown IPs.",
    },
    {
      protocol: "NTP",
      layer: "L7",
      ports: "123 UDP",
      weakness: "Amplification, exposed control queries.",
      defense: "Restrict access, disable legacy modes, rate limits.",
      detection: "Large NTP responses, spikes to port 123.",
    },
    {
      protocol: "DHCP",
      layer: "L7",
      ports: "67/68 UDP",
      weakness: "Rogue servers, IP conflicts, starvation.",
      defense: "DHCP snooping, trusted ports only.",
      detection: "Multiple offers, lease spikes, unknown servers.",
    },
  ];

  const exposureChecklist = [
    "Inventory all listening services and map them to owners.",
    "Verify management ports are restricted to admin networks.",
    "Confirm DNS recursion is limited to trusted clients.",
    "Disable legacy protocols (SMBv1, TLS 1.0/1.1, Telnet).",
    "Rate-limit or shield UDP services that can amplify traffic.",
  ];

  const exploitationPatterns = [
    {
      title: "State Exhaustion",
      desc: "Consume server resources by creating many partial or long-lived sessions.",
      impact: "Service slowdown, dropped connections, noisy alerts.",
      signals: "High SYN_RECV, backlog full, spikes in half-open connections.",
      defense: "Enable SYN cookies and apply connection limits.",
    },
    {
      title: "Reflection and Amplification",
      desc: "Abuse UDP services to multiply traffic using spoofed source IPs.",
      impact: "Bandwidth saturation and upstream throttling.",
      signals: "Large response bursts, asymmetric traffic, spikes from UDP services.",
      defense: "Disable amplification vectors and enforce egress filtering.",
    },
    {
      title: "Downgrade Paths",
      desc: "Force older protocol versions or weaker ciphers.",
      impact: "Weaker encryption and easier interception.",
      signals: "Legacy negotiation, weak cipher usage, TLS alerts.",
      defense: "Disable legacy versions and enforce modern suites.",
    },
    {
      title: "Parser Mismatch",
      desc: "Exploit inconsistent protocol parsing between systems.",
      impact: "Desync between proxy and backend, policy bypass.",
      signals: "Conflicting length headers, malformed requests, proxy errors.",
      defense: "Keep parsers aligned and patch gateway software.",
    },
    {
      title: "Unauthenticated Management",
      desc: "Expose admin or control planes without strong auth.",
      impact: "Config changes, data exposure, or service takeover.",
      signals: "Access to management ports from untrusted ranges.",
      defense: "Restrict management interfaces and require MFA.",
    },
    {
      title: "Cleartext Authentication",
      desc: "Credentials sent without encryption on legacy services.",
      impact: "Credentials visible on the wire and easy to reuse.",
      signals: "Credentials visible in packet captures, basic auth usage.",
      defense: "Require TLS and disable cleartext protocols.",
    },
    {
      title: "Name Resolution Manipulation",
      desc: "Abuse DNS or DHCP behavior to redirect traffic.",
      impact: "Users connect to unintended hosts or services.",
      signals: "Resolver changes, DNS anomalies, rogue DHCP offers.",
      defense: "DHCP snooping, DNSSEC, trusted resolvers.",
    },
    {
      title: "Weak Signing or Integrity",
      desc: "Traffic without signing can be modified or replayed.",
      impact: "Session tampering, relay, or unauthorized actions.",
      signals: "Unsigned sessions, policy downgrades, integrity alerts.",
      defense: "Require signing and strong integrity settings.",
    },
  ];

  const detectionSignals = [
    "Unusual spikes in half-open TCP connections.",
    "Large UDP responses to small requests.",
    "Legacy protocol versions negotiated unexpectedly.",
    "Repeated parser or handshake errors in logs.",
    "Management services reachable from the wrong networks.",
    "Unexpected broadcast or multicast traffic.",
    "Authentication attempts on legacy services.",
    "Sudden increase in DNS NXDOMAIN or SERVFAIL responses.",
    "New services listening on critical ports.",
    "Handshake retries or resets outside normal baselines.",
  ];

  const telemetrySources = [
    "Firewall and load balancer logs for connection patterns.",
    "Packet captures (Wireshark, tcpdump) for protocol anomalies.",
    "TLS termination logs for negotiated ciphers and versions.",
    "DNS resolver logs for recursion and response size spikes.",
    "EDR or host logs for service restarts and crashes.",
    "NetFlow or sFlow summaries for traffic volume changes.",
    "IDS/IPS alerts for malformed packets or protocol abuse.",
  ];

  const detectionMatrix = [
    {
      stage: "Discovery",
      signal: "Burst of scans or probes to protocol-specific ports.",
      evidence: "Firewall logs and flow data.",
    },
    {
      stage: "Negotiation",
      signal: "Downgrade attempts or handshake failures.",
      evidence: "TLS logs, proxy errors, server logs.",
    },
    {
      stage: "Abuse",
      signal: "Resource spikes or malformed packets.",
      evidence: "System metrics, IDS alerts, packet captures.",
    },
    {
      stage: "Impact",
      signal: "Service instability or access anomalies.",
      evidence: "Service health checks and incident tickets.",
    },
  ];

  const baselineMetrics = [
    {
      metric: "Half-open TCP connections",
      normal: "Low and stable for each service.",
      investigate: "Sustained spike or backlog warnings.",
    },
    {
      metric: "UDP response size",
      normal: "Consistent with known services.",
      investigate: "Large bursts or sudden growth in size.",
    },
    {
      metric: "TLS version usage",
      normal: "Mostly TLS 1.2+ with modern ciphers.",
      investigate: "Unexpected TLS 1.0/1.1 or weak cipher use.",
    },
    {
      metric: "DNS error rates",
      normal: "Stable NXDOMAIN and SERVFAIL rates.",
      investigate: "Sudden spikes or resolver changes.",
    },
    {
      metric: "Auth failures by service",
      normal: "Predictable pattern per business hours.",
      investigate: "Sudden bursts or new source IPs.",
    },
    {
      metric: "Protocol parsing errors",
      normal: "Low and consistent error rate.",
      investigate: "Repeated 400/431 or protocol errors.",
    },
  ];

  const triageSteps = [
    "Confirm the affected service and scope (which ports, which hosts).",
    "Compare to baseline for the same time window.",
    "Review the last 24 hours of configuration changes.",
    "Check upstream devices (load balancers, firewalls) for errors.",
    "Capture a small packet sample for validation if approved.",
  ];

  const logQueries = [
    {
      label: "Splunk: legacy TLS versions",
      language: "splunk",
      query:
        "index=tls (ssl_version=\"TLS 1.0\" OR ssl_version=\"TLS 1.1\") | stats count by dest, ssl_version",
    },
    {
      label: "KQL: large UDP responses",
      language: "kql",
      query:
        "DeviceNetworkEvents\n| where Protocol == \"Udp\"\n| where SentBytes > 5000 and ReceivedBytes < 200\n| summarize count() by RemotePort, RemoteIP",
    },
    {
      label: "Nginx: parsing errors",
      language: "bash",
      query: "awk '$9 ~ /400|414|431/' /var/log/nginx/access.log | head -n 20",
    },
    {
      label: "DNS logs: response size spike",
      language: "text",
      query:
        "Filter on response size and error codes.\nLook for large answers, SERVFAIL spikes, or new resolvers.",
    },
  ];

  const hardeningChecklist = [
    "Disable legacy protocols and weak cipher suites.",
    "Limit management services to dedicated admin networks.",
    "Apply protocol-aware rate limits and connection caps.",
    "Patch gateways, proxies, and protocol libraries regularly.",
    "Enable authentication and signing where supported.",
    "Use segmentation to reduce lateral movement paths.",
    "Monitor protocol negotiation and error rates.",
    "Document normal protocol baselines for quick detection.",
    "Enable egress filtering to reduce spoofing risk.",
    "Standardize TLS policy across all entry points.",
  ];

  const hardeningTracks = [
    {
      title: "Transport Layer",
      items: [
        "Enable SYN cookies and tune timeouts.",
        "Set connection and rate limits for exposed services.",
        "Drop malformed packets early at the edge.",
      ],
    },
    {
      title: "Name Resolution",
      items: [
        "Restrict DNS recursion to trusted clients.",
        "Enable DNSSEC validation where possible.",
        "Monitor resolver changes and response size.",
      ],
    },
    {
      title: "Identity and Auth",
      items: [
        "Require LDAPS and disable anonymous binds.",
        "Enforce Kerberos time sync and limit delegation.",
        "Disable weak auth or legacy fallback methods.",
      ],
    },
    {
      title: "Management and Remote Access",
      items: [
        "Place SSH/RDP behind a jump host or VPN.",
        "Require MFA for admin access.",
        "Restrict management ports to admin networks.",
      ],
    },
    {
      title: "Monitoring and Logging",
      items: [
        "Log protocol version and cipher usage.",
        "Alert on parsing errors and handshake failures.",
        "Keep flow baselines for critical services.",
      ],
    },
  ];

  const legacyDeprecations = [
    {
      protocol: "SMBv1",
      risk: "Legacy protocol with weak security controls.",
      action: "Disable across clients and servers.",
    },
    {
      protocol: "TLS 1.0/1.1",
      risk: "Weak ciphers and downgrade exposure.",
      action: "Disable at load balancers and servers.",
    },
    {
      protocol: "SNMPv1/v2c",
      risk: "Unauthenticated community strings.",
      action: "Move to SNMPv3 and restrict access.",
    },
    {
      protocol: "Telnet/FTP",
      risk: "Cleartext credentials and data.",
      action: "Replace with SSH/SFTP.",
    },
    {
      protocol: "LLMNR/NBT-NS",
      risk: "Name resolution abuse on local networks.",
      action: "Disable where policy allows.",
    },
  ];

  const safeChecks = `# Windows: summarize TCP states
Get-NetTCPConnection | Group-Object State | Sort-Object Count -Descending

# Windows: show listening ports (top 10)
Get-NetTCPConnection -State Listen | Select-Object -First 10

# Windows: show UDP listeners (top 10)
Get-NetUDPEndpoint | Select-Object -First 10

# Linux: socket summary
ss -s

# Linux: list half-open connections
ss -ant state syn-recv

# Linux: list listening TCP and UDP ports
ss -lntup

# macOS: protocol statistics (summary)
netstat -s | head -n 20`;

  const labSteps = [
    "Create an isolated lab with two VMs (client and server).",
    "Record baseline listening ports and services.",
    "Generate normal traffic: ping, DNS lookup, and a simple HTTP request.",
    "Capture traffic in Wireshark or tcpdump for 1-2 minutes.",
    "Label handshake stages in the capture (SYN, SYN-ACK, ACK).",
    "Find a DNS query and note response size and TTL.",
    "Identify a TLS handshake and record version and cipher (if present).",
    "Compare how TCP and UDP handle state and retransmissions.",
    "Write down what normal looks like for future baselines.",
  ];
  const labExercises = [
    "Locate one TCP handshake and one UDP exchange in the capture.",
    "Measure the largest UDP response and document the service.",
    "List all unique destination ports seen in 2 minutes.",
    "Note any malformed or reset connections and their source.",
  ];
  const pcapChecklist = [
    "Handshake packets labeled and annotated.",
    "DNS query and response pair recorded.",
    "TLS version and cipher recorded if applicable.",
    "Top talkers by bytes listed.",
    "Any errors or resets noted with timestamps.",
  ];
  const labArtifacts = [
    "lab.pcap",
    "baseline-notes.md",
    "screenshot of key Wireshark filters",
  ];
  const baselineTemplate = `# Protocol Baseline Notes
Date:
Environment:

Listening services (host:port):
- 

TLS policy observed:
- Versions:
- Ciphers:

DNS baseline:
- Resolver IPs:
- Typical response size range:

Anomalies observed:
- 
`;
  const safeBoundaries = [
    "Only test in a lab or with explicit written authorization.",
    "Do not run exploit tools on production or public networks.",
    "Avoid scanning external IP ranges without approval.",
    "Focus on observation, logging, and defensive verification.",
    "Use synthetic traffic and lab-only accounts.",
  ];

  const pageContext = `This page covers network protocol exploitation techniques including attacks on TCP/IP, DNS, DHCP, SMB, SNMP, and other common protocols. Topics include protocol weaknesses, man-in-the-middle attacks, spoofing, injection, and defensive hardening measures.`;

  return (
    <LearnPageLayout pageTitle="Network Protocol Exploitation" pageContext={pageContext}>
    <Box sx={{ minHeight: "100vh", bgcolor: "#0b101a", py: 4 }}>
      <Container maxWidth="lg">
        <Button startIcon={<ArrowBackIcon />} onClick={() => navigate("/learn")} sx={{ mb: 2, color: "grey.400" }}>
          Back to Learn Hub
        </Button>

        <Box sx={{ display: "flex", alignItems: "center", gap: 2, mb: 2 }}>
          <RouterIcon sx={{ fontSize: 42, color: "#0ea5e9" }} />
          <Typography
            variant="h3"
            sx={{
              fontWeight: 700,
              background: "linear-gradient(135deg, #0ea5e9 0%, #f59e0b 100%)",
              backgroundClip: "text",
              WebkitBackgroundClip: "text",
              color: "transparent",
            }}
          >
            Network Protocol Exploitation
          </Typography>
        </Box>
        <Typography variant="h6" sx={{ color: "grey.400", mb: 2 }}>
          Learn how protocol weaknesses are abused and how to detect and harden against them.
        </Typography>

        <Alert severity="warning" sx={{ mb: 3 }}>
          This page is for defensive education and authorized security testing only.
        </Alert>

        <Paper sx={{ p: 2.5, mb: 3, bgcolor: "#0f1422", borderRadius: 2 }}>
          <Typography variant="body1" sx={{ color: "grey.300", mb: 1 }}>
            Network protocols are designed for reliability and interoperability, not for security first. Attackers
            exploit those design gaps by abusing state, forcing downgrades, or leveraging inconsistent parsing. This
            guide focuses on the most common protocol exploitation themes and how to defend against them.
          </Typography>
          <Typography variant="body2" sx={{ color: "grey.400" }}>
            The goal is not to teach offensive tradecraft. Instead, you will learn what to monitor, how to harden
            services, and how to validate configurations safely in a lab.
          </Typography>
        </Paper>

        <Box sx={{ display: "flex", gap: 1, flexWrap: "wrap", mb: 3 }}>
          <Chip icon={<RouterIcon />} label="TCP" size="small" />
          <Chip icon={<RouterIcon />} label="UDP" size="small" />
          <Chip icon={<StorageIcon />} label="DNS" size="small" />
          <Chip icon={<SecurityIcon />} label="TLS" size="small" />
          <Chip icon={<ShieldIcon />} label="SMB" size="small" />
          <Chip icon={<RouterIcon />} label="RDP" size="small" />
          <Chip icon={<RouterIcon />} label="SSH" size="small" />
          <Chip icon={<SearchIcon />} label="Detection" size="small" />
        </Box>

        <Paper sx={{ bgcolor: "#111826", borderRadius: 2 }}>
          <Tabs
            value={tabValue}
            onChange={(_, v) => setTabValue(v)}
            variant="scrollable"
            scrollButtons="auto"
            sx={{
              borderBottom: "1px solid rgba(255,255,255,0.08)",
              "& .MuiTab-root": { color: "grey.400" },
              "& .Mui-selected": { color: "#0ea5e9" },
            }}
          >
            <Tab icon={<SecurityIcon />} label="Overview" />
            <Tab icon={<StorageIcon />} label="Protocol Map" />
            <Tab icon={<TuneIcon />} label="Exploitation Patterns" />
            <Tab icon={<SearchIcon />} label="Detection" />
            <Tab icon={<ShieldIcon />} label="Hardening" />
            <Tab icon={<BuildIcon />} label="Safe Lab" />
          </Tabs>

          <TabPanel value={tabValue} index={0}>
            <Box sx={{ p: 3 }}>
              <Paper sx={{ p: 2.5, mb: 3, bgcolor: "#0f1422", borderRadius: 2 }}>
                <Typography variant="h6" sx={{ color: "#0ea5e9", mb: 1 }}>
                  Learning Objectives
                </Typography>
                <List dense>
                  {objectives.map((item) => (
                    <ListItem key={item}>
                      <ListItemIcon>
                        <CheckCircleIcon color="info" fontSize="small" />
                      </ListItemIcon>
                      <ListItemText primary={item} sx={{ "& .MuiListItemText-primary": { color: "grey.300" } }} />
                    </ListItem>
                  ))}
                </List>
              </Paper>

              <Paper sx={{ p: 2.5, mb: 3, bgcolor: "#0f1422", borderRadius: 2 }}>
                <Typography variant="h6" sx={{ color: "#0ea5e9", mb: 1 }}>
                  Beginner Path
                </Typography>
                <List dense>
                  {beginnerPath.map((item) => (
                    <ListItem key={item}>
                      <ListItemIcon>
                        <CheckCircleIcon color="info" fontSize="small" />
                      </ListItemIcon>
                      <ListItemText primary={item} sx={{ "& .MuiListItemText-primary": { color: "grey.300" } }} />
                    </ListItem>
                  ))}
                </List>
              </Paper>

              <Paper sx={{ p: 2.5, mb: 3, bgcolor: "#0f1422", borderRadius: 2 }}>
                <Typography variant="h6" sx={{ color: "#f59e0b", mb: 1 }}>
                  Quick Glossary
                </Typography>
                <TableContainer>
                  <Table size="small">
                    <TableHead>
                      <TableRow>
                        <TableCell sx={{ color: "#f59e0b" }}>Term</TableCell>
                        <TableCell sx={{ color: "#f59e0b" }}>Meaning</TableCell>
                      </TableRow>
                    </TableHead>
                    <TableBody>
                      {glossary.map((item) => (
                        <TableRow key={item.term}>
                          <TableCell sx={{ color: "grey.200", fontWeight: 600 }}>{item.term}</TableCell>
                          <TableCell sx={{ color: "grey.400" }}>{item.desc}</TableCell>
                        </TableRow>
                      ))}
                    </TableBody>
                  </Table>
                </TableContainer>
              </Paper>

              <Paper sx={{ p: 2.5, bgcolor: "#0f1422", borderRadius: 2 }}>
                <Typography variant="h6" sx={{ color: "#0ea5e9", mb: 1 }}>
                  Where Protocol Exploitation Shows Up
                </Typography>
                <List dense>
                  {scenarios.map((item) => (
                    <ListItem key={item}>
                      <ListItemIcon>
                        <WarningIcon color="warning" fontSize="small" />
                      </ListItemIcon>
                      <ListItemText primary={item} sx={{ "& .MuiListItemText-primary": { color: "grey.300" } }} />
                    </ListItem>
                  ))}
                </List>
              </Paper>
            </Box>
          </TabPanel>

          <TabPanel value={tabValue} index={1}>
            <Box sx={{ p: 3 }}>
              <TableContainer sx={{ mb: 3, overflowX: "auto" }}>
                <Table size="small">
                  <TableHead>
                    <TableRow>
                      <TableCell sx={{ color: "#0ea5e9" }}>Protocol</TableCell>
                      <TableCell sx={{ color: "#0ea5e9" }}>Layer</TableCell>
                      <TableCell sx={{ color: "#0ea5e9" }}>Ports</TableCell>
                      <TableCell sx={{ color: "#0ea5e9" }}>Common Weakness</TableCell>
                      <TableCell sx={{ color: "#0ea5e9" }}>Defensive Focus</TableCell>
                      <TableCell sx={{ color: "#0ea5e9" }}>Detection Focus</TableCell>
                    </TableRow>
                  </TableHead>
                  <TableBody>
                    {protocolMap.map((item) => (
                      <TableRow key={item.protocol}>
                        <TableCell sx={{ color: "grey.200", fontWeight: 600 }}>{item.protocol}</TableCell>
                        <TableCell sx={{ color: "grey.400" }}>{item.layer}</TableCell>
                        <TableCell sx={{ color: "grey.400" }}>{item.ports}</TableCell>
                        <TableCell sx={{ color: "grey.400" }}>{item.weakness}</TableCell>
                        <TableCell sx={{ color: "grey.400" }}>{item.defense}</TableCell>
                        <TableCell sx={{ color: "grey.400" }}>{item.detection}</TableCell>
                      </TableRow>
                    ))}
                  </TableBody>
                </Table>
              </TableContainer>

              <Paper sx={{ p: 2.5, bgcolor: "#0f1422", borderRadius: 2 }}>
                <Typography variant="h6" sx={{ color: "#0ea5e9", mb: 1 }}>
                  Exposure Checklist
                </Typography>
                <List dense>
                  {exposureChecklist.map((item) => (
                    <ListItem key={item}>
                      <ListItemIcon>
                        <CheckCircleIcon color="info" fontSize="small" />
                      </ListItemIcon>
                      <ListItemText primary={item} sx={{ "& .MuiListItemText-primary": { color: "grey.300" } }} />
                    </ListItem>
                  ))}
                </List>
              </Paper>
            </Box>
          </TabPanel>

          <TabPanel value={tabValue} index={2}>
            <Box sx={{ p: 3 }}>
              <Grid container spacing={2}>
                {exploitationPatterns.map((item) => (
                  <Grid item xs={12} md={6} key={item.title}>
                    <Paper
                      sx={{
                        p: 2,
                        bgcolor: "#0f1422",
                        borderRadius: 2,
                        border: "1px solid rgba(245, 158, 11, 0.2)",
                        height: "100%",
                      }}
                    >
                      <Typography variant="subtitle1" sx={{ color: "#e2e8f0", fontWeight: 600 }}>
                        {item.title}
                      </Typography>
                      <Typography variant="body2" sx={{ color: "grey.400", mb: 1 }}>
                        {item.desc}
                      </Typography>
                      <Typography variant="caption" sx={{ color: "#f59e0b", display: "block" }}>
                        Impact: {item.impact}
                      </Typography>
                      <Typography variant="caption" sx={{ color: "#fbbf24", display: "block" }}>
                        Signals: {item.signals}
                      </Typography>
                      <Typography variant="caption" sx={{ color: "#94a3b8", display: "block" }}>
                        Defense: {item.defense}
                      </Typography>
                    </Paper>
                  </Grid>
                ))}
              </Grid>
            </Box>
          </TabPanel>

          <TabPanel value={tabValue} index={3}>
            <Box sx={{ p: 3 }}>
              <Paper sx={{ p: 2.5, mb: 3, bgcolor: "#0f1422", borderRadius: 2 }}>
                <Typography variant="h6" sx={{ color: "#0ea5e9", mb: 1 }}>
                  Detection Signals
                </Typography>
                <List dense>
                  {detectionSignals.map((item) => (
                    <ListItem key={item}>
                      <ListItemIcon>
                        <CheckCircleIcon color="info" fontSize="small" />
                      </ListItemIcon>
                      <ListItemText primary={item} sx={{ "& .MuiListItemText-primary": { color: "grey.300" } }} />
                    </ListItem>
                  ))}
                </List>
              </Paper>

              <Paper sx={{ p: 2.5, mb: 3, bgcolor: "#0f1422", borderRadius: 2 }}>
                <Typography variant="h6" sx={{ color: "#0ea5e9", mb: 1 }}>
                  Telemetry Sources
                </Typography>
                <List dense>
                  {telemetrySources.map((item) => (
                    <ListItem key={item}>
                      <ListItemIcon>
                        <CheckCircleIcon color="success" fontSize="small" />
                      </ListItemIcon>
                      <ListItemText primary={item} sx={{ "& .MuiListItemText-primary": { color: "grey.300" } }} />
                    </ListItem>
                  ))}
                </List>
              </Paper>

              <Paper sx={{ p: 2.5, mb: 3, bgcolor: "#0f1422", borderRadius: 2 }}>
                <Typography variant="h6" sx={{ color: "#0ea5e9", mb: 1 }}>
                  Detection Matrix (Simple)
                </Typography>
                <TableContainer>
                  <Table size="small">
                    <TableHead>
                      <TableRow>
                        <TableCell sx={{ color: "#93c5fd" }}>Stage</TableCell>
                        <TableCell sx={{ color: "#93c5fd" }}>Signal</TableCell>
                        <TableCell sx={{ color: "#93c5fd" }}>Evidence</TableCell>
                      </TableRow>
                    </TableHead>
                    <TableBody>
                      {detectionMatrix.map((item) => (
                        <TableRow key={item.stage}>
                          <TableCell sx={{ color: "grey.200", fontWeight: 600 }}>{item.stage}</TableCell>
                          <TableCell sx={{ color: "grey.400" }}>{item.signal}</TableCell>
                          <TableCell sx={{ color: "grey.400" }}>{item.evidence}</TableCell>
                        </TableRow>
                      ))}
                    </TableBody>
                  </Table>
                </TableContainer>
              </Paper>

              <Paper sx={{ p: 2.5, mb: 3, bgcolor: "#0f1422", borderRadius: 2 }}>
                <Typography variant="h6" sx={{ color: "#0ea5e9", mb: 1 }}>
                  Baseline Metrics to Track
                </Typography>
                <TableContainer>
                  <Table size="small">
                    <TableHead>
                      <TableRow>
                        <TableCell sx={{ color: "#93c5fd" }}>Metric</TableCell>
                        <TableCell sx={{ color: "#93c5fd" }}>Normal</TableCell>
                        <TableCell sx={{ color: "#93c5fd" }}>Investigate When</TableCell>
                      </TableRow>
                    </TableHead>
                    <TableBody>
                      {baselineMetrics.map((item) => (
                        <TableRow key={item.metric}>
                          <TableCell sx={{ color: "grey.200", fontWeight: 600 }}>{item.metric}</TableCell>
                          <TableCell sx={{ color: "grey.400" }}>{item.normal}</TableCell>
                          <TableCell sx={{ color: "grey.400" }}>{item.investigate}</TableCell>
                        </TableRow>
                      ))}
                    </TableBody>
                  </Table>
                </TableContainer>
              </Paper>

              <Paper sx={{ p: 2.5, mb: 3, bgcolor: "#0f1422", borderRadius: 2 }}>
                <Typography variant="h6" sx={{ color: "#0ea5e9", mb: 1 }}>
                  Quick Triage Steps
                </Typography>
                <List dense>
                  {triageSteps.map((item) => (
                    <ListItem key={item}>
                      <ListItemIcon>
                        <CheckCircleIcon color="info" fontSize="small" />
                      </ListItemIcon>
                      <ListItemText primary={item} sx={{ "& .MuiListItemText-primary": { color: "grey.300" } }} />
                    </ListItem>
                  ))}
                </List>
              </Paper>

              {logQueries.map((item) => (
                <Accordion key={item.label} sx={{ bgcolor: "#0f1422", borderRadius: 2, mb: 1 }}>
                  <AccordionSummary expandIcon={<ExpandMoreIcon />}>
                    <Typography variant="h6">{item.label}</Typography>
                  </AccordionSummary>
                  <AccordionDetails>
                    <CodeBlock code={item.query} language={item.language} />
                  </AccordionDetails>
                </Accordion>
              ))}

              <Accordion>
                <AccordionSummary expandIcon={<ExpandMoreIcon />}>
                  <Typography variant="h6">Safe Read-only Checks</Typography>
                </AccordionSummary>
                <AccordionDetails>
                  <CodeBlock code={safeChecks} language="powershell" />
                </AccordionDetails>
              </Accordion>
            </Box>
          </TabPanel>

          <TabPanel value={tabValue} index={4}>
            <Box sx={{ p: 3 }}>
              <Paper sx={{ p: 2.5, mb: 3, bgcolor: "#0f1422", borderRadius: 2 }}>
                <Typography variant="h6" sx={{ color: "#0ea5e9", mb: 1 }}>
                  Hardening Checklist
                </Typography>
                <List dense>
                  {hardeningChecklist.map((item) => (
                    <ListItem key={item}>
                      <ListItemIcon>
                        <CheckCircleIcon color="info" fontSize="small" />
                      </ListItemIcon>
                      <ListItemText primary={item} sx={{ "& .MuiListItemText-primary": { color: "grey.300" } }} />
                    </ListItem>
                  ))}
                </List>
              </Paper>

              <Grid container spacing={2} sx={{ mb: 3 }}>
                {hardeningTracks.map((track) => (
                  <Grid item xs={12} md={6} key={track.title}>
                    <Paper sx={{ p: 2, bgcolor: "#0f1422", borderRadius: 2, height: "100%" }}>
                      <Typography variant="subtitle1" sx={{ color: "#e2e8f0", fontWeight: 600, mb: 1 }}>
                        {track.title}
                      </Typography>
                      <List dense>
                        {track.items.map((item) => (
                          <ListItem key={item}>
                            <ListItemIcon>
                              <CheckCircleIcon color="info" fontSize="small" />
                            </ListItemIcon>
                            <ListItemText primary={item} sx={{ "& .MuiListItemText-primary": { color: "grey.300" } }} />
                          </ListItem>
                        ))}
                      </List>
                    </Paper>
                  </Grid>
                ))}
              </Grid>

              <Paper sx={{ p: 2.5, mb: 3, bgcolor: "#0f1422", borderRadius: 2 }}>
                <Typography variant="h6" sx={{ color: "#0ea5e9", mb: 1 }}>
                  Legacy Deprecations to Plan
                </Typography>
                <TableContainer>
                  <Table size="small">
                    <TableHead>
                      <TableRow>
                        <TableCell sx={{ color: "#93c5fd" }}>Protocol</TableCell>
                        <TableCell sx={{ color: "#93c5fd" }}>Risk</TableCell>
                        <TableCell sx={{ color: "#93c5fd" }}>Recommended Action</TableCell>
                      </TableRow>
                    </TableHead>
                    <TableBody>
                      {legacyDeprecations.map((item) => (
                        <TableRow key={item.protocol}>
                          <TableCell sx={{ color: "grey.200", fontWeight: 600 }}>{item.protocol}</TableCell>
                          <TableCell sx={{ color: "grey.400" }}>{item.risk}</TableCell>
                          <TableCell sx={{ color: "grey.400" }}>{item.action}</TableCell>
                        </TableRow>
                      ))}
                    </TableBody>
                  </Table>
                </TableContainer>
              </Paper>

              <Paper sx={{ p: 2.5, bgcolor: "#0f1422", borderRadius: 2 }}>
                <Typography variant="h6" sx={{ color: "#f59e0b", mb: 1 }}>
                  Protocol Hardening Priorities
                </Typography>
                <List dense>
                  {[
                    "Remove unused services and close unused ports.",
                    "Enforce modern TLS policies and disable fallback.",
                    "Require signing and strong auth on internal protocols.",
                    "Put management services behind VPN or jump hosts.",
                    "Review firewall rules for protocol-specific exposure.",
                  ].map((item) => (
                    <ListItem key={item}>
                      <ListItemIcon>
                        <ShieldIcon color="warning" fontSize="small" />
                      </ListItemIcon>
                      <ListItemText primary={item} sx={{ "& .MuiListItemText-primary": { color: "grey.300" } }} />
                    </ListItem>
                  ))}
                </List>
              </Paper>
            </Box>
          </TabPanel>

          <TabPanel value={tabValue} index={5}>
            <Box sx={{ p: 3 }}>
              <Paper sx={{ p: 2.5, mb: 3, bgcolor: "#0f1422", borderRadius: 2 }}>
                <Typography variant="h6" sx={{ color: "#0ea5e9", mb: 1 }}>
                  Safe Lab Walkthrough
                </Typography>
                <List dense>
                  {labSteps.map((item) => (
                    <ListItem key={item}>
                      <ListItemIcon>
                        <CheckCircleIcon color="info" fontSize="small" />
                      </ListItemIcon>
                      <ListItemText primary={item} sx={{ "& .MuiListItemText-primary": { color: "grey.300" } }} />
                    </ListItem>
                  ))}
                </List>
              </Paper>

              <Paper sx={{ p: 2.5, mb: 3, bgcolor: "#0f1422", borderRadius: 2 }}>
                <Typography variant="h6" sx={{ color: "#0ea5e9", mb: 1 }}>
                  Mini Exercises
                </Typography>
                <List dense>
                  {labExercises.map((item) => (
                    <ListItem key={item}>
                      <ListItemIcon>
                        <CheckCircleIcon color="info" fontSize="small" />
                      </ListItemIcon>
                      <ListItemText primary={item} sx={{ "& .MuiListItemText-primary": { color: "grey.300" } }} />
                    </ListItem>
                  ))}
                </List>
              </Paper>

              <Paper sx={{ p: 2.5, mb: 3, bgcolor: "#0f1422", borderRadius: 2 }}>
                <Typography variant="h6" sx={{ color: "#0ea5e9", mb: 1 }}>
                  PCAP Checklist
                </Typography>
                <List dense>
                  {pcapChecklist.map((item) => (
                    <ListItem key={item}>
                      <ListItemIcon>
                        <CheckCircleIcon color="success" fontSize="small" />
                      </ListItemIcon>
                      <ListItemText primary={item} sx={{ "& .MuiListItemText-primary": { color: "grey.300" } }} />
                    </ListItem>
                  ))}
                </List>
              </Paper>

              <Paper sx={{ p: 2.5, mb: 3, bgcolor: "#0f1422", borderRadius: 2 }}>
                <Typography variant="h6" sx={{ color: "#0ea5e9", mb: 1 }}>
                  Artifacts to Save
                </Typography>
                <List dense>
                  {labArtifacts.map((item) => (
                    <ListItem key={item}>
                      <ListItemIcon>
                        <CheckCircleIcon color="info" fontSize="small" />
                      </ListItemIcon>
                      <ListItemText primary={item} sx={{ "& .MuiListItemText-primary": { color: "grey.300" } }} />
                    </ListItem>
                  ))}
                </List>
              </Paper>

              <Paper sx={{ p: 2.5, mb: 3, bgcolor: "#0f1422", borderRadius: 2 }}>
                <Typography variant="h6" sx={{ color: "#f59e0b", mb: 1 }}>
                  Safe Boundaries
                </Typography>
                <List dense>
                  {safeBoundaries.map((item) => (
                    <ListItem key={item}>
                      <ListItemIcon>
                        <WarningIcon color="warning" fontSize="small" />
                      </ListItemIcon>
                      <ListItemText primary={item} sx={{ "& .MuiListItemText-primary": { color: "grey.300" } }} />
                    </ListItem>
                  ))}
                </List>
              </Paper>

              <Accordion sx={{ bgcolor: "#0f1422", borderRadius: 2, mb: 1 }}>
                <AccordionSummary expandIcon={<ExpandMoreIcon />}>
                  <Typography variant="h6">Baseline Notes Template</Typography>
                </AccordionSummary>
                <AccordionDetails>
                  <CodeBlock code={baselineTemplate} language="markdown" />
                </AccordionDetails>
              </Accordion>

              <Accordion>
                <AccordionSummary expandIcon={<ExpandMoreIcon />}>
                  <Typography variant="h6">Capture Commands (Read-only)</Typography>
                </AccordionSummary>
                <AccordionDetails>
                  <CodeBlock
                    language="bash"
                    code={`# Capture lab traffic for review (Linux/macOS)
sudo tcpdump -i eth0 -w lab.pcap

# Filter for TCP handshakes in a capture
tshark -r lab.pcap -Y "tcp.flags.syn==1 && tcp.flags.ack==0" -T fields -e ip.src -e ip.dst

# DNS response size review
tshark -r lab.pcap -Y "dns.flags.response==1" -T fields -e dns.qry.name -e dns.len`}
                  />
                </AccordionDetails>
              </Accordion>
            </Box>
          </TabPanel>
        </Paper>

        <Box sx={{ mt: 4, textAlign: "center" }}>
          <Button
            variant="outlined"
            startIcon={<ArrowBackIcon />}
            onClick={() => navigate("/learn")}
            sx={{ borderColor: "#0ea5e9", color: "#0ea5e9" }}
          >
            Back to Learn Hub
          </Button>
        </Box>
      </Container>
    </Box>
    </LearnPageLayout>
  );
};

export default NetworkProtocolExploitationPage;
