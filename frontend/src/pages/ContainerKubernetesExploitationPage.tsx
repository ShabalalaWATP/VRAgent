import React, { useState } from "react";
import LearnPageLayout from "../components/LearnPageLayout";
import QuizSection, { QuizQuestion } from "../components/QuizSection";
import {
  Box,
  Container,
  Typography,
  Paper,
  Tabs,
  Tab,
  Chip,
  Button,
  Accordion,
  AccordionSummary,
  AccordionDetails,
  Grid,
  List,
  ListItem,
  ListItemIcon,
  ListItemText,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  IconButton,
  Tooltip,
  alpha,
} from "@mui/material";
import ArrowBackIcon from "@mui/icons-material/ArrowBack";
import ExpandMoreIcon from "@mui/icons-material/ExpandMore";
import ContentCopyIcon from "@mui/icons-material/ContentCopy";
import SecurityIcon from "@mui/icons-material/Security";
import LayersIcon from "@mui/icons-material/Layers";
import HubIcon from "@mui/icons-material/Hub";
import BuildIcon from "@mui/icons-material/Build";
import ChecklistIcon from "@mui/icons-material/Checklist";
import WarningIcon from "@mui/icons-material/Warning";
import CheckCircleIcon from "@mui/icons-material/CheckCircle";
import CloudIcon from "@mui/icons-material/Cloud";
import QuizIcon from "@mui/icons-material/Quiz";
import { Link, useNavigate } from "react-router-dom";

interface TabPanelProps {
  children?: React.ReactNode;
  index: number;
  value: number;
}

function TabPanel(props: TabPanelProps) {
  const { children, value, index, ...other } = props;
  return (
    <div role="tabpanel" hidden={value !== index} {...other}>
      {value === index && <Box sx={{ py: 3 }}>{children}</Box>}
    </div>
  );
}

const CodeBlock: React.FC<{ code: string; language?: string }> = ({
  code,
  language = "bash",
}) => {
  const [copied, setCopied] = useState(false);

  const handleCopy = () => {
    navigator.clipboard.writeText(code);
    setCopied(true);
    setTimeout(() => setCopied(false), 2000);
  };

  return (
    <Paper
      sx={{
        p: 2,
        bgcolor: "#121424",
        borderRadius: 2,
        position: "relative",
        my: 2,
        border: "1px solid rgba(56, 189, 248, 0.3)",
      }}
    >
      <Box sx={{ position: "absolute", top: 8, right: 8, display: "flex", gap: 1 }}>
        <Chip label={language} size="small" sx={{ bgcolor: "#38bdf8", color: "#0b1020" }} />
        <Tooltip title={copied ? "Copied!" : "Copy"}>
          <IconButton size="small" onClick={handleCopy} sx={{ color: "#e2e8f0" }}>
            <ContentCopyIcon fontSize="small" />
          </IconButton>
        </Tooltip>
      </Box>
      <Box
        component="pre"
        sx={{
          m: 0,
          overflow: "auto",
          fontFamily: "monospace",
          fontSize: "0.85rem",
          color: "#e2e8f0",
          pt: 2,
        }}
      >
        {code}
      </Box>
    </Paper>
  );
};

const QUIZ_QUESTION_COUNT = 10;
const QUIZ_ACCENT_COLOR = "#38bdf8";

const quizQuestions: QuizQuestion[] = [
  {
    id: 1,
    topic: "Basics",
    question: "A container is best described as:",
    options: [
      "An isolated process sharing the host kernel",
      "A full virtual machine with its own kernel",
      "A physical server appliance",
      "A network firewall rule",
    ],
    correctAnswer: 0,
    explanation: "Containers share the host kernel and isolate processes with namespaces and cgroups.",
  },
  {
    id: 2,
    topic: "Basics",
    question: "How do containers differ from virtual machines?",
    options: [
      "Containers share the host OS kernel; VMs run separate kernels",
      "Containers always require more memory than VMs",
      "VMs cannot be isolated",
      "Containers cannot be networked",
    ],
    correctAnswer: 0,
    explanation: "VMs include a full guest OS, while containers share the host kernel.",
  },
  {
    id: 3,
    topic: "Images",
    question: "A container image is:",
    options: [
      "A read-only template used to create containers",
      "A running process on the host",
      "A Kubernetes object that schedules pods",
      "A network policy rule",
    ],
    correctAnswer: 0,
    explanation: "Images are immutable templates used to start containers.",
  },
  {
    id: 4,
    topic: "Images",
    question: "A container registry is used to:",
    options: [
      "Store and distribute container images",
      "Manage Kubernetes nodes",
      "Enforce RBAC policies",
      "Monitor network flows",
    ],
    correctAnswer: 0,
    explanation: "Registries host images for pulling and deployment.",
  },
  {
    id: 5,
    topic: "Images",
    question: "Why use minimal base images?",
    options: [
      "They reduce attack surface and vulnerabilities",
      "They increase container privileges",
      "They disable logging",
      "They prevent scanning",
    ],
    correctAnswer: 0,
    explanation: "Smaller images reduce installed packages and exposures.",
  },
  {
    id: 6,
    topic: "Images",
    question: "A Dockerfile is:",
    options: [
      "A set of instructions to build an image",
      "A runtime configuration for Kubernetes",
      "A log file for containers",
      "A network policy definition",
    ],
    correctAnswer: 0,
    explanation: "Dockerfiles define how to build container images.",
  },
  {
    id: 7,
    topic: "Images",
    question: "Image layers represent:",
    options: [
      "Immutable filesystem changes per build step",
      "Runtime memory pages",
      "Network firewall rules",
      "Kubernetes namespaces",
    ],
    correctAnswer: 0,
    explanation: "Each Dockerfile step adds a filesystem layer.",
  },
  {
    id: 8,
    topic: "Runtime",
    question: "A container runtime is responsible for:",
    options: [
      "Starting and managing containers on a host",
      "Scheduling pods across the cluster",
      "Managing DNS records",
      "Issuing TLS certificates",
    ],
    correctAnswer: 0,
    explanation: "Runtimes like containerd or Docker run containers.",
  },
  {
    id: 9,
    topic: "Kubernetes",
    question: "A pod is:",
    options: [
      "The smallest deployable unit in Kubernetes",
      "A physical server",
      "A container registry",
      "A network firewall",
    ],
    correctAnswer: 0,
    explanation: "Pods encapsulate one or more containers with shared context.",
  },
  {
    id: 10,
    topic: "Kubernetes",
    question: "A node is:",
    options: [
      "A worker machine running pods",
      "A cluster-wide RBAC policy",
      "A namespace for isolation",
      "A Kubernetes secret",
    ],
    correctAnswer: 0,
    explanation: "Nodes host and run pods in a cluster.",
  },
  {
    id: 11,
    topic: "Kubernetes",
    question: "A namespace provides:",
    options: [
      "Logical isolation of resources within a cluster",
      "Full network encryption by default",
      "A replacement for RBAC",
      "Access to host processes",
    ],
    correctAnswer: 0,
    explanation: "Namespaces separate resources logically, not as a strict boundary.",
  },
  {
    id: 12,
    topic: "Identity",
    question: "A Kubernetes service account is:",
    options: [
      "An identity for pods to access the API server",
      "A container registry login",
      "A node-level admin account",
      "A firewall user group",
    ],
    correctAnswer: 0,
    explanation: "Service accounts provide API identities for pods.",
  },
  {
    id: 13,
    topic: "RBAC",
    question: "A Role defines:",
    options: [
      "Permissions within a namespace",
      "Cluster-wide permissions",
      "Node-level OS permissions",
      "Container runtime settings",
    ],
    correctAnswer: 0,
    explanation: "Roles are namespace-scoped permission sets.",
  },
  {
    id: 14,
    topic: "RBAC",
    question: "A ClusterRole defines:",
    options: [
      "Permissions across the cluster",
      "Permissions only for one namespace",
      "Permissions only for a single pod",
      "File system permissions on nodes",
    ],
    correctAnswer: 0,
    explanation: "ClusterRoles apply cluster-wide or to multiple namespaces.",
  },
  {
    id: 15,
    topic: "RBAC",
    question: "A RoleBinding is used to:",
    options: [
      "Bind a Role to a user or service account",
      "Create a new namespace",
      "Encrypt secrets",
      "Expose a service externally",
    ],
    correctAnswer: 0,
    explanation: "RoleBindings grant Role permissions to subjects.",
  },
  {
    id: 16,
    topic: "RBAC",
    question: "A ClusterRoleBinding is used to:",
    options: [
      "Bind a ClusterRole across the cluster",
      "Create a pod security policy",
      "Schedule a pod on all nodes",
      "Run a container as root",
    ],
    correctAnswer: 0,
    explanation: "ClusterRoleBindings grant cluster-wide permissions.",
  },
  {
    id: 17,
    topic: "RBAC",
    question: "The cluster-admin role grants:",
    options: [
      "Full administrative access to the cluster",
      "Read-only access to pods",
      "Access only to secrets in one namespace",
      "Node OS privileges only",
    ],
    correctAnswer: 0,
    explanation: "cluster-admin is effectively full access.",
  },
  {
    id: 18,
    topic: "Control Plane",
    question: "The API server is:",
    options: [
      "The front end for all Kubernetes API requests",
      "A container registry",
      "A DNS server",
      "A kubelet on a node",
    ],
    correctAnswer: 0,
    explanation: "All kubectl and API calls go through the API server.",
  },
  {
    id: 19,
    topic: "Control Plane",
    question: "etcd stores:",
    options: [
      "Cluster state and configuration data",
      "Container images",
      "User passwords in plain text",
      "Only node logs",
    ],
    correctAnswer: 0,
    explanation: "etcd is the key-value store for cluster state.",
  },
  {
    id: 20,
    topic: "Control Plane",
    question: "The kubelet is:",
    options: [
      "The node agent that runs pods",
      "The scheduler for pods across nodes",
      "The ingress controller",
      "The DNS resolver",
    ],
    correctAnswer: 0,
    explanation: "kubelet manages pods on each node.",
  },
  {
    id: 21,
    topic: "Access",
    question: "A kubeconfig file typically contains:",
    options: [
      "Cluster endpoints and authentication credentials",
      "Container image layers",
      "Pod logs only",
      "Firewall rules",
    ],
    correctAnswer: 0,
    explanation: "kubeconfig stores cluster access details.",
  },
  {
    id: 22,
    topic: "Secrets",
    question: "Kubernetes secrets are stored as:",
    options: [
      "Base64-encoded data by default",
      "Fully encrypted values by default",
      "Plain text in pod logs",
      "Hashed values only",
    ],
    correctAnswer: 0,
    explanation: "Secrets are base64-encoded unless encryption at rest is enabled.",
  },
  {
    id: 23,
    topic: "Secrets",
    question: "Why disable automountServiceAccountToken?",
    options: [
      "To reduce credential exposure inside pods",
      "To improve pod scheduling",
      "To increase container privileges",
      "To enable host networking",
    ],
    correctAnswer: 0,
    explanation: "Not mounting tokens reduces API access if the pod is compromised.",
  },
  {
    id: 24,
    topic: "Escalation",
    question: "A hostPath volume allows:",
    options: [
      "Mounting host filesystem paths into a pod",
      "Encrypting pod storage",
      "Blocking outbound traffic",
      "Setting network policies",
    ],
    correctAnswer: 0,
    explanation: "hostPath mounts can expose host files to containers.",
  },
  {
    id: 25,
    topic: "Escalation",
    question: "Why are privileged containers risky?",
    options: [
      "They grant broad access to host resources and devices",
      "They disable container networking",
      "They prevent container logging",
      "They require no image scanning",
    ],
    correctAnswer: 0,
    explanation: "Privileged containers have near-host-level access.",
  },
  {
    id: 26,
    topic: "Escalation",
    question: "hostNetwork enables a pod to:",
    options: [
      "Share the node's network namespace",
      "Encrypt all network traffic",
      "Disable outbound access",
      "Run only on the control plane",
    ],
    correctAnswer: 0,
    explanation: "hostNetwork gives pods direct access to the node network stack.",
  },
  {
    id: 27,
    topic: "Escalation",
    question: "hostPID allows a pod to:",
    options: [
      "See and interact with host processes",
      "Only use its own PID namespace",
      "Disable process monitoring",
      "Encrypt process memory",
    ],
    correctAnswer: 0,
    explanation: "hostPID exposes the host process namespace.",
  },
  {
    id: 28,
    topic: "Escalation",
    question: "Why is mounting /var/run/docker.sock dangerous?",
    options: [
      "It grants control over the Docker daemon",
      "It prevents image pulls",
      "It disables container networking",
      "It blocks host access",
    ],
    correctAnswer: 0,
    explanation: "Docker socket access can start privileged containers on the host.",
  },
  {
    id: 29,
    topic: "Escalation",
    question: "A container escape refers to:",
    options: [
      "Breaking out of the container to access the host",
      "Restarting a pod",
      "Scaling a deployment",
      "Rotating secrets",
    ],
    correctAnswer: 0,
    explanation: "Escapes grant host access from a containerized process.",
  },
  {
    id: 30,
    topic: "Hardening",
    question: "Running containers as non-root helps by:",
    options: [
      "Reducing privilege if the container is compromised",
      "Increasing host kernel access",
      "Disabling security logs",
      "Allowing host mounts by default",
    ],
    correctAnswer: 0,
    explanation: "Non-root users limit the impact of compromise.",
  },
  {
    id: 31,
    topic: "Hardening",
    question: "Seccomp is used to:",
    options: [
      "Filter allowed system calls",
      "Encrypt container file systems",
      "Configure RBAC rules",
      "Disable namespaces",
    ],
    correctAnswer: 0,
    explanation: "Seccomp restricts syscalls to reduce attack surface.",
  },
  {
    id: 32,
    topic: "Hardening",
    question: "AppArmor provides:",
    options: [
      "Mandatory access control profiles for processes",
      "Network encryption",
      "Container image signing",
      "Pod scheduling constraints",
    ],
    correctAnswer: 0,
    explanation: "AppArmor enforces security profiles for processes.",
  },
  {
    id: 33,
    topic: "Hardening",
    question: "SELinux provides:",
    options: [
      "Label-based access control",
      "DNS resolution",
      "Image compression",
      "Pod scaling",
    ],
    correctAnswer: 0,
    explanation: "SELinux enforces label-based security policies.",
  },
  {
    id: 34,
    topic: "Hardening",
    question: "Which Linux capability is often considered high risk?",
    options: [
      "CAP_SYS_ADMIN",
      "CAP_NET_BIND_SERVICE",
      "CAP_CHOWN",
      "CAP_SETUID",
    ],
    correctAnswer: 0,
    explanation: "CAP_SYS_ADMIN grants broad privileges and is often abused.",
  },
  {
    id: 35,
    topic: "Policy",
    question: "Admission controllers are used to:",
    options: [
      "Enforce policy at pod creation time",
      "Store container images",
      "Run containers on nodes",
      "Provide DNS resolution",
    ],
    correctAnswer: 0,
    explanation: "Admission controllers validate or mutate requests.",
  },
  {
    id: 36,
    topic: "Policy",
    question: "Pod Security Admission helps enforce:",
    options: [
      "Baseline and restricted pod security standards",
      "Container image scanning only",
      "Node health checks",
      "Ingress routing rules",
    ],
    correctAnswer: 0,
    explanation: "PSA enforces pod security levels.",
  },
  {
    id: 37,
    topic: "Networking",
    question: "Network policies are used to:",
    options: [
      "Restrict pod-to-pod traffic",
      "Configure container runtimes",
      "Encrypt secrets at rest",
      "Patch nodes automatically",
    ],
    correctAnswer: 0,
    explanation: "Network policies define allowed traffic between pods.",
  },
  {
    id: 38,
    topic: "Networking",
    question: "A default deny network policy means:",
    options: [
      "Traffic is blocked unless explicitly allowed",
      "All traffic is allowed by default",
      "Only DNS is blocked",
      "Only ingress is allowed",
    ],
    correctAnswer: 0,
    explanation: "Default deny requires explicit allow rules.",
  },
  {
    id: 39,
    topic: "Hardening",
    question: "Why use a read-only root filesystem?",
    options: [
      "To reduce tampering and persistence in containers",
      "To increase write speed",
      "To disable logging",
      "To allow host access",
    ],
    correctAnswer: 0,
    explanation: "Read-only roots limit modifications inside containers.",
  },
  {
    id: 40,
    topic: "Scanning",
    question: "Trivy is used for:",
    options: [
      "Container image vulnerability scanning",
      "Packet capture",
      "DNS enumeration",
      "RBAC management",
    ],
    correctAnswer: 0,
    explanation: "Trivy scans images for vulnerabilities and misconfigurations.",
  },
  {
    id: 41,
    topic: "Scanning",
    question: "Grype is used for:",
    options: [
      "Container image vulnerability scanning",
      "Cluster scheduling",
      "Network segmentation",
      "Log aggregation",
    ],
    correctAnswer: 0,
    explanation: "Grype scans images and filesystems for CVEs.",
  },
  {
    id: 42,
    topic: "Scanning",
    question: "kube-bench is used for:",
    options: [
      "Checking cluster configuration against CIS benchmarks",
      "Running container escapes",
      "Scanning web apps",
      "Collecting DNS data",
    ],
    correctAnswer: 0,
    explanation: "kube-bench evaluates CIS Kubernetes benchmarks.",
  },
  {
    id: 43,
    topic: "Scanning",
    question: "kube-hunter is used for:",
    options: [
      "Hunting for Kubernetes weaknesses",
      "Building container images",
      "Managing nodes",
      "Enforcing RBAC",
    ],
    correctAnswer: 0,
    explanation: "kube-hunter probes for common Kubernetes issues.",
  },
  {
    id: 44,
    topic: "Scanning",
    question: "Docker Bench for Security checks:",
    options: [
      "Docker host and daemon configuration against best practices",
      "Kubernetes RBAC permissions",
      "DNS zone files",
      "Web app vulnerabilities",
    ],
    correctAnswer: 0,
    explanation: "Docker Bench reviews Docker configuration for security.",
  },
  {
    id: 45,
    topic: "RBAC",
    question: "A risky RBAC pattern is:",
    options: [
      "Wildcard verbs or resources (\"*\")",
      "Read-only access to pods",
      "Namespace-scoped read access",
      "Least privilege role bindings",
    ],
    correctAnswer: 0,
    explanation: "Wildcard permissions grant overly broad access.",
  },
  {
    id: 46,
    topic: "RBAC",
    question: "Why is service account token theft impactful?",
    options: [
      "Tokens can allow API access and privilege escalation",
      "Tokens only grant read access to logs",
      "Tokens cannot be used outside the pod",
      "Tokens are encrypted with hardware keys",
    ],
    correctAnswer: 0,
    explanation: "Stolen tokens can access the API with assigned privileges.",
  },
  {
    id: 47,
    topic: "Exposure",
    question: "Anonymous kubelet access is dangerous because it can:",
    options: [
      "Allow pod listing, exec, or log access without auth",
      "Encrypt etcd automatically",
      "Disable RBAC",
      "Stop the API server",
    ],
    correctAnswer: 0,
    explanation: "Unauthenticated kubelet access can expose workloads and secrets.",
  },
  {
    id: 48,
    topic: "Exposure",
    question: "An unsecured etcd instance can expose:",
    options: [
      "All cluster state including secrets",
      "Only container logs",
      "Only node metrics",
      "Only DNS records",
    ],
    correctAnswer: 0,
    explanation: "etcd stores cluster configuration and secrets.",
  },
  {
    id: 49,
    topic: "Ingress",
    question: "Ingress is used to:",
    options: [
      "Route HTTP/HTTPS traffic into services",
      "Store secrets in etcd",
      "Schedule pods on nodes",
      "Apply RBAC policies",
    ],
    correctAnswer: 0,
    explanation: "Ingress manages external access to services.",
  },
  {
    id: 50,
    topic: "Workloads",
    question: "A DaemonSet ensures:",
    options: [
      "A pod runs on each node (or selected nodes)",
      "A pod runs only once",
      "Only one replica exists cluster-wide",
      "Pods run only on the control plane",
    ],
    correctAnswer: 0,
    explanation: "DaemonSets schedule pods on all or selected nodes.",
  },
  {
    id: 51,
    topic: "Workloads",
    question: "A Deployment manages:",
    options: [
      "Replicas and rolling updates of pods",
      "Network policies for pods",
      "Service account tokens",
      "Node OS updates",
    ],
    correctAnswer: 0,
    explanation: "Deployments manage replica sets and rollout strategies.",
  },
  {
    id: 52,
    topic: "Workloads",
    question: "A StatefulSet is useful for:",
    options: [
      "Workloads requiring stable identities and storage",
      "Stateless web apps only",
      "One-time jobs",
      "Cluster-wide RBAC policies",
    ],
    correctAnswer: 0,
    explanation: "StatefulSets provide stable IDs and storage for stateful apps.",
  },
  {
    id: 53,
    topic: "Escalation",
    question: "Mounting the host root filesystem in a pod can allow:",
    options: [
      "Direct modification of host files",
      "Only read access to logs",
      "Network policy changes",
      "API server restarts",
    ],
    correctAnswer: 0,
    explanation: "Host mounts can give full access to the host filesystem.",
  },
  {
    id: 54,
    topic: "Supply Chain",
    question: "Why pin images by digest?",
    options: [
      "It ensures immutability and prevents tag drift",
      "It disables image scanning",
      "It forces root execution",
      "It increases image size",
    ],
    correctAnswer: 0,
    explanation: "Digests are immutable and reduce supply chain risk.",
  },
  {
    id: 55,
    topic: "Supply Chain",
    question: "Using untrusted images is risky because:",
    options: [
      "They may contain malware or backdoors",
      "They improve performance",
      "They always match CIS benchmarks",
      "They cannot be scanned",
    ],
    correctAnswer: 0,
    explanation: "Untrusted sources can introduce malicious code.",
  },
  {
    id: 56,
    topic: "RBAC",
    question: "The verbs get, list, and watch allow:",
    options: [
      "Read access to resources",
      "Full admin access",
      "Node OS access",
      "Container runtime control",
    ],
    correctAnswer: 0,
    explanation: "These verbs provide read-only resource access.",
  },
  {
    id: 57,
    topic: "Access",
    question: "kubectl exec requires:",
    options: [
      "Permissions to create exec sessions in pods",
      "Node OS root access only",
      "DNS admin rights",
      "Ingress controller access",
    ],
    correctAnswer: 0,
    explanation: "kubectl exec requires API permissions on pods.",
  },
  {
    id: 58,
    topic: "Access",
    question: "kubectl port-forward is used to:",
    options: [
      "Forward local ports to a pod or service",
      "Create a new node",
      "Rotate secrets",
      "Disable network policies",
    ],
    correctAnswer: 0,
    explanation: "Port forwarding provides local access to a pod or service.",
  },
  {
    id: 59,
    topic: "Access",
    question: "kubectl proxy provides:",
    options: [
      "A local proxy to the Kubernetes API",
      "A container runtime socket",
      "A DNS resolver",
      "A pod security policy",
    ],
    correctAnswer: 0,
    explanation: "kubectl proxy exposes the API locally via HTTP.",
  },
  {
    id: 60,
    topic: "Cloud",
    question: "Cloud metadata endpoints are risky because they:",
    options: [
      "Can expose temporary credentials to pods",
      "Always enforce MFA",
      "Only return public keys",
      "Are accessible only from control plane nodes",
    ],
    correctAnswer: 0,
    explanation: "Metadata endpoints can provide cloud credentials.",
  },
  {
    id: 61,
    topic: "Hardening",
    question: "Why enable encryption at rest for secrets?",
    options: [
      "To protect data stored in etcd",
      "To increase pod scheduling speed",
      "To disable logs",
      "To allow anonymous access",
    ],
    correctAnswer: 0,
    explanation: "Encryption at rest protects stored secrets in etcd.",
  },
  {
    id: 62,
    topic: "Hardening",
    question: "Why restrict access to the API server?",
    options: [
      "It is the control plane entry point for the cluster",
      "It only serves static content",
      "It does not require authentication",
      "It only affects logging",
    ],
    correctAnswer: 0,
    explanation: "The API server controls all cluster operations.",
  },
  {
    id: 63,
    topic: "Hardening",
    question: "Why use namespace isolation with RBAC?",
    options: [
      "It limits access to resources by scope",
      "It guarantees network isolation alone",
      "It disables secrets",
      "It removes monitoring",
    ],
    correctAnswer: 0,
    explanation: "Namespaces plus RBAC limit access by scope.",
  },
  {
    id: 64,
    topic: "Hardening",
    question: "Why enable audit logging in Kubernetes?",
    options: [
      "To track API actions and detect misuse",
      "To disable RBAC",
      "To reduce storage usage",
      "To avoid incident response",
    ],
    correctAnswer: 0,
    explanation: "Audit logs show who did what in the API.",
  },
  {
    id: 65,
    topic: "Escalation",
    question: "A common container escape path involves:",
    options: [
      "Privileged containers with host mounts",
      "Read-only root filesystems",
      "Rootless containers",
      "Strict seccomp profiles",
    ],
    correctAnswer: 0,
    explanation: "Privileged containers with host access increase escape risk.",
  },
  {
    id: 66,
    topic: "Kubernetes",
    question: "A Service in Kubernetes provides:",
    options: [
      "Stable networking to access pods",
      "Cluster-wide admin privileges",
      "Image scanning",
      "Node OS patching",
    ],
    correctAnswer: 0,
    explanation: "Services provide stable access to pod endpoints.",
  },
  {
    id: 67,
    topic: "Kubernetes",
    question: "Why are namespaces not a strict security boundary?",
    options: [
      "Shared kernel and misconfigurations can allow cross-namespace impact",
      "They block all network traffic automatically",
      "They enforce RBAC without configuration",
      "They encrypt secrets by default",
    ],
    correctAnswer: 0,
    explanation: "Namespaces provide logical separation, not full isolation.",
  },
  {
    id: 68,
    topic: "Hardening",
    question: "Why limit hostPath usage?",
    options: [
      "It can expose host files and allow escalation",
      "It improves pod startup speed",
      "It disables network policies",
      "It encrypts secrets",
    ],
    correctAnswer: 0,
    explanation: "hostPath can expose sensitive host paths.",
  },
  {
    id: 69,
    topic: "Hardening",
    question: "Why use image signing or verification?",
    options: [
      "To ensure images are from trusted sources",
      "To disable vulnerability scanning",
      "To increase image size",
      "To allow unsigned code execution",
    ],
    correctAnswer: 0,
    explanation: "Signing verifies image integrity and provenance.",
  },
  {
    id: 70,
    topic: "Operations",
    question: "What is a common indicator of excessive pod privileges?",
    options: [
      "SecurityContext with privileged: true",
      "Read-only root filesystem",
      "Dropping all capabilities",
      "RunAsNonRoot enabled",
    ],
    correctAnswer: 0,
    explanation: "Privileged pods have elevated access.",
  },
  {
    id: 71,
    topic: "Operations",
    question: "Why review pod security contexts?",
    options: [
      "They control user, capabilities, and privilege settings",
      "They store DNS records",
      "They configure ingress rules",
      "They encrypt secrets",
    ],
    correctAnswer: 0,
    explanation: "Security contexts define privilege settings for pods.",
  },
  {
    id: 72,
    topic: "Detection",
    question: "Why monitor for exec into pods?",
    options: [
      "It can indicate interactive access by an attacker",
      "It always indicates normal operations",
      "It disables logs",
      "It prevents pod restarts",
    ],
    correctAnswer: 0,
    explanation: "Unexpected exec sessions can indicate compromise.",
  },
  {
    id: 73,
    topic: "Detection",
    question: "Why alert on new ClusterRoleBindings?",
    options: [
      "They can grant broad permissions quickly",
      "They only affect logging",
      "They are created automatically every hour",
      "They disable secrets",
    ],
    correctAnswer: 0,
    explanation: "New bindings can grant excessive cluster access.",
  },
  {
    id: 74,
    topic: "Hardening",
    question: "A good practice for service account tokens is to:",
    options: [
      "Use short-lived tokens and rotate regularly",
      "Use a single static token for all pods",
      "Disable all token validation",
      "Store tokens in public registries",
    ],
    correctAnswer: 0,
    explanation: "Short-lived tokens reduce exposure if stolen.",
  },
  {
    id: 75,
    topic: "Basics",
    question: "Which statement best summarizes container and K8s risk?",
    options: [
      "Misconfigurations and excessive privileges can expose hosts and clusters",
      "Containers are always isolated and safe by default",
      "RBAC is optional for security",
      "Secrets are always encrypted by default",
    ],
    correctAnswer: 0,
    explanation: "Security depends on configuration, least privilege, and controls.",
  },
];

const ContainerKubernetesExploitationPage: React.FC = () => {
  const navigate = useNavigate();
  const [tabValue, setTabValue] = useState(0);

  const pageContext = `This page covers container and Kubernetes security exploitation techniques for offensive assessments. Topics include container runtime security (Docker, containerd), Kubernetes cluster enumeration, control plane components, RBAC and authentication weaknesses, secrets and service account abuse, node and pod escalation paths, container escape techniques, persistence ideas, detection signals, and supply chain risks. The page covers tools like Trivy, Grype, kube-hunter, kube-bench, and Docker Bench. Lab environments include Kubernetes Goat, KubeGoat, Kind/Minikube, and OWASP Juice Shop on K8s. Key concepts include pods, nodes, namespaces, service accounts, DaemonSets, Ingress, and privileged containers.`;

  const guardrails = [
    "Only test systems you own or have explicit written authorization to assess.",
    "Confirm scope, time window, and escalation contacts before testing.",
    "Avoid destructive actions unless explicitly approved by stakeholders.",
    "Collect evidence and log outputs for reproducibility.",
    "Coordinate with platform owners before draining nodes or restarting workloads.",
  ];

  const attackSurface = [
    {
      area: "Container Images",
      risk: "Outdated bases, embedded secrets, and unsigned artifacts.",
      focus: "Scan SBOMs, search for secrets, validate signatures.",
    },
    {
      area: "Runtime Config",
      risk: "Privileged containers and weak isolation.",
      focus: "Check caps, seccomp, AppArmor, and host mounts.",
    },
    {
      area: "Registries",
      risk: "Public exposure or weak auth controls.",
      focus: "Review pull permissions, tag immutability, and audit logs.",
    },
    {
      area: "Kubernetes API",
      risk: "Overly broad RBAC or exposed API endpoints.",
      focus: "Map RBAC bindings and auth can-i results.",
    },
    {
      area: "Nodes and Kubelet",
      risk: "Direct node access or insecure kubelet endpoints.",
      focus: "Validate node exposure and kubelet auth mode.",
    },
    {
      area: "Secrets and Config",
      risk: "Plaintext secrets and weak service account controls.",
      focus: "Review secret scope, rotation, and token use.",
    },
  ];
  const beginnerPath = [
    "1) Build a local lab (kind or minikube) and deploy a safe demo app.",
    "2) Learn the core terms: pod, node, namespace, service account, RBAC.",
    "3) Enumerate what you can see with kubectl and simple container checks.",
    "4) Map risks: privileged pods, hostPath mounts, and broad RBAC grants.",
    "5) Document evidence, impact, and fixes you would recommend.",
  ];
  const beginnerGlossary = [
    { term: "Container", desc: "Isolated process with its own filesystem and network." },
    { term: "Image", desc: "Read-only template used to start a container." },
    { term: "Registry", desc: "Server that stores and delivers container images." },
    { term: "Pod", desc: "Smallest deployable unit in Kubernetes, one or more containers." },
    { term: "Node", desc: "Machine that runs pods (VM or physical host)." },
    { term: "Namespace", desc: "Logical isolation boundary inside a cluster." },
    { term: "Service Account", desc: "Identity used by pods to talk to the Kubernetes API." },
    { term: "RBAC", desc: "Role-based access control for Kubernetes resources." },
    { term: "RoleBinding", desc: "Binds a role to users or service accounts." },
    { term: "Kubelet", desc: "Node agent that runs containers and reports status." },
    { term: "DaemonSet", desc: "Ensures a pod runs on each node in the cluster." },
    { term: "Ingress", desc: "Routes HTTP traffic to services inside the cluster." },
  ];
  const containerCommandHints = [
    { cmd: "id", purpose: "Who am I inside the container." },
    { cmd: "cat /proc/1/cgroup", purpose: "Confirm container runtime context." },
    { cmd: "mount", purpose: "Find host mounts and sensitive paths." },
    { cmd: "ls -l /var/run/docker.sock", purpose: "Check for Docker socket exposure." },
    { cmd: "capsh --print", purpose: "Review Linux capabilities." },
  ];
  const kubectlBasics = [
    { cmd: "kubectl get ns", purpose: "List namespaces." },
    { cmd: "kubectl get pods -A", purpose: "List all pods in all namespaces." },
    { cmd: "kubectl auth can-i --list", purpose: "See what the current identity can do." },
    { cmd: "kubectl get roles,rolebindings -A", purpose: "Map RBAC permissions." },
    { cmd: "kubectl describe pod <name> -n <ns>", purpose: "View pod details and mounts." },
  ];
  const k8sNetworkRecon = `# Service and network mapping
kubectl get svc -A
kubectl get endpoints -A
kubectl get ingress -A
kubectl get networkpolicy -A
kubectl get pods -A -o wide`;
  const controlPlaneComponents = [
    {
      component: "API Server",
      risk: "Primary control plane entrypoint. Exposure or weak auth grants cluster control.",
      focus: "Restrict access, enable authn/authz, audit logs.",
    },
    {
      component: "etcd",
      risk: "Stores secrets and cluster state. Exposure yields full compromise.",
      focus: "No public access, mTLS, encrypted backups.",
    },
    {
      component: "Controller Manager",
      risk: "Can create or scale workloads for persistence.",
      focus: "Protect via API auth and RBAC.",
    },
    {
      component: "Scheduler",
      risk: "Can schedule privileged pods to nodes.",
      focus: "Limit API access and enforce policies.",
    },
    {
      component: "Kubelet",
      risk: "Insecure endpoints allow exec or log access.",
      focus: "Disable read-only port, require auth.",
    },
  ];
  const runtimeEscalationPatterns = [
    "Docker or containerd socket access enables container to host control.",
    "HostPath mounts allow overwriting host binaries or kubelet configs.",
    "Privileged pods with host PID or host network can reach host namespaces.",
    "CAP_SYS_ADMIN plus sensitive mounts unlocks escape primitives.",
    "Writable /proc or /sys mounts can alter host settings.",
  ];
  const containerDetectionSignals = [
    "Access to /var/run/docker.sock or /run/containerd.sock inside pods",
    "Unexpected processes spawning with elevated capabilities",
    "Write activity to hostPath mounts or /proc/1/root",
    "Outbound calls to metadata endpoints from workloads",
    "New containers or DaemonSets created without change tickets",
  ];
  const kubernetesEscalationPaths = [
    {
      vector: "Service account token theft",
      impact: "API access as the pod identity",
      signal: "Token used from unexpected pod or namespace",
    },
    {
      vector: "RBAC wildcard permissions",
      impact: "Create pods, read secrets, or bind cluster-admin",
      signal: "can-i shows '*' verbs/resources",
    },
    {
      vector: "Privileged DaemonSet",
      impact: "Node access and host persistence",
      signal: "DaemonSet with hostPID or hostPath mounts",
    },
    {
      vector: "Kubelet exposure",
      impact: "Exec into pods or read logs",
      signal: "Unsecured kubelet ports 10250 or 10255",
    },
    {
      vector: "Admission policy gaps",
      impact: "Unsafe pod specs allowed",
      signal: "Pods created without expected policy checks",
    },
  ];
  const persistenceIdeas = [
    "Add a CronJob or DaemonSet with elevated permissions.",
    "Patch an existing deployment image or environment values.",
    "Create a ClusterRoleBinding for a controlled service account.",
    "Store payloads in ConfigMaps or Secrets and mount them in pods.",
  ];
  const reportingChecklist = [
    "Capture kubectl auth can-i outputs and RBAC bindings.",
    "Record pod specs showing hostPath, privileged, or capabilities.",
    "List exposed endpoints (kubelet, API server, registries).",
    "Document impact, evidence, and recommended fixes per finding.",
  ];

  return (
    <LearnPageLayout pageTitle="Container and Kubernetes Exploitation" pageContext={pageContext}>
    <Box sx={{ minHeight: "100vh", bgcolor: "#0a0d18", py: 4 }}>
      <Container maxWidth="lg">
        <Chip
          component={Link}
          to="/learn"
          icon={<ArrowBackIcon />}
          label="Back to Learning Hub"
          clickable
          variant="outlined"
          sx={{ borderRadius: 2, mb: 2 }}
        />

        <Box sx={{ display: "flex", alignItems: "center", gap: 2, mb: 2 }}>
          <CloudIcon sx={{ fontSize: 42, color: "#38bdf8" }} />
          <Typography
            variant="h3"
            sx={{
              fontWeight: 700,
              background: "linear-gradient(135deg, #38bdf8 0%, #6366f1 100%)",
              backgroundClip: "text",
              WebkitBackgroundClip: "text",
              color: "transparent",
            }}
          >
            Container and Kubernetes Exploitation
          </Typography>
        </Box>
        <Typography variant="h6" sx={{ color: "grey.400", mb: 2 }}>
          Offensive learning paths for container runtime testing and Kubernetes security assessments.
        </Typography>
        <Box sx={{ display: "flex", gap: 1, flexWrap: "wrap", mb: 3 }}>
          <Chip icon={<LayersIcon />} label="Containers" size="small" />
          <Chip icon={<HubIcon />} label="Kubernetes" size="small" />
          <Chip icon={<SecurityIcon />} label="RBAC and Access" size="small" />
          <Chip icon={<WarningIcon />} label="Misconfigurations" size="small" />
        </Box>

        <Paper sx={{ bgcolor: "#111424", borderRadius: 2 }}>
          <Tabs
            value={tabValue}
            onChange={(_, v) => setTabValue(v)}
            variant="scrollable"
            scrollButtons="auto"
            sx={{
              borderBottom: "1px solid rgba(255,255,255,0.08)",
              "& .MuiTab-root": { color: "grey.400" },
              "& .Mui-selected": { color: "#38bdf8" },
            }}
          >
            <Tab icon={<SecurityIcon />} label="Overview" />
            <Tab icon={<LayersIcon />} label="Container Runtime" />
            <Tab icon={<HubIcon />} label="Kubernetes" />
            <Tab icon={<BuildIcon />} label="Tools and Labs" />
            <Tab icon={<ChecklistIcon />} label="Checklists" />
          </Tabs>

          <TabPanel value={tabValue} index={0}>
            <Box sx={{ p: 3 }}>
              <Paper
                sx={{
                  p: 2.5,
                  mb: 3,
                  bgcolor: "#0e1222",
                  border: "1px solid rgba(239,68,68,0.3)",
                  borderRadius: 2,
                }}
              >
                <Typography variant="h6" sx={{ color: "#f87171", mb: 1 }}>
                  Engagement Guardrails
                </Typography>
                <List dense>
                  {guardrails.map((item) => (
                    <ListItem key={item}>
                      <ListItemIcon>
                        <CheckCircleIcon color="success" fontSize="small" />
                      </ListItemIcon>
                      <ListItemText primary={item} sx={{ "& .MuiListItemText-primary": { color: "grey.300" } }} />
                    </ListItem>
                  ))}
                </List>
              </Paper>

              <Paper sx={{ mb: 3, p: 2.5, bgcolor: "#0c0f1c", borderRadius: 2 }}>
                <Typography variant="h6" sx={{ color: "#38bdf8", mb: 1 }}>
                  Beginner Path (60 to 120 minutes)
                </Typography>
                <List dense>
                  {beginnerPath.map((step) => (
                    <ListItem key={step}>
                      <ListItemIcon>
                        <CheckCircleIcon color="info" fontSize="small" />
                      </ListItemIcon>
                      <ListItemText primary={step} sx={{ "& .MuiListItemText-primary": { color: "grey.300" } }} />
                    </ListItem>
                  ))}
                </List>
              </Paper>

              <Paper sx={{ mb: 3, p: 2.5, bgcolor: "#0c0f1c", borderRadius: 2 }}>
                <Typography variant="h6" sx={{ color: "#a5b4fc", mb: 2 }}>
                  Quick Glossary
                </Typography>
                <TableContainer>
                  <Table size="small">
                    <TableHead>
                      <TableRow>
                        <TableCell sx={{ color: "#a5b4fc" }}>Term</TableCell>
                        <TableCell sx={{ color: "#a5b4fc" }}>Meaning</TableCell>
                      </TableRow>
                    </TableHead>
                    <TableBody>
                      {beginnerGlossary.map((item) => (
                        <TableRow key={item.term}>
                          <TableCell sx={{ color: "grey.200", fontWeight: 600 }}>{item.term}</TableCell>
                          <TableCell sx={{ color: "grey.400" }}>{item.desc}</TableCell>
                        </TableRow>
                      ))}
                    </TableBody>
                  </Table>
                </TableContainer>
              </Paper>

              <Typography variant="h6" sx={{ color: "#38bdf8", mb: 2 }}>
                Primary Attack Surfaces
              </Typography>
              <Grid container spacing={2}>
                {attackSurface.map((item) => (
                  <Grid item xs={12} md={6} key={item.area}>
                    <Paper
                      sx={{
                        p: 2,
                        bgcolor: "#0c0f1c",
                        borderRadius: 2,
                        border: "1px solid rgba(56,189,248,0.2)",
                        height: "100%",
                      }}
                    >
                      <Typography variant="subtitle1" sx={{ color: "#e2e8f0", fontWeight: 600 }}>
                        {item.area}
                      </Typography>
                      <Typography variant="body2" sx={{ color: "grey.400", mb: 1 }}>
                        Risk: {item.risk}
                      </Typography>
                      <Typography variant="caption" sx={{ color: "grey.500" }}>
                        Focus: {item.focus}
                      </Typography>
                    </Paper>
                  </Grid>
                ))}
              </Grid>

              <Paper sx={{ mt: 3, p: 2.5, bgcolor: "#0c0f1c", borderRadius: 2 }}>
                <Typography variant="h6" sx={{ color: "#a5b4fc", mb: 2 }}>
                  Control Plane Components and Risk
                </Typography>
                <TableContainer>
                  <Table size="small">
                    <TableHead>
                      <TableRow>
                        <TableCell sx={{ color: "#a5b4fc" }}>Component</TableCell>
                        <TableCell sx={{ color: "#a5b4fc" }}>Risk</TableCell>
                        <TableCell sx={{ color: "#a5b4fc" }}>Focus</TableCell>
                      </TableRow>
                    </TableHead>
                    <TableBody>
                      {controlPlaneComponents.map((item) => (
                        <TableRow key={item.component}>
                          <TableCell sx={{ color: "grey.200", fontWeight: 600 }}>{item.component}</TableCell>
                          <TableCell sx={{ color: "grey.400" }}>{item.risk}</TableCell>
                          <TableCell sx={{ color: "grey.400" }}>{item.focus}</TableCell>
                        </TableRow>
                      ))}
                    </TableBody>
                  </Table>
                </TableContainer>
              </Paper>

              <Paper sx={{ mt: 3, p: 2.5, bgcolor: "#0c0f1c", borderRadius: 2 }}>
                <Typography variant="subtitle1" sx={{ color: "#a5b4fc", mb: 1 }}>
                  Typical Offensive Flow
                </Typography>
                <List dense>
                  {[
                    "Enumerate runtime, cluster, and registry context.",
                    "Identify weak isolation or exposed control-plane services.",
                    "Abuse RBAC or service account permissions to expand access.",
                    "Pivot to nodes, registries, or adjacent namespaces.",
                    "Document evidence, impact, and recommended fixes.",
                  ].map((step) => (
                    <ListItem key={step}>
                      <ListItemIcon>
                        <CheckCircleIcon color="info" fontSize="small" />
                      </ListItemIcon>
                      <ListItemText primary={step} sx={{ "& .MuiListItemText-primary": { color: "grey.300" } }} />
                    </ListItem>
                  ))}
                </List>
              </Paper>
            </Box>
          </TabPanel>

          <TabPanel value={tabValue} index={1}>
            <Box sx={{ p: 3 }}>
              <Accordion defaultExpanded>
                <AccordionSummary expandIcon={<ExpandMoreIcon />}>
                  <Typography variant="h6">Beginner Quick Triage</Typography>
                </AccordionSummary>
                <AccordionDetails>
                  <List dense>
                    {[
                      "Confirm you are inside a container and note your user identity.",
                      "Check for host mounts and exposed Docker sockets.",
                      "Identify any privileged settings or dangerous capabilities.",
                      "Look for secrets in environment variables and mounted files.",
                      "Record what you find before making changes.",
                    ].map((item) => (
                      <ListItem key={item}>
                        <ListItemIcon>
                          <CheckCircleIcon color="info" fontSize="small" />
                        </ListItemIcon>
                        <ListItemText primary={item} sx={{ "& .MuiListItemText-primary": { color: "grey.300" } }} />
                      </ListItem>
                    ))}
                  </List>
                </AccordionDetails>
              </Accordion>

              <Accordion defaultExpanded>
                <AccordionSummary expandIcon={<ExpandMoreIcon />}>
                  <Typography variant="h6">Enumeration Basics</Typography>
                </AccordionSummary>
                <AccordionDetails>
                  <CodeBlock
                    code={`# Container and host context
id
cat /proc/1/cgroup
cat /etc/os-release

# Docker visibility (if socket exposed)
docker version
docker ps --format "table {{.ID}}\\t{{.Image}}\\t{{.Status}}"
docker inspect <container_id>

# Capability review
capsh --print
getcap -r / 2>/dev/null`}
                  />
                </AccordionDetails>
              </Accordion>

              <Accordion>
                <AccordionSummary expandIcon={<ExpandMoreIcon />}>
                  <Typography variant="h6">Command Cheat Sheet</Typography>
                </AccordionSummary>
                <AccordionDetails>
                  <TableContainer>
                    <Table size="small">
                      <TableHead>
                        <TableRow>
                          <TableCell sx={{ color: "#38bdf8" }}>Command</TableCell>
                          <TableCell sx={{ color: "#38bdf8" }}>Why it matters</TableCell>
                        </TableRow>
                      </TableHead>
                      <TableBody>
                        {containerCommandHints.map((item) => (
                          <TableRow key={item.cmd}>
                            <TableCell sx={{ color: "grey.200", fontFamily: "monospace" }}>{item.cmd}</TableCell>
                            <TableCell sx={{ color: "grey.400" }}>{item.purpose}</TableCell>
                          </TableRow>
                        ))}
                      </TableBody>
                    </Table>
                  </TableContainer>
                </AccordionDetails>
              </Accordion>

              <Accordion>
                <AccordionSummary expandIcon={<ExpandMoreIcon />}>
                  <Typography variant="h6">High-Risk Runtime Config</Typography>
                </AccordionSummary>
                <AccordionDetails>
                  <List dense>
                    {[
                      "Privileged containers or CAP_SYS_ADMIN enabled.",
                      "Host mounts like /var/run/docker.sock or / mounted read-write.",
                      "allowPrivilegeEscalation=true or seccomp=unconfined.",
                      "AppArmor disabled or custom profiles missing.",
                      "Host networking or host PID namespace enabled.",
                    ].map((item) => (
                      <ListItem key={item}>
                        <ListItemIcon>
                          <WarningIcon sx={{ color: "#f59e0b" }} fontSize="small" />
                        </ListItemIcon>
                        <ListItemText primary={item} sx={{ "& .MuiListItemText-primary": { color: "grey.300" } }} />
                      </ListItem>
                    ))}
                  </List>
                </AccordionDetails>
              </Accordion>

              <Accordion>
                <AccordionSummary expandIcon={<ExpandMoreIcon />}>
                  <Typography variant="h6">Image and Supply Chain Risks</Typography>
                </AccordionSummary>
                <AccordionDetails>
                  <List dense>
                    {[
                      "Outdated base images or vulnerable packages.",
                      "Secrets baked into images or layered history.",
                      "Unsigned images or untrusted registries.",
                      "Overly broad build contexts and copied credentials.",
                      "Build pipelines with weak dependency pinning.",
                    ].map((item) => (
                      <ListItem key={item}>
                        <ListItemIcon>
                          <CheckCircleIcon color="warning" fontSize="small" />
                        </ListItemIcon>
                        <ListItemText primary={item} sx={{ "& .MuiListItemText-primary": { color: "grey.300" } }} />
                      </ListItem>
                    ))}
                  </List>
                </AccordionDetails>
              </Accordion>

              <Accordion>
                <AccordionSummary expandIcon={<ExpandMoreIcon />}>
                  <Typography variant="h6">Container Escape Themes</Typography>
                </AccordionSummary>
                <AccordionDetails>
                  <Typography variant="body2" sx={{ color: "grey.400", mb: 2 }}>
                    Focus on isolation breaks caused by misconfiguration, not kernel zero-days.
                  </Typography>
                  <List dense>
                    {[
                      "Abuse mounted Docker socket to control the host.",
                      "HostPath volumes that expose host filesystem or secrets.",
                      "Privileged pods with host PID or host network access.",
                      "Sensitive device mounts like /dev or /proc.",
                      "Weak seccomp or AppArmor profiles that allow dangerous syscalls.",
                    ].map((item) => (
                      <ListItem key={item}>
                        <ListItemIcon>
                          <CheckCircleIcon color="success" fontSize="small" />
                        </ListItemIcon>
                        <ListItemText primary={item} sx={{ "& .MuiListItemText-primary": { color: "grey.300" } }} />
                      </ListItem>
                    ))}
                  </List>
                </AccordionDetails>
              </Accordion>

              <Accordion>
                <AccordionSummary expandIcon={<ExpandMoreIcon />}>
                  <Typography variant="h6">Privilege Escalation Patterns</Typography>
                </AccordionSummary>
                <AccordionDetails>
                  <List dense>
                    {runtimeEscalationPatterns.map((item) => (
                      <ListItem key={item}>
                        <ListItemIcon>
                          <CheckCircleIcon color="info" fontSize="small" />
                        </ListItemIcon>
                        <ListItemText primary={item} sx={{ "& .MuiListItemText-primary": { color: "grey.300" } }} />
                      </ListItem>
                    ))}
                  </List>
                </AccordionDetails>
              </Accordion>

              <Accordion>
                <AccordionSummary expandIcon={<ExpandMoreIcon />}>
                  <Typography variant="h6">Detection Signals</Typography>
                </AccordionSummary>
                <AccordionDetails>
                  <List dense>
                    {containerDetectionSignals.map((item) => (
                      <ListItem key={item}>
                        <ListItemIcon>
                          <WarningIcon sx={{ color: "#f59e0b" }} fontSize="small" />
                        </ListItemIcon>
                        <ListItemText primary={item} sx={{ "& .MuiListItemText-primary": { color: "grey.300" } }} />
                      </ListItem>
                    ))}
                  </List>
                </AccordionDetails>
              </Accordion>
            </Box>
          </TabPanel>

          <TabPanel value={tabValue} index={2}>
            <Box sx={{ p: 3 }}>
              <Accordion defaultExpanded>
                <AccordionSummary expandIcon={<ExpandMoreIcon />}>
                  <Typography variant="h6">Beginner kubectl Basics</Typography>
                </AccordionSummary>
                <AccordionDetails>
                  <TableContainer>
                    <Table size="small">
                      <TableHead>
                        <TableRow>
                          <TableCell sx={{ color: "#38bdf8" }}>Command</TableCell>
                          <TableCell sx={{ color: "#38bdf8" }}>Purpose</TableCell>
                        </TableRow>
                      </TableHead>
                      <TableBody>
                        {kubectlBasics.map((item) => (
                          <TableRow key={item.cmd}>
                            <TableCell sx={{ color: "grey.200", fontFamily: "monospace" }}>{item.cmd}</TableCell>
                            <TableCell sx={{ color: "grey.400" }}>{item.purpose}</TableCell>
                          </TableRow>
                        ))}
                      </TableBody>
                    </Table>
                  </TableContainer>
                </AccordionDetails>
              </Accordion>

              <Accordion defaultExpanded>
                <AccordionSummary expandIcon={<ExpandMoreIcon />}>
                  <Typography variant="h6">Cluster Recon</Typography>
                </AccordionSummary>
                <AccordionDetails>
                  <CodeBlock
                    code={`# Basic cluster visibility
kubectl version --short
kubectl config view --minify
kubectl get ns
kubectl get nodes -o wide
kubectl get pods -A

# RBAC and access checks
kubectl auth can-i --list
kubectl get roles,rolebindings -A
kubectl get clusterroles,clusterrolebindings`}
                  />
                </AccordionDetails>
              </Accordion>

              <Accordion>
                <AccordionSummary expandIcon={<ExpandMoreIcon />}>
                  <Typography variant="h6">Service Discovery and Network Mapping</Typography>
                </AccordionSummary>
                <AccordionDetails>
                  <CodeBlock code={k8sNetworkRecon} />
                </AccordionDetails>
              </Accordion>

              <Accordion>
                <AccordionSummary expandIcon={<ExpandMoreIcon />}>
                  <Typography variant="h6">RBAC and Auth Weaknesses</Typography>
                </AccordionSummary>
                <AccordionDetails>
                  <List dense>
                    {[
                      "ClusterRoleBinding grants cluster-admin to service accounts.",
                      "Namespace RoleBindings allow wildcard verbs or resources.",
                      "Anonymous or unauthenticated access enabled.",
                      "Default service accounts with broad permissions.",
                      "Lack of authn/authz on kubelet endpoints.",
                    ].map((item) => (
                      <ListItem key={item}>
                        <ListItemIcon>
                          <WarningIcon sx={{ color: "#f59e0b" }} fontSize="small" />
                        </ListItemIcon>
                        <ListItemText primary={item} sx={{ "& .MuiListItemText-primary": { color: "grey.300" } }} />
                      </ListItem>
                    ))}
                  </List>
                </AccordionDetails>
              </Accordion>

              <Accordion>
                <AccordionSummary expandIcon={<ExpandMoreIcon />}>
                  <Typography variant="h6">Escalation Paths</Typography>
                </AccordionSummary>
                <AccordionDetails>
                  <TableContainer>
                    <Table size="small">
                      <TableHead>
                        <TableRow>
                          <TableCell sx={{ color: "#38bdf8" }}>Vector</TableCell>
                          <TableCell sx={{ color: "#38bdf8" }}>Impact</TableCell>
                          <TableCell sx={{ color: "#38bdf8" }}>Signal</TableCell>
                        </TableRow>
                      </TableHead>
                      <TableBody>
                        {kubernetesEscalationPaths.map((item) => (
                          <TableRow key={item.vector}>
                            <TableCell sx={{ color: "grey.200", fontWeight: 600 }}>{item.vector}</TableCell>
                            <TableCell sx={{ color: "grey.400" }}>{item.impact}</TableCell>
                            <TableCell sx={{ color: "grey.400" }}>{item.signal}</TableCell>
                          </TableRow>
                        ))}
                      </TableBody>
                    </Table>
                  </TableContainer>
                </AccordionDetails>
              </Accordion>

              <Accordion>
                <AccordionSummary expandIcon={<ExpandMoreIcon />}>
                  <Typography variant="h6">Secrets and Service Accounts</Typography>
                </AccordionSummary>
                <AccordionDetails>
                  <List dense>
                    {[
                      "Service account tokens mounted in every pod by default.",
                      "Secrets stored in plaintext or with weak rotation.",
                      "ConfigMaps with credentials or API keys.",
                      "CI/CD tokens stored in namespaces shared by many teams.",
                    ].map((item) => (
                      <ListItem key={item}>
                        <ListItemIcon>
                          <CheckCircleIcon color="warning" fontSize="small" />
                        </ListItemIcon>
                        <ListItemText primary={item} sx={{ "& .MuiListItemText-primary": { color: "grey.300" } }} />
                      </ListItem>
                    ))}
                  </List>
                </AccordionDetails>
              </Accordion>

              <Accordion>
                <AccordionSummary expandIcon={<ExpandMoreIcon />}>
                  <Typography variant="h6">Node and Pod Escalation Paths</Typography>
                </AccordionSummary>
                <AccordionDetails>
                  <List dense>
                    {[
                      "Privileged pods with host PID or host network access.",
                      "HostPath volumes mounted read-write.",
                      "DaemonSets deployed with broad permissions.",
                      "Exposed kubelet read-only or unsecured metrics.",
                      "Access to container runtime sockets on the node.",
                    ].map((item) => (
                      <ListItem key={item}>
                        <ListItemIcon>
                          <CheckCircleIcon color="success" fontSize="small" />
                        </ListItemIcon>
                        <ListItemText primary={item} sx={{ "& .MuiListItemText-primary": { color: "grey.300" } }} />
                      </ListItem>
                    ))}
                  </List>
                </AccordionDetails>
              </Accordion>

              <Accordion>
                <AccordionSummary expandIcon={<ExpandMoreIcon />}>
                  <Typography variant="h6">Persistence Ideas</Typography>
                </AccordionSummary>
                <AccordionDetails>
                  <List dense>
                    {persistenceIdeas.map((item) => (
                      <ListItem key={item}>
                        <ListItemIcon>
                          <CheckCircleIcon color="info" fontSize="small" />
                        </ListItemIcon>
                        <ListItemText primary={item} sx={{ "& .MuiListItemText-primary": { color: "grey.300" } }} />
                      </ListItem>
                    ))}
                  </List>
                </AccordionDetails>
              </Accordion>
            </Box>
          </TabPanel>

          <TabPanel value={tabValue} index={3}>
            <Box sx={{ p: 3 }}>
              <Typography variant="h6" sx={{ color: "#38bdf8", mb: 2 }}>
                Tools for Offensive Assessment
              </Typography>
              <TableContainer sx={{ mb: 3 }}>
                <Table size="small">
                  <TableHead>
                    <TableRow>
                      <TableCell sx={{ color: "#38bdf8" }}>Tool</TableCell>
                      <TableCell sx={{ color: "#38bdf8" }}>Focus</TableCell>
                      <TableCell sx={{ color: "#38bdf8" }}>Use Case</TableCell>
                    </TableRow>
                  </TableHead>
                  <TableBody>
                    {[
                      ["Trivy", "Image and config scanning", "Find vulnerable packages and misconfigurations"],
                      ["Grype + Syft", "SBOM and vuln scanning", "Inventory and CVE mapping"],
                      ["kube-hunter", "Kubernetes recon", "Cluster attack surface discovery"],
                      ["kube-bench", "CIS checks", "Baseline hardening verification"],
                      ["kubectl + krew", "Native access", "Query RBAC and resources"],
                      ["Docker Bench", "Docker CIS checks", "Host and daemon validation"],
                    ].map(([tool, focus, use]) => (
                      <TableRow key={tool}>
                        <TableCell sx={{ color: "grey.200", fontWeight: 600 }}>{tool}</TableCell>
                        <TableCell sx={{ color: "grey.400" }}>{focus}</TableCell>
                        <TableCell sx={{ color: "grey.400" }}>{use}</TableCell>
                      </TableRow>
                    ))}
                  </TableBody>
                </Table>
              </TableContainer>

              <Typography variant="h6" sx={{ color: "#a5b4fc", mb: 2 }}>
                Recommended Lab Environments
              </Typography>
              <Grid container spacing={2}>
                {[
                  {
                    title: "Kubernetes Goat",
                    desc: "Intentionally vulnerable cluster scenarios for common attack paths.",
                  },
                  {
                    title: "KubeGoat",
                    desc: "Hands-on exercises for misconfigurations and RBAC abuse.",
                  },
                  {
                    title: "Kind or Minikube",
                    desc: "Local clusters for repeatable testing without touching production.",
                  },
                  {
                    title: "OWASP Juice Shop on K8s",
                    desc: "Pair web exploitation with container runtime learning.",
                  },
                ].map((lab) => (
                  <Grid item xs={12} md={6} key={lab.title}>
                    <Paper
                      sx={{
                        p: 2,
                        bgcolor: "#0c0f1c",
                        borderRadius: 2,
                        border: "1px solid rgba(99,102,241,0.3)",
                      }}
                    >
                      <Typography variant="subtitle1" sx={{ color: "#e2e8f0", fontWeight: 600 }}>
                        {lab.title}
                      </Typography>
                      <Typography variant="body2" sx={{ color: "grey.400" }}>
                        {lab.desc}
                      </Typography>
                    </Paper>
                  </Grid>
                ))}
              </Grid>

              <Paper sx={{ mt: 3, p: 2.5, bgcolor: "#0c0f1c", borderRadius: 2 }}>
                <Typography variant="h6" sx={{ color: "#38bdf8", mb: 2 }}>
                  Beginner Lab Quickstart (Local Cluster)
                </Typography>
                <Typography variant="body2" sx={{ color: "grey.400", mb: 1 }}>
                  Create a local cluster, deploy a simple app, and run basic recon. Use a disposable lab only.
                </Typography>
                <CodeBlock
                  code={`# Create a local cluster (kind)
kind create cluster --name k8s-lab
kubectl cluster-info

# Deploy a sample app
kubectl create ns demo
kubectl run demo-nginx --image=nginx --namespace demo
kubectl get pods -n demo -o wide

# Inspect the pod and its mounts
kubectl describe pod demo-nginx -n demo

# Cleanup
kind delete cluster --name k8s-lab`}
                />
                <Typography variant="body2" sx={{ color: "grey.400", mt: 2 }}>
                  If you use minikube instead of kind, replace the create and delete steps:
                </Typography>
                <CodeBlock
                  code={`# minikube alternative
minikube start
kubectl get nodes
minikube delete`}
                />
              </Paper>
            </Box>
          </TabPanel>

          <TabPanel value={tabValue} index={4}>
            <Box sx={{ p: 3 }}>
              <Paper sx={{ p: 2, bgcolor: "#0c0f1c", borderRadius: 2, mb: 2 }}>
                <Typography variant="subtitle1" sx={{ color: "#a5b4fc", mb: 1 }}>
                  Beginner Preflight
                </Typography>
                <List dense>
                  {[
                    "Confirm scope and permission to test before touching any cluster.",
                    "Work in a local or lab environment first.",
                    "Keep a simple notes file with commands and outputs.",
                    "Take screenshots of risky configurations for evidence.",
                  ].map((item) => (
                    <ListItem key={item}>
                      <ListItemIcon>
                        <CheckCircleIcon color="info" fontSize="small" />
                      </ListItemIcon>
                      <ListItemText primary={item} sx={{ "& .MuiListItemText-primary": { color: "grey.300" } }} />
                    </ListItem>
                  ))}
                </List>
              </Paper>

              <Typography variant="h6" sx={{ color: "#38bdf8", mb: 2 }}>
                Container Checklist
              </Typography>
              <List dense>
                {[
                  "Identify privileged or high-capability containers.",
                  "Check for mounted Docker or container runtime sockets.",
                  "Review base image age and vulnerability posture.",
                  "Look for secrets in image layers or environment variables.",
                  "Validate seccomp, AppArmor, and user namespaces.",
                ].map((item) => (
                  <ListItem key={item}>
                    <ListItemIcon>
                      <CheckCircleIcon color="success" fontSize="small" />
                    </ListItemIcon>
                    <ListItemText primary={item} sx={{ "& .MuiListItemText-primary": { color: "grey.300" } }} />
                  </ListItem>
                ))}
              </List>

              <Typography variant="h6" sx={{ color: "#a5b4fc", mt: 3, mb: 2 }}>
                Kubernetes Checklist
              </Typography>
              <List dense>
                {[
                  "Enumerate RBAC for cluster-admin or wildcard permissions.",
                  "Inspect service account token usage and secret access.",
                  "Check for hostPath volumes or privileged pods.",
                  "Review kubelet, API server, and etcd exposure.",
                  "Assess network policies and namespace isolation.",
                ].map((item) => (
                  <ListItem key={item}>
                    <ListItemIcon>
                      <CheckCircleIcon color="info" fontSize="small" />
                    </ListItemIcon>
                    <ListItemText primary={item} sx={{ "& .MuiListItemText-primary": { color: "grey.300" } }} />
                  </ListItem>
                ))}
              </List>

              <Typography variant="h6" sx={{ color: "#38bdf8", mt: 3, mb: 2 }}>
                Reporting Checklist
              </Typography>
              <List dense>
                {reportingChecklist.map((item) => (
                  <ListItem key={item}>
                    <ListItemIcon>
                      <CheckCircleIcon color="success" fontSize="small" />
                    </ListItemIcon>
                    <ListItemText primary={item} sx={{ "& .MuiListItemText-primary": { color: "grey.300" } }} />
                  </ListItem>
                ))}
              </List>
            </Box>
          </TabPanel>
        </Paper>

        <Paper
          id="quiz-section"
          sx={{
            mt: 4,
            p: 4,
            borderRadius: 3,
            border: `1px solid ${alpha(QUIZ_ACCENT_COLOR, 0.2)}`,
          }}
        >
          <Typography variant="h5" sx={{ fontWeight: 800, mb: 3, display: "flex", alignItems: "center", gap: 2 }}>
            <QuizIcon sx={{ color: QUIZ_ACCENT_COLOR }} />
            Knowledge Check
          </Typography>
          <QuizSection
            questions={quizQuestions}
            accentColor={QUIZ_ACCENT_COLOR}
            title="Container and Kubernetes Exploitation Knowledge Check"
            description="Random 10-question quiz drawn from a 75-question bank each time you start the quiz."
            questionsPerQuiz={QUIZ_QUESTION_COUNT}
          />
        </Paper>

        <Box sx={{ mt: 4, textAlign: "center" }}>
          <Button
            variant="outlined"
            startIcon={<ArrowBackIcon />}
            onClick={() => navigate("/learn")}
            sx={{ borderColor: "#38bdf8", color: "#38bdf8" }}
          >
            Back to Learning Hub
          </Button>
        </Box>
      </Container>
    </Box>
    </LearnPageLayout>
  );
};

export default ContainerKubernetesExploitationPage;
