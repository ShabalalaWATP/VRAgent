from fastapi import APIRouter, Depends, HTTPException, Query
from sqlalchemy.orm import Session
from sqlalchemy import case
from typing import Literal

from backend import models
from backend.core.database import get_db
from backend.core.auth import get_current_active_user
from backend.models.models import User
from backend.schemas import ExploitScenario
from backend.tasks.jobs import enqueue_exploitability
from backend.services.exploit_service import generate_attack_chain_diagram, generate_ai_attack_chain_diagram
from backend.core.logging import get_logger

logger = get_logger(__name__)

router = APIRouter()


def _get_report(db: Session, report_id: int) -> models.Report:
    report = db.get(models.Report, report_id)
    if not report:
        raise HTTPException(status_code=404, detail="Report not found")
    return report


@router.post("/{report_id}/exploitability")
def start_exploitability(
    report_id: int, 
    mode: Literal["full", "summary", "auto"] = Query(
        default="auto",
        description="Analysis mode: 'full' for individual LLM analysis (slow, detailed), "
                    "'summary' for executive summary + templates (fast, recommended for large codebases), "
                    "'auto' to select based on finding count (<=20 findings = full, >20 = summary)"
    ),
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_active_user),
):
    """
    Start exploitability analysis for a report.
    
    - **full**: Individual exploit scenarios with LLM analysis for each finding (slow but detailed)
    - **summary**: Single executive summary + template-based scenarios (fast, 1 LLM call max)
    - **auto**: Automatically selects based on finding count (default)
    """
    report = _get_report(db, report_id)
    enqueue_exploitability(report.id, mode=mode)
    return {"status": "queued", "mode": mode}


@router.get("/{report_id}/exploitability", response_model=list[ExploitScenario])
def list_exploitability(report_id: int, db: Session = Depends(get_db), current_user: User = Depends(get_current_active_user)):
    _get_report(db, report_id)
    
    # Order: Executive Summary first, then by severity (critical > high > medium), then by id
    severity_order = case(
        (models.ExploitScenario.severity == "critical", 0),
        (models.ExploitScenario.severity == "high", 1),
        (models.ExploitScenario.severity == "medium", 2),
        else_=3
    )
    summary_first = case(
        (models.ExploitScenario.title == "Exploit Development Summary", 0),
        else_=1
    )
    
    scenarios = (
        db.query(models.ExploitScenario)
        .filter(models.ExploitScenario.report_id == report_id)
        .order_by(summary_first, severity_order, models.ExploitScenario.id)
        .all()
    )
    return scenarios


@router.get("/{report_id}/exploitability/attack-chain")
async def get_attack_chain_diagram(
    report_id: int, 
    use_ai: bool = Query(default=True, description="Use AI to generate a more intelligent attack chain diagram"),
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_active_user),
):
    """
    Get a Mermaid attack chain diagram showing exploit paths.
    
    Returns a visual representation of:
    - Entry points (critical vulnerabilities)
    - Exploitation paths (high severity chains)
    - Lateral movement (medium severity)
    - Attack outcomes (what attackers can achieve)
    
    Args:
        report_id: ID of the report
        use_ai: If True, uses AI to generate a more intelligent diagram (default True)
        
    Returns:
        Mermaid diagram code for the attack chain
    """
    report = _get_report(db, report_id)
    
    # Get exploit scenarios
    scenarios = (
        db.query(models.ExploitScenario)
        .filter(models.ExploitScenario.report_id == report_id)
        .all()
    )
    
    if not scenarios:
        # No exploit scenarios yet - check if analysis has been run
        return {
            "report_id": report_id,
            "diagram": "flowchart TD\n    MSG@{ icon: \"fa:hourglass\", form: \"square\", label: \"Run Exploitability Analysis First\" }",
            "diagram_type": "flowchart",
            "message": "No exploit scenarios found. Run exploitability analysis first."
        }
    
    # Check for cached diagram
    if report.data and report.data.get("attack_chain_diagram"):
        cached = report.data.get("attack_chain_diagram")
        logger.info(f"Returning cached attack chain diagram for report {report_id}")
        return {
            "report_id": report_id,
            "diagram": cached.get("mermaid_code", ""),
            "diagram_type": "flowchart",
            "cached": True,
            "generated_by": cached.get("generated_by", "unknown")
        }
    
    # Generate diagram
    if use_ai:
        mermaid_code = await generate_ai_attack_chain_diagram(db, report, scenarios)
        generated_by = "ai"
    else:
        mermaid_code = generate_attack_chain_diagram(db, report, scenarios)
        generated_by = "template"
    
    # Cache the diagram
    report_data = report.data or {}
    report_data["attack_chain_diagram"] = {
        "mermaid_code": mermaid_code,
        "diagram_type": "flowchart",
        "generated_by": generated_by
    }
    report.data = report_data
    db.commit()
    logger.info(f"Generated and cached attack chain diagram for report {report_id}")
    
    return {
        "report_id": report_id,
        "diagram": mermaid_code,
        "diagram_type": "flowchart",
        "cached": False,
        "generated_by": generated_by
    }


@router.delete("/{report_id}/exploitability/attack-chain")
def clear_attack_chain_cache(
    report_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_active_user),
):
    """Clear the cached attack chain diagram to force regeneration."""
    report = _get_report(db, report_id)
    
    if report.data and "attack_chain_diagram" in report.data:
        report_data = report.data.copy()
        del report_data["attack_chain_diagram"]
        report.data = report_data
        db.commit()
        return {"status": "cleared", "message": "Attack chain diagram cache cleared"}
    
    return {"status": "not_found", "message": "No cached diagram found"}

