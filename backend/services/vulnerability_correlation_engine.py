"""
Vulnerability Correlation Engine

Analyzes findings to:
1. Identify root cause vulnerabilities
2. Discover attack chain opportunities
3. Cross-validate findings to reduce false positives
4. Prioritize findings by actual exploitability
5. Generate comprehensive impact assessments

Uses graph-based analysis for relationship discovery.
"""

import hashlib
import json
import logging
import uuid
from collections import defaultdict
from dataclasses import dataclass, field, asdict
from typing import Dict, List, Any, Optional, Set, Tuple
from enum import Enum
from datetime import datetime
import re

logger = logging.getLogger(__name__)


class CorrelationType(str, Enum):
    """Types of correlations between findings."""
    SAME_ROOT_CAUSE = "same_root_cause"       # Same underlying vulnerability
    CHAINED = "chained"                        # One enables another
    AMPLIFIED = "amplified"                    # Combined impact is higher
    DEPENDENT = "dependent"                    # Requires another to exploit
    CONTRADICTING = "contradicting"            # May indicate false positive
    CORROBORATING = "corroborating"            # Confirms finding validity


class FindingCategory(str, Enum):
    """High-level vulnerability categories."""
    INJECTION = "injection"
    AUTHENTICATION = "authentication"
    AUTHORIZATION = "authorization"
    CRYPTOGRAPHY = "cryptography"
    CONFIGURATION = "configuration"
    DATA_EXPOSURE = "data_exposure"
    INPUT_VALIDATION = "input_validation"
    SESSION_MANAGEMENT = "session_management"
    BUSINESS_LOGIC = "business_logic"
    INFRASTRUCTURE = "infrastructure"


class AttackChainImpact(str, Enum):
    """Impact levels for attack chains."""
    CATASTROPHIC = "catastrophic"    # Full system compromise
    SEVERE = "severe"                # Major data breach or RCE
    SIGNIFICANT = "significant"      # Significant unauthorized access
    MODERATE = "moderate"            # Limited data exposure
    MINOR = "minor"                  # Low impact chain


@dataclass
class VulnerabilityNode:
    """A node in the vulnerability correlation graph."""
    id: str
    finding_id: str
    technique: str
    category: FindingCategory
    severity: str
    endpoint: str
    parameter: Optional[str]
    cwe_id: Optional[str]
    cvss_score: float
    confidence: float
    exploitable: bool
    title: str
    description: str
    evidence: List[str] = field(default_factory=list)
    tags: Set[str] = field(default_factory=set)
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            **asdict(self),
            "category": self.category.value,
            "tags": list(self.tags),
        }


@dataclass
class CorrelationEdge:
    """An edge connecting two vulnerability nodes."""
    id: str
    source_id: str
    target_id: str
    correlation_type: CorrelationType
    strength: float  # 0.0 to 1.0
    reasoning: str
    data: Dict[str, Any] = field(default_factory=dict)
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            **asdict(self),
            "correlation_type": self.correlation_type.value,
        }


@dataclass
class AttackChain:
    """A discovered attack chain."""
    id: str
    name: str
    description: str
    steps: List[str]  # List of finding IDs in order
    entry_point: str
    final_impact: str
    impact_level: AttackChainImpact
    likelihood: float
    prerequisites: List[str]
    total_cvss: float
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            **asdict(self),
            "impact_level": self.impact_level.value,
        }


@dataclass
class RootCauseAnalysis:
    """Analysis of a root cause vulnerability."""
    id: str
    root_cause: str
    affected_findings: List[str]
    cwe_id: str
    description: str
    systemic: bool  # Affects multiple components
    fix_priority: str
    estimated_fix_effort: str
    
    def to_dict(self) -> Dict[str, Any]:
        return asdict(self)


@dataclass
class CorrelationReport:
    """Complete correlation analysis report."""
    id: str
    generated_at: str
    total_findings: int
    unique_endpoints: int
    correlations: List[CorrelationEdge]
    attack_chains: List[AttackChain]
    root_causes: List[RootCauseAnalysis]
    priority_ranking: List[Dict[str, Any]]
    false_positive_candidates: List[str]
    statistics: Dict[str, Any]
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            **asdict(self),
            "correlations": [c.to_dict() for c in self.correlations],
            "attack_chains": [c.to_dict() for c in self.attack_chains],
            "root_causes": [r.to_dict() for r in self.root_causes],
        }


# =============================================================================
# VULNERABILITY CLASSIFICATION
# =============================================================================

# CWE to Category mapping
CWE_CATEGORY_MAP = {
    # Injection
    "CWE-89": FindingCategory.INJECTION,    # SQL Injection
    "CWE-79": FindingCategory.INJECTION,    # XSS
    "CWE-78": FindingCategory.INJECTION,    # OS Command Injection
    "CWE-91": FindingCategory.INJECTION,    # XML Injection
    "CWE-90": FindingCategory.INJECTION,    # LDAP Injection
    "CWE-94": FindingCategory.INJECTION,    # Code Injection
    "CWE-917": FindingCategory.INJECTION,   # Expression Language Injection
    
    # Authentication
    "CWE-287": FindingCategory.AUTHENTICATION,  # Improper Authentication
    "CWE-306": FindingCategory.AUTHENTICATION,  # Missing Authentication
    "CWE-307": FindingCategory.AUTHENTICATION,  # Brute Force
    "CWE-521": FindingCategory.AUTHENTICATION,  # Weak Password
    "CWE-798": FindingCategory.AUTHENTICATION,  # Hardcoded Credentials
    
    # Authorization
    "CWE-862": FindingCategory.AUTHORIZATION,   # Missing Authorization
    "CWE-863": FindingCategory.AUTHORIZATION,   # Incorrect Authorization
    "CWE-639": FindingCategory.AUTHORIZATION,   # IDOR
    "CWE-284": FindingCategory.AUTHORIZATION,   # Improper Access Control
    
    # Cryptography
    "CWE-327": FindingCategory.CRYPTOGRAPHY,    # Broken Crypto
    "CWE-328": FindingCategory.CRYPTOGRAPHY,    # Weak Hash
    "CWE-330": FindingCategory.CRYPTOGRAPHY,    # Insufficient Randomness
    "CWE-326": FindingCategory.CRYPTOGRAPHY,    # Inadequate Encryption
    
    # Configuration
    "CWE-16": FindingCategory.CONFIGURATION,    # Configuration
    "CWE-209": FindingCategory.CONFIGURATION,   # Error Messages
    "CWE-532": FindingCategory.CONFIGURATION,   # Info in Log
    "CWE-200": FindingCategory.DATA_EXPOSURE,   # Information Exposure
    
    # Session
    "CWE-384": FindingCategory.SESSION_MANAGEMENT,  # Session Fixation
    "CWE-613": FindingCategory.SESSION_MANAGEMENT,  # Session Expiration
    "CWE-614": FindingCategory.SESSION_MANAGEMENT,  # Sensitive Cookie
    
    # Input Validation
    "CWE-20": FindingCategory.INPUT_VALIDATION,     # Input Validation
    "CWE-22": FindingCategory.INPUT_VALIDATION,     # Path Traversal
    "CWE-73": FindingCategory.INPUT_VALIDATION,     # External Control
    
    # Business Logic
    "CWE-840": FindingCategory.BUSINESS_LOGIC,      # Business Logic
    "CWE-362": FindingCategory.BUSINESS_LOGIC,      # Race Condition
    
    # Infrastructure
    "CWE-918": FindingCategory.INFRASTRUCTURE,      # SSRF
    "CWE-444": FindingCategory.INFRASTRUCTURE,      # HTTP Smuggling
    "CWE-400": FindingCategory.INFRASTRUCTURE,      # Resource Exhaustion
}

# Technique to CWE mapping
TECHNIQUE_CWE_MAP = {
    "sql_injection": "CWE-89",
    "xss": "CWE-79",
    "command_injection": "CWE-78",
    "path_traversal": "CWE-22",
    "ssti": "CWE-94",
    "xxe": "CWE-611",
    "ssrf": "CWE-918",
    "idor": "CWE-639",
    "auth_bypass": "CWE-287",
    "jwt_attack": "CWE-347",
    "http_smuggling": "CWE-444",
    "race_condition": "CWE-362",
    "csrf": "CWE-352",
    "open_redirect": "CWE-601",
    "header_injection": "CWE-113",
}

# Attack chain templates
CHAIN_TEMPLATES = {
    "ssrf_to_rce": {
        "name": "SSRF to Remote Code Execution",
        "steps": ["ssrf", "internal_access", "command_injection"],
        "impact": AttackChainImpact.CATASTROPHIC,
        "prerequisites": ["SSRF to internal services", "Vulnerable internal service"],
    },
    "sqli_to_exfil": {
        "name": "SQL Injection to Data Exfiltration",
        "steps": ["sql_injection", "data_extraction", "credential_theft"],
        "impact": AttackChainImpact.SEVERE,
        "prerequisites": ["Exploitable SQL injection"],
    },
    "auth_bypass_to_admin": {
        "name": "Authentication Bypass to Admin Access",
        "steps": ["auth_bypass", "privilege_escalation", "admin_access"],
        "impact": AttackChainImpact.SEVERE,
        "prerequisites": ["Auth bypass vulnerability", "Admin functionality"],
    },
    "xss_to_session": {
        "name": "XSS to Session Hijacking",
        "steps": ["xss", "cookie_theft", "session_hijack"],
        "impact": AttackChainImpact.SIGNIFICANT,
        "prerequisites": ["Stored XSS", "Session cookies without HttpOnly"],
    },
    "idor_chain": {
        "name": "IDOR to Data Breach",
        "steps": ["idor", "enumeration", "mass_data_access"],
        "impact": AttackChainImpact.SEVERE,
        "prerequisites": ["Predictable identifiers", "No rate limiting"],
    },
    "lfi_to_rce": {
        "name": "LFI to RCE via Log Poisoning",
        "steps": ["path_traversal", "log_read", "log_poison", "rce"],
        "impact": AttackChainImpact.CATASTROPHIC,
        "prerequisites": ["LFI vulnerability", "Log file access", "PHP/interpreted backend"],
    },
    # HTTP Request Smuggling Chains
    "smuggling_to_cache_poison": {
        "name": "HTTP Smuggling to Cache Poisoning",
        "steps": ["http_smuggling", "cache_manipulation", "xss"],
        "impact": AttackChainImpact.CATASTROPHIC,
        "prerequisites": ["Request smuggling vulnerability", "Caching proxy"],
    },
    "smuggling_to_auth_bypass": {
        "name": "HTTP Smuggling to Auth Bypass",
        "steps": ["http_smuggling", "request_routing", "auth_bypass"],
        "impact": AttackChainImpact.CATASTROPHIC,
        "prerequisites": ["Request smuggling", "Frontend auth checks"],
    },
    "smuggling_to_request_hijack": {
        "name": "HTTP Smuggling to Request Hijacking",
        "steps": ["http_smuggling", "prefix_injection", "credential_theft"],
        "impact": AttackChainImpact.CATASTROPHIC,
        "prerequisites": ["CL.TE or TE.CL vulnerability"],
    },
    # Race Condition Chains
    "race_to_double_spend": {
        "name": "Race Condition to Double Spend",
        "steps": ["race_condition", "balance_bypass", "financial_fraud"],
        "impact": AttackChainImpact.SEVERE,
        "prerequisites": ["Transaction endpoint", "No locking mechanism"],
    },
    "race_to_privilege_escalation": {
        "name": "Race Condition to Privilege Escalation",
        "steps": ["race_condition", "role_assignment", "privilege_escalation"],
        "impact": AttackChainImpact.SEVERE,
        "prerequisites": ["Registration/role endpoint", "TOCTOU vulnerability"],
    },
    # JWT Attack Chains
    "jwt_to_admin": {
        "name": "JWT Exploitation to Admin Access",
        "steps": ["jwt_attack", "signature_bypass", "claim_tampering", "admin_access"],
        "impact": AttackChainImpact.SEVERE,
        "prerequisites": ["JWT authentication", "Weak validation"],
    },
    "jwt_to_account_takeover": {
        "name": "JWT Key Confusion to Account Takeover",
        "steps": ["jwt_attack", "key_confusion", "token_forge", "account_takeover"],
        "impact": AttackChainImpact.CATASTROPHIC,
        "prerequisites": ["RS256 to HS256 confusion", "Public key accessible"],
    },
    # SSTI Chains
    "ssti_to_rce": {
        "name": "SSTI to RCE",
        "steps": ["ssti", "template_execution", "command_injection"],
        "impact": AttackChainImpact.CATASTROPHIC,
        "prerequisites": ["Template injection", "Dangerous template engine"],
    },
    "ssti_to_secrets": {
        "name": "SSTI to Secret Exfiltration",
        "steps": ["ssti", "config_access", "credential_theft"],
        "impact": AttackChainImpact.SEVERE,
        "prerequisites": ["SSTI vulnerability", "Config in template context"],
    },
    # Prototype Pollution Chains
    "prototype_to_rce": {
        "name": "Prototype Pollution to RCE",
        "steps": ["prototype_pollution", "env_pollution", "command_injection"],
        "impact": AttackChainImpact.CATASTROPHIC,
        "prerequisites": ["Prototype pollution sink", "Node.js backend"],
    },
    "prototype_to_xss": {
        "name": "Prototype Pollution to XSS",
        "steps": ["prototype_pollution", "dom_pollution", "xss"],
        "impact": AttackChainImpact.SIGNIFICANT,
        "prerequisites": ["Client-side prototype pollution", "DOM rendering"],
    },
    # Cache Poisoning Chains
    "cache_poison_to_xss": {
        "name": "Cache Poisoning to Mass XSS",
        "steps": ["cache_poisoning", "header_injection", "xss"],
        "impact": AttackChainImpact.CATASTROPHIC,
        "prerequisites": ["Unkeyed header reflection", "Caching enabled"],
    },
    "cache_deception_to_data": {
        "name": "Cache Deception to Data Theft",
        "steps": ["cache_poisoning", "path_manipulation", "data_extraction"],
        "impact": AttackChainImpact.SEVERE,
        "prerequisites": ["Path-based caching", "Static file extensions"],
    },
    # GraphQL Chains
    "graphql_introspection_to_data": {
        "name": "GraphQL Introspection to Data Theft",
        "steps": ["graphql", "schema_discovery", "data_extraction"],
        "impact": AttackChainImpact.SEVERE,
        "prerequisites": ["Introspection enabled", "Sensitive types exposed"],
    },
    "graphql_batching_bypass": {
        "name": "GraphQL Batching Rate Limit Bypass",
        "steps": ["graphql", "query_batching", "brute_force", "auth_bypass"],
        "impact": AttackChainImpact.SIGNIFICANT,
        "prerequisites": ["Batching allowed", "No per-operation limits"],
    },
    # CORS Chains
    "cors_to_data_theft": {
        "name": "CORS Misconfiguration to Data Theft",
        "steps": ["cors_bypass", "cross_origin_request", "data_extraction"],
        "impact": AttackChainImpact.SEVERE,
        "prerequisites": ["Reflected origin", "Credentials allowed"],
    },
    # Mass Assignment Chains
    "mass_assign_to_admin": {
        "name": "Mass Assignment to Admin",
        "steps": ["mass_assignment", "role_injection", "privilege_escalation"],
        "impact": AttackChainImpact.SEVERE,
        "prerequisites": ["Unprotected model binding", "Role field accessible"],
    },
    # XXE Chains
    "xxe_to_file_read": {
        "name": "XXE to File Exfiltration",
        "steps": ["xxe", "entity_expansion", "file_read"],
        "impact": AttackChainImpact.SEVERE,
        "prerequisites": ["XML parsing", "External entities allowed"],
    },
    "xxe_to_ssrf_to_rce": {
        "name": "XXE to SSRF to RCE",
        "steps": ["xxe", "ssrf", "internal_access", "command_injection"],
        "impact": AttackChainImpact.CATASTROPHIC,
        "prerequisites": ["XXE with HTTP entity", "Vulnerable internal service"],
    },
    # Open Redirect Chains
    "redirect_to_oauth_theft": {
        "name": "Open Redirect to OAuth Token Theft",
        "steps": ["open_redirect", "oauth_manipulation", "token_theft"],
        "impact": AttackChainImpact.SEVERE,
        "prerequisites": ["Open redirect", "OAuth implementation"],
    },
    # Deserialization Chains
    "deserialize_to_rce": {
        "name": "Insecure Deserialization to RCE",
        "steps": ["business_logic", "deserialization", "command_injection"],
        "impact": AttackChainImpact.CATASTROPHIC,
        "prerequisites": ["Serialized input", "Dangerous deserializer"],
    },
    # WebSocket Chains
    "websocket_csrf": {
        "name": "WebSocket CSRF to Action",
        "steps": ["websocket", "cross_origin_connect", "action_execution"],
        "impact": AttackChainImpact.SIGNIFICANT,
        "prerequisites": ["No origin validation", "Authenticated WebSocket"],
    },
}


# =============================================================================
# CORRELATION ENGINE
# =============================================================================

class VulnerabilityCorrelationEngine:
    """
    Analyzes vulnerability findings to identify correlations,
    attack chains, and root causes.
    """
    
    def __init__(self):
        self._nodes: Dict[str, VulnerabilityNode] = {}
        self._edges: List[CorrelationEdge] = []
        self._adjacency: Dict[str, List[str]] = defaultdict(list)
        self._reports: List[CorrelationReport] = []
    
    def _categorize_finding(self, finding: Dict[str, Any]) -> FindingCategory:
        """Categorize a finding based on CWE or technique."""
        cwe = finding.get("cwe_id", "")
        technique = finding.get("technique", "").lower()
        
        # Try CWE mapping first
        if cwe in CWE_CATEGORY_MAP:
            return CWE_CATEGORY_MAP[cwe]
        
        # Try technique to CWE mapping
        if technique in TECHNIQUE_CWE_MAP:
            mapped_cwe = TECHNIQUE_CWE_MAP[technique]
            if mapped_cwe in CWE_CATEGORY_MAP:
                return CWE_CATEGORY_MAP[mapped_cwe]
        
        # Default based on technique keywords
        technique_lower = technique.lower()
        if "injection" in technique_lower or "sqli" in technique_lower or "xss" in technique_lower:
            return FindingCategory.INJECTION
        if "auth" in technique_lower or "login" in technique_lower:
            return FindingCategory.AUTHENTICATION
        if "idor" in technique_lower or "access" in technique_lower:
            return FindingCategory.AUTHORIZATION
        
        return FindingCategory.INPUT_VALIDATION
    
    def _generate_tags(self, finding: Dict[str, Any]) -> Set[str]:
        """Generate tags for a finding."""
        tags = set()
        
        technique = finding.get("technique", "").lower()
        endpoint = finding.get("endpoint", "")
        
        # Technique-based tags
        if "sql" in technique:
            tags.add("database")
            tags.add("injection")
        if "xss" in technique:
            tags.add("client-side")
            tags.add("injection")
        if "command" in technique:
            tags.add("rce")
            tags.add("server-side")
        if "ssrf" in technique:
            tags.add("network")
            tags.add("server-side")
        if "path" in technique or "traversal" in technique:
            tags.add("file-system")
        if "auth" in technique:
            tags.add("access-control")
        if "jwt" in technique:
            tags.add("token")
            tags.add("authentication")
        
        # Endpoint-based tags
        if "/api/" in endpoint:
            tags.add("api")
        if "/admin" in endpoint:
            tags.add("admin")
            tags.add("high-value")
        if "login" in endpoint or "auth" in endpoint:
            tags.add("authentication")
        if "upload" in endpoint:
            tags.add("file-upload")
        if "user" in endpoint:
            tags.add("user-data")
        
        return tags
    
    def add_finding(self, finding: Dict[str, Any]) -> VulnerabilityNode:
        """Add a finding to the correlation graph."""
        node_id = finding.get("id", str(uuid.uuid4())[:8])
        
        if node_id in self._nodes:
            return self._nodes[node_id]
        
        node = VulnerabilityNode(
            id=node_id,
            finding_id=finding.get("id", node_id),
            technique=finding.get("technique", "unknown"),
            category=self._categorize_finding(finding),
            severity=finding.get("severity", "medium"),
            endpoint=finding.get("endpoint", ""),
            parameter=finding.get("parameter"),
            cwe_id=finding.get("cwe_id") or TECHNIQUE_CWE_MAP.get(finding.get("technique", "").lower()),
            cvss_score=finding.get("cvss_score", 0.0),
            confidence=finding.get("confidence", 0.5),
            exploitable=finding.get("exploitable", False),
            title=finding.get("title", ""),
            description=finding.get("description", ""),
            evidence=finding.get("evidence", []),
            tags=self._generate_tags(finding),
        )
        
        self._nodes[node_id] = node
        return node
    
    def add_correlation(
        self,
        source_id: str,
        target_id: str,
        correlation_type: CorrelationType,
        strength: float,
        reasoning: str,
    ) -> CorrelationEdge:
        """Add a correlation between two findings."""
        edge = CorrelationEdge(
            id=str(uuid.uuid4())[:8],
            source_id=source_id,
            target_id=target_id,
            correlation_type=correlation_type,
            strength=strength,
            reasoning=reasoning,
        )
        
        self._edges.append(edge)
        self._adjacency[source_id].append(target_id)
        
        return edge
    
    def _calculate_similarity(
        self,
        node1: VulnerabilityNode,
        node2: VulnerabilityNode,
    ) -> Tuple[float, List[str]]:
        """Calculate similarity between two nodes."""
        score = 0.0
        reasons = []
        
        # Same endpoint
        if node1.endpoint == node2.endpoint:
            score += 0.3
            reasons.append("Same endpoint")
        elif self._endpoints_similar(node1.endpoint, node2.endpoint):
            score += 0.15
            reasons.append("Similar endpoint")
        
        # Same category
        if node1.category == node2.category:
            score += 0.2
            reasons.append("Same vulnerability category")
        
        # Same CWE
        if node1.cwe_id and node1.cwe_id == node2.cwe_id:
            score += 0.25
            reasons.append(f"Same CWE ({node1.cwe_id})")
        
        # Related CWEs (same family)
        if node1.cwe_id and node2.cwe_id:
            if self._cwes_related(node1.cwe_id, node2.cwe_id):
                score += 0.15
                reasons.append("Related CWEs")
        
        # Shared tags
        shared_tags = node1.tags & node2.tags
        if shared_tags:
            score += min(len(shared_tags) * 0.05, 0.2)
            reasons.append(f"Shared tags: {', '.join(shared_tags)}")
        
        # Same parameter
        if node1.parameter and node1.parameter == node2.parameter:
            score += 0.1
            reasons.append("Same parameter")
        
        return min(score, 1.0), reasons
    
    def _endpoints_similar(self, ep1: str, ep2: str) -> bool:
        """Check if two endpoints are similar."""
        # Remove query params and trailing slashes
        ep1_clean = ep1.split("?")[0].rstrip("/")
        ep2_clean = ep2.split("?")[0].rstrip("/")
        
        # Check path prefix match
        parts1 = ep1_clean.split("/")
        parts2 = ep2_clean.split("/")
        
        common = 0
        for p1, p2 in zip(parts1, parts2):
            if p1 == p2:
                common += 1
            elif self._is_id_segment(p1) and self._is_id_segment(p2):
                common += 0.5
            else:
                break
        
        return common >= len(parts1) * 0.6 or common >= len(parts2) * 0.6
    
    def _is_id_segment(self, segment: str) -> bool:
        """Check if a URL segment is likely an ID."""
        if segment.isdigit():
            return True
        if len(segment) == 36 and "-" in segment:  # UUID
            return True
        if re.match(r'^[a-f0-9]{24}$', segment):  # MongoDB ObjectId
            return True
        return False
    
    def _cwes_related(self, cwe1: str, cwe2: str) -> bool:
        """Check if two CWEs are in the same family."""
        # Extract CWE numbers
        try:
            n1 = int(cwe1.replace("CWE-", ""))
            n2 = int(cwe2.replace("CWE-", ""))
        except ValueError:
            return False
        
        # Define CWE families (simplified)
        families = [
            {89, 564, 943},     # SQL Injection family
            {78, 77, 88},       # OS Command family
            {79, 80, 81, 83},   # XSS family
            {22, 23, 36, 73},   # Path Traversal family
            {287, 306, 307},    # Authentication family
            {862, 863, 639},    # Authorization family
        ]
        
        for family in families:
            if n1 in family and n2 in family:
                return True
        
        return False
    
    def _can_chain(
        self,
        source: VulnerabilityNode,
        target: VulnerabilityNode,
    ) -> Tuple[bool, str]:
        """Check if source can enable target in an attack chain."""
        # Define chain relationships
        chain_rules = [
            # SSRF enables internal access
            (["ssrf", "blind_ssrf"], ["command_injection", "sql_injection", "xxe"], 
             "SSRF can access internal services with {target}"),
            
            # SQLi enables data access
            (["sql_injection", "blind_sqli"], ["auth_bypass", "idor"], 
             "SQL Injection can extract credentials for {target}"),
            
            # Auth bypass enables everything
            (["auth_bypass", "jwt_attack"], ["idor", "command_injection", "path_traversal"], 
             "Authentication bypass enables access to {target}"),
            
            # LFI enables various attacks
            (["path_traversal", "lfi"], ["command_injection", "ssti"], 
             "File inclusion can be escalated to {target}"),
            
            # XSS enables session attacks
            (["xss", "stored_xss"], ["session_hijack", "csrf"], 
             "XSS can steal sessions for {target}"),
            
            # IDOR enables data theft
            (["idor"], ["data_exposure", "mass_assignment"], 
             "IDOR can be used to access {target}"),
        ]
        
        source_tech = source.technique.lower()
        target_tech = target.technique.lower()
        
        for source_patterns, target_patterns, reason_template in chain_rules:
            source_match = any(p in source_tech for p in source_patterns)
            target_match = any(p in target_tech for p in target_patterns)
            
            if source_match and target_match:
                return True, reason_template.format(target=target.technique)
        
        # Category-based chaining
        chain_categories = {
            FindingCategory.AUTHENTICATION: [
                FindingCategory.AUTHORIZATION, 
                FindingCategory.DATA_EXPOSURE,
            ],
            FindingCategory.AUTHORIZATION: [
                FindingCategory.DATA_EXPOSURE,
            ],
            FindingCategory.INJECTION: [
                FindingCategory.DATA_EXPOSURE,
                FindingCategory.INFRASTRUCTURE,
            ],
            FindingCategory.INFRASTRUCTURE: [
                FindingCategory.INJECTION,
            ],
        }
        
        if source.category in chain_categories:
            if target.category in chain_categories[source.category]:
                return True, f"{source.category.value} can enable {target.category.value}"
        
        return False, ""
    
    def analyze(self, findings: List[Dict[str, Any]]) -> CorrelationReport:
        """
        Perform full correlation analysis on findings.
        """
        # Reset for new analysis
        self._nodes.clear()
        self._edges.clear()
        self._adjacency.clear()
        
        # Add all findings as nodes
        for finding in findings:
            self.add_finding(finding)
        
        nodes = list(self._nodes.values())
        
        # Find correlations between all pairs
        for i, node1 in enumerate(nodes):
            for node2 in nodes[i + 1:]:
                # Check for same root cause
                similarity, reasons = self._calculate_similarity(node1, node2)
                
                if similarity >= 0.5:
                    self.add_correlation(
                        node1.id, node2.id,
                        CorrelationType.SAME_ROOT_CAUSE,
                        similarity,
                        "; ".join(reasons),
                    )
                
                # Check for chain potential
                can_chain, chain_reason = self._can_chain(node1, node2)
                if can_chain:
                    self.add_correlation(
                        node1.id, node2.id,
                        CorrelationType.CHAINED,
                        0.7,
                        chain_reason,
                    )
                
                can_chain_reverse, chain_reason_reverse = self._can_chain(node2, node1)
                if can_chain_reverse:
                    self.add_correlation(
                        node2.id, node1.id,
                        CorrelationType.CHAINED,
                        0.7,
                        chain_reason_reverse,
                    )
                
                # Check for corroborating evidence
                if (node1.endpoint == node2.endpoint and 
                    node1.technique == node2.technique and
                    node1.confidence > 0.5 and node2.confidence > 0.5):
                    self.add_correlation(
                        node1.id, node2.id,
                        CorrelationType.CORROBORATING,
                        0.8,
                        "Multiple detections of same vulnerability confirm finding",
                    )
        
        # Discover attack chains
        attack_chains = self._discover_attack_chains()
        
        # Identify root causes
        root_causes = self._identify_root_causes()
        
        # Prioritize findings
        priority_ranking = self._prioritize_findings()
        
        # Identify potential false positives
        false_positives = self._identify_false_positives()
        
        # Generate statistics
        statistics = self._generate_statistics()
        
        report = CorrelationReport(
            id=str(uuid.uuid4())[:8],
            generated_at=datetime.utcnow().isoformat(),
            total_findings=len(findings),
            unique_endpoints=len(set(n.endpoint for n in nodes)),
            correlations=self._edges,
            attack_chains=attack_chains,
            root_causes=root_causes,
            priority_ranking=priority_ranking,
            false_positive_candidates=[fp for fp in false_positives],
            statistics=statistics,
        )
        
        self._reports.append(report)
        return report
    
    def _discover_attack_chains(self) -> List[AttackChain]:
        """Discover attack chains from correlations."""
        chains = []
        
        # Find all chain-type edges
        chain_edges = [e for e in self._edges if e.correlation_type == CorrelationType.CHAINED]
        
        # Build chains using DFS
        visited = set()
        
        def build_chain(start_id: str, path: List[str], depth: int = 0) -> List[List[str]]:
            if depth > 5:  # Max chain length
                return [path]
            
            chains_found = []
            
            # Find outgoing chain edges
            for edge in chain_edges:
                if edge.source_id == start_id and edge.target_id not in path:
                    new_path = path + [edge.target_id]
                    chains_found.extend(build_chain(edge.target_id, new_path, depth + 1))
            
            if not chains_found:
                return [path] if len(path) > 1 else []
            
            return chains_found
        
        # Start from each node
        for node_id in self._nodes:
            found = build_chain(node_id, [node_id])
            for chain_path in found:
                if len(chain_path) >= 2:
                    chains.append(chain_path)
        
        # Convert to AttackChain objects
        attack_chains = []
        seen_chains = set()
        
        for chain_path in chains:
            chain_key = tuple(chain_path)
            if chain_key in seen_chains:
                continue
            seen_chains.add(chain_key)
            
            nodes = [self._nodes[nid] for nid in chain_path]
            
            # Calculate impact
            max_cvss = max(n.cvss_score for n in nodes)
            impact_level = self._calculate_chain_impact(nodes)
            
            # Generate name and description
            techniques = [n.technique for n in nodes]
            name = " â†’ ".join(techniques[:3])
            if len(techniques) > 3:
                name += f" (+{len(techniques)-3} more)"
            
            attack_chains.append(AttackChain(
                id=str(uuid.uuid4())[:8],
                name=name,
                description=f"Attack chain through {len(nodes)} vulnerabilities",
                steps=chain_path,
                entry_point=nodes[0].endpoint,
                final_impact=self._describe_chain_impact(nodes),
                impact_level=impact_level,
                likelihood=self._calculate_chain_likelihood(nodes),
                prerequisites=[f"Exploitable {n.technique}" for n in nodes],
                total_cvss=min(max_cvss + len(nodes) * 0.5, 10.0),
            ))
        
        # Sort by impact
        attack_chains.sort(
            key=lambda c: ["minor", "moderate", "significant", "severe", "catastrophic"].index(c.impact_level.value),
            reverse=True,
        )
        
        return attack_chains[:10]  # Top 10 chains
    
    def _calculate_chain_impact(self, nodes: List[VulnerabilityNode]) -> AttackChainImpact:
        """Calculate impact level for an attack chain."""
        # Check for high-impact patterns
        techniques = {n.technique.lower() for n in nodes}
        categories = {n.category for n in nodes}
        
        # Catastrophic: RCE involved
        if any("command" in t or "rce" in t for t in techniques):
            return AttackChainImpact.CATASTROPHIC
        
        # Severe: Auth + Data combination
        if (FindingCategory.AUTHENTICATION in categories and 
            FindingCategory.DATA_EXPOSURE in categories):
            return AttackChainImpact.SEVERE
        
        # Severe: Multiple injections
        injection_count = sum(1 for n in nodes if n.category == FindingCategory.INJECTION)
        if injection_count >= 2:
            return AttackChainImpact.SEVERE
        
        # Significant: Auth bypass or IDOR chain
        if any("auth" in t or "idor" in t for t in techniques):
            return AttackChainImpact.SIGNIFICANT
        
        # Default based on chain length
        if len(nodes) >= 3:
            return AttackChainImpact.MODERATE
        
        return AttackChainImpact.MINOR
    
    def _describe_chain_impact(self, nodes: List[VulnerabilityNode]) -> str:
        """Generate impact description for chain."""
        techniques = [n.technique for n in nodes]
        
        impact_templates = {
            "command_injection": "Remote code execution on the server",
            "sql_injection": "Database access and data exfiltration",
            "auth_bypass": "Unauthorized access to protected resources",
            "idor": "Access to other users' data",
            "ssrf": "Access to internal network resources",
            "xss": "Client-side code execution and session theft",
        }
        
        # Find most severe impact
        for tech, impact in impact_templates.items():
            if any(tech in t.lower() for t in techniques):
                return impact
        
        return "Escalated access through chained vulnerabilities"
    
    def _calculate_chain_likelihood(self, nodes: List[VulnerabilityNode]) -> float:
        """Calculate likelihood of successful chain exploitation."""
        if not nodes:
            return 0.0
        
        # Multiply probabilities (confidences)
        likelihood = 1.0
        for node in nodes:
            likelihood *= node.confidence
        
        # Boost if all exploitable
        if all(n.exploitable for n in nodes):
            likelihood = min(likelihood * 1.5, 1.0)
        
        return likelihood
    
    def _identify_root_causes(self) -> List[RootCauseAnalysis]:
        """Identify root cause vulnerabilities."""
        root_causes = []
        
        # Group findings by correlation
        same_root = [e for e in self._edges if e.correlation_type == CorrelationType.SAME_ROOT_CAUSE]
        
        # Use union-find to group connected findings
        parent = {nid: nid for nid in self._nodes}
        
        def find(x):
            if parent[x] != x:
                parent[x] = find(parent[x])
            return parent[x]
        
        def union(x, y):
            px, py = find(x), find(y)
            if px != py:
                parent[px] = py
        
        for edge in same_root:
            if edge.strength >= 0.5:
                union(edge.source_id, edge.target_id)
        
        # Group by root
        groups = defaultdict(list)
        for nid in self._nodes:
            groups[find(nid)].append(nid)
        
        # Create root cause analysis for multi-finding groups
        for root_id, member_ids in groups.items():
            if len(member_ids) < 2:
                continue
            
            members = [self._nodes[mid] for mid in member_ids]
            
            # Determine common CWE
            cwes = [m.cwe_id for m in members if m.cwe_id]
            common_cwe = max(set(cwes), key=cwes.count) if cwes else "CWE-20"
            
            # Determine if systemic
            endpoints = set(m.endpoint for m in members)
            systemic = len(endpoints) > 1
            
            # Determine priority based on severity
            max_severity = max(members, key=lambda m: ["low", "medium", "high", "critical"].index(m.severity))
            
            root_causes.append(RootCauseAnalysis(
                id=str(uuid.uuid4())[:8],
                root_cause=self._describe_root_cause(members),
                affected_findings=member_ids,
                cwe_id=common_cwe,
                description=f"Common vulnerability affecting {len(member_ids)} findings across {len(endpoints)} endpoints",
                systemic=systemic,
                fix_priority=max_severity.severity,
                estimated_fix_effort="days" if systemic else "hours",
            ))
        
        return root_causes
    
    def _describe_root_cause(self, nodes: List[VulnerabilityNode]) -> str:
        """Describe the root cause for a group of findings."""
        categories = [n.category for n in nodes]
        most_common = max(set(categories), key=categories.count)
        
        descriptions = {
            FindingCategory.INJECTION: "Insufficient input validation allowing injection attacks",
            FindingCategory.AUTHENTICATION: "Weak authentication implementation",
            FindingCategory.AUTHORIZATION: "Improper access control checks",
            FindingCategory.INPUT_VALIDATION: "Missing or incomplete input sanitization",
            FindingCategory.CONFIGURATION: "Insecure default configuration",
            FindingCategory.SESSION_MANAGEMENT: "Session handling vulnerabilities",
        }
        
        return descriptions.get(most_common, "Common security weakness")
    
    def _prioritize_findings(self) -> List[Dict[str, Any]]:
        """Prioritize findings by risk and exploitability."""
        rankings = []
        
        for node in self._nodes.values():
            # Calculate risk score
            base_score = node.cvss_score
            
            # Boost for exploitability
            if node.exploitable:
                base_score += 1.0
            
            # Boost for high confidence
            base_score += node.confidence * 0.5
            
            # Boost for being part of attack chain
            chain_count = sum(
                1 for e in self._edges 
                if e.correlation_type == CorrelationType.CHAINED
                and (e.source_id == node.id or e.target_id == node.id)
            )
            base_score += chain_count * 0.3
            
            # Boost for high-value tags
            high_value_tags = {"admin", "authentication", "rce", "high-value"}
            if node.tags & high_value_tags:
                base_score += 0.5
            
            rankings.append({
                "finding_id": node.id,
                "title": node.title,
                "technique": node.technique,
                "risk_score": min(base_score, 10.0),
                "severity": node.severity,
                "exploitable": node.exploitable,
                "chain_potential": chain_count > 0,
                "endpoint": node.endpoint,
            })
        
        # Sort by risk score
        rankings.sort(key=lambda x: x["risk_score"], reverse=True)
        
        # Add priority rank
        for i, r in enumerate(rankings):
            r["priority"] = i + 1
        
        return rankings
    
    def _identify_false_positives(self) -> List[str]:
        """Identify potential false positive findings."""
        fp_candidates = []
        
        for node in self._nodes.values():
            fp_score = 0
            
            # Low confidence
            if node.confidence < 0.5:
                fp_score += 1
            
            # No evidence
            if not node.evidence:
                fp_score += 1
            
            # Not exploitable
            if not node.exploitable:
                fp_score += 0.5
            
            # Contradicting correlations
            contradicting = sum(
                1 for e in self._edges
                if e.correlation_type == CorrelationType.CONTRADICTING
                and (e.source_id == node.id or e.target_id == node.id)
            )
            fp_score += contradicting
            
            # No corroborating evidence
            corroborating = sum(
                1 for e in self._edges
                if e.correlation_type == CorrelationType.CORROBORATING
                and (e.source_id == node.id or e.target_id == node.id)
            )
            if corroborating == 0 and len(self._nodes) > 1:
                fp_score += 0.5
            
            if fp_score >= 2:
                fp_candidates.append(node.id)
        
        return fp_candidates
    
    def _generate_statistics(self) -> Dict[str, Any]:
        """Generate analysis statistics."""
        nodes = list(self._nodes.values())
        
        return {
            "total_nodes": len(nodes),
            "total_edges": len(self._edges),
            "by_category": {
                cat.value: sum(1 for n in nodes if n.category == cat)
                for cat in FindingCategory
            },
            "by_severity": {
                sev: sum(1 for n in nodes if n.severity == sev)
                for sev in ["critical", "high", "medium", "low", "info"]
            },
            "exploitable_count": sum(1 for n in nodes if n.exploitable),
            "correlation_types": {
                ct.value: sum(1 for e in self._edges if e.correlation_type == ct)
                for ct in CorrelationType
            },
            "avg_confidence": sum(n.confidence for n in nodes) / len(nodes) if nodes else 0,
            "avg_cvss": sum(n.cvss_score for n in nodes) / len(nodes) if nodes else 0,
        }
    
    def get_graph_data(self) -> Dict[str, Any]:
        """Get graph data for visualization."""
        return {
            "nodes": [n.to_dict() for n in self._nodes.values()],
            "edges": [e.to_dict() for e in self._edges],
        }
    
    def get_reports(self) -> List[Dict[str, Any]]:
        """Get all generated reports."""
        return [r.to_dict() for r in self._reports]


# Global engine instance
_correlation_engine = VulnerabilityCorrelationEngine()


def get_correlation_engine() -> VulnerabilityCorrelationEngine:
    """Get the global correlation engine."""
    return _correlation_engine


def analyze_findings(findings: List[Dict[str, Any]]) -> Dict[str, Any]:
    """
    Convenience function to analyze findings.
    
    Args:
        findings: List of finding dictionaries
        
    Returns:
        Correlation report
    """
    engine = VulnerabilityCorrelationEngine()
    report = engine.analyze(findings)
    return report.to_dict()
