"""
Malware Sandbox Service - Docker Isolation

Provides isolated Docker sandboxes for safe malware execution:
1. Wine containers for Windows PE binaries
2. Ubuntu containers for Linux ELF binaries
3. Network isolation with optional internet access
4. Resource limits (CPU, memory, disk)
5. Snapshot/restore capabilities
6. Automated cleanup
"""

import asyncio
import logging
import os
import shutil
import tempfile
import uuid
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from pathlib import Path
from typing import Any, Dict, List, Optional

logger = logging.getLogger(__name__)


# ============================================================================
# Enums
# ============================================================================

class SandboxPlatform(Enum):
    """Sandbox platform type."""
    WINDOWS_WINE = "windows_wine"
    LINUX = "linux"
    MACOS = "macos"  # Future support


class SandboxStatus(Enum):
    """Sandbox status."""
    CREATING = "creating"
    RUNNING = "running"
    STOPPED = "stopped"
    FAILED = "failed"
    DESTROYED = "destroyed"


class NetworkMode(Enum):
    """Network isolation mode."""
    NONE = "none"  # No network access
    ISOLATED = "isolated"  # Internal network only
    BRIDGE = "bridge"  # Bridge to host (restricted)
    HOST = "host"  # Full host network (not recommended)


# ============================================================================
# Data Classes
# ============================================================================

@dataclass
class SandboxConfig:
    """Sandbox configuration."""
    platform: SandboxPlatform
    network_mode: NetworkMode = NetworkMode.ISOLATED
    enable_internet: bool = False
    timeout_seconds: int = 300
    auto_destroy: bool = True

    # Resource limits
    cpu_quota: int = 50000  # 50% CPU (100000 = 100%)
    memory_mb: int = 2048
    disk_mb: int = 4096
    max_pids: int = 256

    # Frida server
    enable_frida: bool = True
    frida_version: str = "16.1.4"

    # Monitoring
    enable_packet_capture: bool = True
    enable_syscall_trace: bool = False

    # Snapshots
    enable_snapshots: bool = True
    snapshot_interval_seconds: int = 60


@dataclass
class SandboxInfo:
    """Sandbox instance information."""
    sandbox_id: str
    container_id: str
    platform: SandboxPlatform
    status: SandboxStatus
    ip_address: Optional[str] = None
    frida_port: int = 27042
    created_at: datetime = field(default_factory=datetime.now)
    started_at: Optional[datetime] = None
    stopped_at: Optional[datetime] = None
    binary_path: Optional[str] = None
    working_directory: str = "/analysis"
    snapshots: List[str] = field(default_factory=list)
    resource_usage: Dict[str, Any] = field(default_factory=dict)


@dataclass
class ExecutionResult:
    """Binary execution result."""
    exit_code: int
    stdout: str
    stderr: str
    duration_seconds: float
    timed_out: bool
    crashed: bool
    crash_info: Optional[Dict] = None


# ============================================================================
# Docker Images Configuration
# ============================================================================

DOCKERFILE_WINE = """
# Frida + Wine Sandbox for Windows PE Analysis
FROM scottyhardy/docker-wine:stable

# Install dependencies
RUN apt-get update && apt-get install -y \\
    python3 python3-pip git wget curl \\
    tcpdump strace gdb net-tools \\
    && rm -rf /var/lib/apt/lists/*

# Install Frida
RUN pip3 install frida-tools==16.1.4 frida==16.1.4

# Setup Wine environment
ENV WINEPREFIX=/root/.wine
ENV WINEARCH=win64
ENV DISPLAY=:0

# Initialize Wine
RUN wine wineboot --init && wine wineboot --update

# Download frida-server for Windows
RUN mkdir -p /frida && \\
    wget https://github.com/frida/frida/releases/download/16.1.4/frida-server-16.1.4-windows-x86_64.exe \\
    -O /frida/frida-server.exe

# Create analysis directory
RUN mkdir -p /analysis /analysis/input /analysis/output

# Entrypoint script
COPY start-frida-wine.sh /usr/local/bin/start-frida.sh
RUN chmod +x /usr/local/bin/start-frida.sh

WORKDIR /analysis
CMD ["/usr/local/bin/start-frida.sh"]
"""

DOCKERFILE_LINUX = """
# Frida + Ubuntu Sandbox for Linux ELF Analysis
FROM ubuntu:22.04

# Install dependencies
RUN apt-get update && apt-get install -y \\
    python3 python3-pip git wget curl \\
    gdb strace ltrace tcpdump \\
    build-essential binutils \\
    net-tools iputils-ping \\
    && rm -rf /var/lib/apt/lists/*

# Install Frida
RUN pip3 install frida-tools==16.1.4 frida==16.1.4

# Download frida-server
RUN wget https://github.com/frida/frida/releases/download/16.1.4/frida-server-16.1.4-linux-x86_64 \\
    -O /usr/local/bin/frida-server && \\
    chmod +x /usr/local/bin/frida-server

# Create analysis directory
RUN mkdir -p /analysis /analysis/input /analysis/output

# Entrypoint script
COPY start-frida-linux.sh /usr/local/bin/start-frida.sh
RUN chmod +x /usr/local/bin/start-frida.sh

WORKDIR /analysis
CMD ["/usr/local/bin/start-frida.sh"]
"""

START_FRIDA_WINE_SCRIPT = """#!/bin/bash
# Start Frida server under Wine

echo "[SANDBOX] Starting Frida server under Wine..."

# Start Frida server in background
wine /frida/frida-server.exe -l 0.0.0.0:27042 &
FRIDA_PID=$!

echo "[SANDBOX] Frida server started with PID $FRIDA_PID"
echo "[SANDBOX] Sandbox ready for analysis"

# Keep container running
wait $FRIDA_PID
"""

START_FRIDA_LINUX_SCRIPT = """#!/bin/bash
# Start Frida server for Linux

echo "[SANDBOX] Starting Frida server..."

# Start Frida server in background
/usr/local/bin/frida-server -l 0.0.0.0:27042 &
FRIDA_PID=$!

echo "[SANDBOX] Frida server started with PID $FRIDA_PID"
echo "[SANDBOX] Sandbox ready for analysis"

# Keep container running
wait $FRIDA_PID
"""


# ============================================================================
# Malware Sandbox Service
# ============================================================================

class MalwareSandboxService:
    """
    Docker-based malware sandbox service.

    Provides isolated environments for safe malware execution with:
    - Wine containers for Windows PE binaries
    - Ubuntu containers for Linux ELF binaries
    - Network isolation
    - Resource limits
    - Frida instrumentation
    - Snapshot/restore capabilities
    """

    def __init__(self, docker_socket: str = "/var/run/docker.sock"):
        self.docker_socket = docker_socket
        self.sandboxes: Dict[str, SandboxInfo] = {}
        self.docker_client = None
        self._init_docker()

    def _init_docker(self):
        """Initialize Docker client."""
        try:
            import docker
            self.docker_client = docker.from_env()
            logger.info("Docker client initialized")
        except ImportError:
            logger.warning("Docker SDK not installed. Run: pip install docker")
        except Exception as e:
            logger.error(f"Failed to initialize Docker: {e}")

    async def create_sandbox(self, config: SandboxConfig) -> SandboxInfo:
        """
        Create a new isolated sandbox.

        Args:
            config: Sandbox configuration

        Returns:
            SandboxInfo with sandbox details
        """
        sandbox_id = str(uuid.uuid4())[:8]

        logger.info(f"Creating sandbox {sandbox_id} for platform {config.platform.value}")

        # Select Docker image based on platform
        if config.platform == SandboxPlatform.WINDOWS_WINE:
            image_name = "vrfuzzer/frida-wine:latest"
        elif config.platform == SandboxPlatform.LINUX:
            image_name = "vrfuzzer/frida-linux:latest"
        else:
            raise ValueError(f"Unsupported platform: {config.platform}")

        # Create sandbox info
        sandbox_info = SandboxInfo(
            sandbox_id=sandbox_id,
            container_id="",  # Will be set after container creation
            platform=config.platform,
            status=SandboxStatus.CREATING
        )

        try:
            # Build Docker image if needed
            await self._ensure_image(config.platform)

            # Create container
            container = await self._create_container(
                sandbox_id,
                image_name,
                config
            )

            sandbox_info.container_id = container.id
            sandbox_info.status = SandboxStatus.RUNNING
            sandbox_info.started_at = datetime.now()

            # Get container IP
            container.reload()
            networks = container.attrs.get('NetworkSettings', {}).get('Networks', {})
            if networks:
                first_network = list(networks.values())[0]
                sandbox_info.ip_address = first_network.get('IPAddress')

            self.sandboxes[sandbox_id] = sandbox_info
            logger.info(f"Sandbox {sandbox_id} created with container {container.id[:12]}")

            return sandbox_info

        except Exception as e:
            sandbox_info.status = SandboxStatus.FAILED
            logger.error(f"Failed to create sandbox {sandbox_id}: {e}")
            raise

    async def _ensure_image(self, platform: SandboxPlatform):
        """Ensure Docker image exists, build if necessary."""
        if not self.docker_client:
            raise RuntimeError("Docker client not initialized")

        if platform == SandboxPlatform.WINDOWS_WINE:
            image_name = "vrfuzzer/frida-wine:latest"
            dockerfile_content = DOCKERFILE_WINE
            startup_script = START_FRIDA_WINE_SCRIPT
        elif platform == SandboxPlatform.LINUX:
            image_name = "vrfuzzer/frida-linux:latest"
            dockerfile_content = DOCKERFILE_LINUX
            startup_script = START_FRIDA_LINUX_SCRIPT
        else:
            raise ValueError(f"Unsupported platform: {platform}")

        try:
            # Check if image exists
            self.docker_client.images.get(image_name)
            logger.info(f"Image {image_name} already exists")
            return
        except Exception:
            pass

        # Build image
        logger.info(f"Building Docker image {image_name}...")

        # Create temporary build context
        with tempfile.TemporaryDirectory() as build_dir:
            # Write Dockerfile
            dockerfile_path = os.path.join(build_dir, "Dockerfile")
            with open(dockerfile_path, 'w') as f:
                f.write(dockerfile_content)

            # Write startup script
            script_name = "start-frida-wine.sh" if platform == SandboxPlatform.WINDOWS_WINE else "start-frida-linux.sh"
            script_path = os.path.join(build_dir, script_name)
            with open(script_path, 'w') as f:
                f.write(startup_script)
            os.chmod(script_path, 0o755)

            # Build image
            try:
                image, build_logs = self.docker_client.images.build(
                    path=build_dir,
                    tag=image_name,
                    rm=True,
                    forcerm=True
                )
                logger.info(f"Image {image_name} built successfully")
            except Exception as e:
                logger.error(f"Failed to build image {image_name}: {e}")
                raise

    async def _create_container(
        self,
        sandbox_id: str,
        image_name: str,
        config: SandboxConfig
    ):
        """Create and start Docker container."""
        if not self.docker_client:
            raise RuntimeError("Docker client not initialized")

        # Configure network
        network_mode = config.network_mode.value

        # Configure resource limits
        host_config = self.docker_client.api.create_host_config(
            cpu_quota=config.cpu_quota,
            mem_limit=f"{config.memory_mb}m",
            memswap_limit=f"{config.memory_mb}m",
            pids_limit=config.max_pids,
            network_mode=network_mode,
            cap_drop=['ALL'],  # Drop all capabilities for security
            security_opt=['no-new-privileges'],
            read_only_rootfs=False  # Need write access for analysis
        )

        # Create container
        container = self.docker_client.containers.create(
            image=image_name,
            name=f"malware_sandbox_{sandbox_id}",
            detach=True,
            hostname=f"sandbox-{sandbox_id}",
            labels={
                "vrfuzzer.sandbox": "true",
                "vrfuzzer.sandbox_id": sandbox_id,
                "vrfuzzer.platform": config.platform.value
            },
            host_config=host_config,
            environment={
                "SANDBOX_ID": sandbox_id,
                "FRIDA_PORT": "27042"
            }
        )

        # Start container
        container.start()

        # Wait for container to be ready
        await asyncio.sleep(2)

        return container

    async def execute_binary(
        self,
        sandbox_id: str,
        binary_path: str,
        args: List[str] = None,
        timeout_seconds: int = 60
    ) -> ExecutionResult:
        """
        Execute a binary in the sandbox.

        Args:
            sandbox_id: Sandbox ID
            binary_path: Path to binary (will be copied to sandbox)
            args: Command-line arguments
            timeout_seconds: Execution timeout

        Returns:
            ExecutionResult with execution details
        """
        if sandbox_id not in self.sandboxes:
            raise ValueError(f"Sandbox {sandbox_id} not found")

        sandbox = self.sandboxes[sandbox_id]

        if not self.docker_client:
            raise RuntimeError("Docker client not initialized")

        try:
            container = self.docker_client.containers.get(sandbox.container_id)
        except Exception as e:
            raise RuntimeError(f"Container not found: {e}")

        # Copy binary to container
        binary_name = os.path.basename(binary_path)
        container_binary_path = f"/analysis/input/{binary_name}"

        logger.info(f"Copying {binary_path} to container {sandbox.container_id[:12]}")

        # Copy file using tarball
        import tarfile
        import io

        tar_stream = io.BytesIO()
        tar = tarfile.open(fileobj=tar_stream, mode='w')
        tar.add(binary_path, arcname=binary_name)
        tar.close()
        tar_stream.seek(0)

        container.put_archive("/analysis/input", tar_stream)

        # Make binary executable
        if sandbox.platform == SandboxPlatform.LINUX:
            container.exec_run(f"chmod +x {container_binary_path}")

        # Build execution command
        if sandbox.platform == SandboxPlatform.WINDOWS_WINE:
            cmd = ["wine", container_binary_path]
        else:
            cmd = [container_binary_path]

        if args:
            cmd.extend(args)

        # Execute binary
        logger.info(f"Executing: {' '.join(cmd)}")
        start_time = datetime.now()

        try:
            exec_result = container.exec_run(
                cmd,
                stdout=True,
                stderr=True,
                demux=True,
                workdir="/analysis"
            )

            duration = (datetime.now() - start_time).total_seconds()

            # Parse output
            stdout = exec_result.output[0].decode('utf-8', errors='replace') if exec_result.output[0] else ""
            stderr = exec_result.output[1].decode('utf-8', errors='replace') if exec_result.output[1] else ""

            return ExecutionResult(
                exit_code=exec_result.exit_code,
                stdout=stdout,
                stderr=stderr,
                duration_seconds=duration,
                timed_out=False,
                crashed=exec_result.exit_code != 0
            )

        except Exception as e:
            duration = (datetime.now() - start_time).total_seconds()
            logger.error(f"Execution failed: {e}")

            return ExecutionResult(
                exit_code=-1,
                stdout="",
                stderr=str(e),
                duration_seconds=duration,
                timed_out=duration >= timeout_seconds,
                crashed=True
            )

    async def stop_sandbox(self, sandbox_id: str):
        """Stop a sandbox."""
        if sandbox_id not in self.sandboxes:
            raise ValueError(f"Sandbox {sandbox_id} not found")

        sandbox = self.sandboxes[sandbox_id]

        if not self.docker_client:
            raise RuntimeError("Docker client not initialized")

        try:
            container = self.docker_client.containers.get(sandbox.container_id)
            container.stop(timeout=10)
            sandbox.status = SandboxStatus.STOPPED
            sandbox.stopped_at = datetime.now()
            logger.info(f"Sandbox {sandbox_id} stopped")
        except Exception as e:
            logger.error(f"Failed to stop sandbox {sandbox_id}: {e}")
            raise

    async def destroy_sandbox(self, sandbox_id: str, force: bool = False):
        """Destroy a sandbox and cleanup resources."""
        if sandbox_id not in self.sandboxes:
            raise ValueError(f"Sandbox {sandbox_id} not found")

        sandbox = self.sandboxes[sandbox_id]

        if not self.docker_client:
            raise RuntimeError("Docker client not initialized")

        try:
            container = self.docker_client.containers.get(sandbox.container_id)

            # Stop if running
            if container.status == 'running':
                container.stop(timeout=5)

            # Remove container
            container.remove(force=force)

            sandbox.status = SandboxStatus.DESTROYED
            del self.sandboxes[sandbox_id]

            logger.info(f"Sandbox {sandbox_id} destroyed")
        except Exception as e:
            logger.error(f"Failed to destroy sandbox {sandbox_id}: {e}")
            if not force:
                raise

    async def get_sandbox_status(self, sandbox_id: str) -> SandboxInfo:
        """Get sandbox status and info."""
        if sandbox_id not in self.sandboxes:
            raise ValueError(f"Sandbox {sandbox_id} not found")

        sandbox = self.sandboxes[sandbox_id]

        if not self.docker_client:
            return sandbox

        try:
            container = self.docker_client.containers.get(sandbox.container_id)
            container.reload()

            # Update status
            if container.status == 'running':
                sandbox.status = SandboxStatus.RUNNING
            elif container.status == 'exited':
                sandbox.status = SandboxStatus.STOPPED

            # Update resource usage
            stats = container.stats(stream=False)
            sandbox.resource_usage = {
                "cpu_percent": self._calculate_cpu_percent(stats),
                "memory_mb": stats['memory_stats'].get('usage', 0) / (1024 * 1024),
                "memory_limit_mb": stats['memory_stats'].get('limit', 0) / (1024 * 1024)
            }

        except Exception as e:
            logger.error(f"Failed to get sandbox status: {e}")

        return sandbox

    def _calculate_cpu_percent(self, stats: Dict) -> float:
        """Calculate CPU usage percentage from Docker stats."""
        try:
            cpu_delta = stats['cpu_stats']['cpu_usage']['total_usage'] - \
                       stats['precpu_stats']['cpu_usage']['total_usage']
            system_delta = stats['cpu_stats']['system_cpu_usage'] - \
                          stats['precpu_stats']['system_cpu_usage']
            cpu_count = stats['cpu_stats'].get('online_cpus', 1)

            if system_delta > 0:
                cpu_percent = (cpu_delta / system_delta) * cpu_count * 100.0
                return round(cpu_percent, 2)
        except (KeyError, ZeroDivisionError):
            pass

        return 0.0

    async def create_snapshot(self, sandbox_id: str, snapshot_name: str) -> bool:
        """Create a snapshot of the sandbox state."""
        if sandbox_id not in self.sandboxes:
            raise ValueError(f"Sandbox {sandbox_id} not found")

        sandbox = self.sandboxes[sandbox_id]

        if not self.docker_client:
            raise RuntimeError("Docker client not initialized")

        try:
            container = self.docker_client.containers.get(sandbox.container_id)

            # Commit container to image
            snapshot_image = container.commit(
                repository=f"vrfuzzer/snapshot_{sandbox_id}",
                tag=snapshot_name
            )

            sandbox.snapshots.append(snapshot_name)
            logger.info(f"Snapshot '{snapshot_name}' created for sandbox {sandbox_id}")
            return True

        except Exception as e:
            logger.error(f"Failed to create snapshot: {e}")
            return False

    async def restore_snapshot(self, sandbox_id: str, snapshot_name: str) -> bool:
        """Restore sandbox to a previous snapshot."""
        if sandbox_id not in self.sandboxes:
            raise ValueError(f"Sandbox {sandbox_id} not found")

        # This would require stopping current container and starting from snapshot image
        # Implementation would be similar to create_container but using snapshot image
        logger.warning("Snapshot restore not yet implemented")
        return False

    async def cleanup_all(self):
        """Cleanup all sandboxes."""
        logger.info("Cleaning up all sandboxes...")
        for sandbox_id in list(self.sandboxes.keys()):
            try:
                await self.destroy_sandbox(sandbox_id, force=True)
            except Exception as e:
                logger.error(f"Failed to cleanup sandbox {sandbox_id}: {e}")
