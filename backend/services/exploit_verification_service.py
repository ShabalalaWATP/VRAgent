"""
Exploit Verification Service

Automated testing of generated exploits to verify effectiveness.
Provides:
- Sandboxed exploit execution
- Crash/shell verification
- Iterative exploit refinement feedback
- Success/failure metrics
"""

import asyncio
import hashlib
import logging
import os
import signal
import struct
import subprocess
import tempfile
import time
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple, Union
import shutil

logger = logging.getLogger(__name__)


# =============================================================================
# Data Classes
# =============================================================================

class VerificationStatus(str, Enum):
    """Status of exploit verification."""
    PENDING = "pending"
    RUNNING = "running"
    SUCCESS = "success"
    PARTIAL = "partial"  # Achieved crash but not full exploitation
    FAILED = "failed"
    ERROR = "error"
    TIMEOUT = "timeout"


class ExploitGoal(str, Enum):
    """Goal of the exploit."""
    CRASH = "crash"  # Just trigger a crash
    CONTROLLED_CRASH = "controlled_crash"  # Crash at specific address
    CODE_EXECUTION = "code_execution"  # Execute arbitrary code
    SHELL = "shell"  # Get a shell
    INFO_LEAK = "info_leak"  # Leak memory contents
    PRIVILEGE_ESCALATION = "privilege_escalation"


@dataclass
class VerificationConfig:
    """Configuration for exploit verification."""
    timeout_seconds: int = 30
    max_attempts: int = 3
    sandbox_enabled: bool = True
    capture_output: bool = True
    check_coredump: bool = True
    target_architecture: str = "x64"
    expected_crash_address: Optional[int] = None
    expected_crash_signal: Optional[int] = None  # SIGSEGV = 11
    shell_marker: str = "EXPLOIT_SUCCESS_MARKER"


@dataclass
class CrashInfo:
    """Information about a crash."""
    signal: int
    signal_name: str
    crash_address: Optional[int]
    instruction_pointer: Optional[int]
    stack_pointer: Optional[int]
    registers: Dict[str, int]
    backtrace: List[str]
    memory_map: List[str]


@dataclass
class VerificationResult:
    """Result of exploit verification."""
    exploit_id: str
    status: VerificationStatus
    goal: ExploitGoal
    goal_achieved: bool

    # Execution details
    attempts: int
    execution_time_ms: int
    exit_code: Optional[int]
    stdout: str
    stderr: str

    # Crash analysis
    crash_info: Optional[CrashInfo]

    # Feedback for improvement
    failure_reason: Optional[str]
    improvement_suggestions: List[str]

    # Metadata
    timestamp: datetime = field(default_factory=datetime.utcnow)
    binary_hash: str = ""


@dataclass
class ExploitPayload:
    """An exploit payload to verify."""
    exploit_id: str
    target_binary: str
    payload_data: bytes
    goal: ExploitGoal
    delivery_method: str = "stdin"  # stdin, file, argv, network
    arguments: List[str] = field(default_factory=list)
    environment: Dict[str, str] = field(default_factory=dict)
    expected_output: Optional[str] = None


# =============================================================================
# Exploit Verification Service
# =============================================================================

class ExploitVerificationService:
    """
    Automated exploit verification in a sandboxed environment.

    Provides:
    - Safe execution of exploits
    - Crash/shell detection
    - Feedback for iterative refinement
    - Success metrics tracking
    """

    # Signal names
    SIGNAL_NAMES = {
        1: "SIGHUP",
        2: "SIGINT",
        4: "SIGILL",
        6: "SIGABRT",
        8: "SIGFPE",
        9: "SIGKILL",
        11: "SIGSEGV",
        13: "SIGPIPE",
        14: "SIGALRM",
        15: "SIGTERM",
    }

    def __init__(self, workspace_dir: Optional[str] = None):
        """Initialize verification service."""
        self.workspace_dir = workspace_dir or tempfile.mkdtemp(prefix="exploit_verify_")
        self._results_cache: Dict[str, VerificationResult] = {}
        self._verification_count = 0
        self._success_count = 0

        logger.info(f"ExploitVerificationService initialized, workspace: {self.workspace_dir}")

    async def verify_exploit(
        self,
        payload: ExploitPayload,
        config: Optional[VerificationConfig] = None,
    ) -> VerificationResult:
        """
        Verify an exploit payload against the target binary.

        Args:
            payload: The exploit payload to test
            config: Verification configuration

        Returns:
            VerificationResult with success/failure details
        """
        config = config or VerificationConfig()
        self._verification_count += 1

        # Validate inputs
        if not os.path.exists(payload.target_binary):
            return self._create_error_result(
                payload,
                "Target binary not found",
                ["Ensure the binary path is correct"],
            )

        # Calculate binary hash for tracking
        binary_hash = self._calculate_hash(payload.target_binary)

        # Run verification attempts
        best_result = None
        for attempt in range(1, config.max_attempts + 1):
            logger.info(f"Verification attempt {attempt}/{config.max_attempts} for {payload.exploit_id}")

            result = await self._run_verification(payload, config, attempt, binary_hash)

            if result.goal_achieved:
                self._success_count += 1
                logger.info(f"Exploit {payload.exploit_id} VERIFIED on attempt {attempt}")
                return result

            # Keep best partial result
            if best_result is None or result.status == VerificationStatus.PARTIAL:
                best_result = result

            # Small delay between attempts
            if attempt < config.max_attempts:
                await asyncio.sleep(0.5)

        return best_result or self._create_error_result(payload, "All attempts failed", [])

    async def _run_verification(
        self,
        payload: ExploitPayload,
        config: VerificationConfig,
        attempt: int,
        binary_hash: str,
    ) -> VerificationResult:
        """Run a single verification attempt."""
        start_time = time.time()

        # Prepare sandbox directory
        sandbox_dir = os.path.join(self.workspace_dir, f"sandbox_{payload.exploit_id}_{attempt}")
        os.makedirs(sandbox_dir, exist_ok=True)

        try:
            # Copy binary to sandbox
            sandbox_binary = os.path.join(sandbox_dir, os.path.basename(payload.target_binary))
            shutil.copy2(payload.target_binary, sandbox_binary)
            os.chmod(sandbox_binary, 0o755)

            # Prepare payload delivery
            stdin_data = None
            env = dict(os.environ)
            env.update(payload.environment)

            args = [sandbox_binary] + payload.arguments

            if payload.delivery_method == "stdin":
                stdin_data = payload.payload_data
            elif payload.delivery_method == "file":
                payload_file = os.path.join(sandbox_dir, "payload.bin")
                with open(payload_file, "wb") as f:
                    f.write(payload.payload_data)
                args.append(payload_file)
            elif payload.delivery_method == "argv":
                # Add payload as command line argument
                args.append(payload.payload_data.decode("latin-1", errors="replace"))

            # Execute with timeout
            try:
                proc = await asyncio.create_subprocess_exec(
                    *args,
                    stdin=asyncio.subprocess.PIPE if stdin_data else None,
                    stdout=asyncio.subprocess.PIPE,
                    stderr=asyncio.subprocess.PIPE,
                    cwd=sandbox_dir,
                    env=env,
                    limit=1024 * 1024,  # 1MB output limit
                )

                try:
                    stdout, stderr = await asyncio.wait_for(
                        proc.communicate(input=stdin_data),
                        timeout=config.timeout_seconds,
                    )
                except asyncio.TimeoutError:
                    proc.kill()
                    await proc.wait()
                    return VerificationResult(
                        exploit_id=payload.exploit_id,
                        status=VerificationStatus.TIMEOUT,
                        goal=payload.goal,
                        goal_achieved=False,
                        attempts=attempt,
                        execution_time_ms=int((time.time() - start_time) * 1000),
                        exit_code=None,
                        stdout="",
                        stderr="",
                        crash_info=None,
                        failure_reason="Execution timed out",
                        improvement_suggestions=[
                            "The exploit may be hanging - check for infinite loops",
                            "Try reducing payload size",
                            "Verify the offset is correct",
                        ],
                        binary_hash=binary_hash,
                    )

                exit_code = proc.returncode
                stdout_str = stdout.decode("utf-8", errors="replace")[:10000]
                stderr_str = stderr.decode("utf-8", errors="replace")[:10000]

            except Exception as e:
                logger.error(f"Process execution failed: {e}")
                return self._create_error_result(payload, str(e), [], attempt, binary_hash)

            execution_time = int((time.time() - start_time) * 1000)

            # Analyze result
            crash_info = None
            status = VerificationStatus.FAILED
            goal_achieved = False
            failure_reason = None
            suggestions = []

            # Check for crash (negative exit codes indicate signal on Unix)
            if exit_code is not None and exit_code < 0:
                signal_num = -exit_code
                crash_info = CrashInfo(
                    signal=signal_num,
                    signal_name=self.SIGNAL_NAMES.get(signal_num, f"SIG{signal_num}"),
                    crash_address=self._extract_crash_address(stderr_str),
                    instruction_pointer=None,
                    stack_pointer=None,
                    registers={},
                    backtrace=[],
                    memory_map=[],
                )

                if payload.goal == ExploitGoal.CRASH:
                    status = VerificationStatus.SUCCESS
                    goal_achieved = True
                elif payload.goal == ExploitGoal.CONTROLLED_CRASH:
                    if config.expected_crash_address and crash_info.crash_address:
                        if crash_info.crash_address == config.expected_crash_address:
                            status = VerificationStatus.SUCCESS
                            goal_achieved = True
                        else:
                            status = VerificationStatus.PARTIAL
                            failure_reason = f"Crashed at {hex(crash_info.crash_address)}, expected {hex(config.expected_crash_address)}"
                            suggestions.append("Adjust offset - crash address doesn't match")
                    else:
                        status = VerificationStatus.PARTIAL
                else:
                    status = VerificationStatus.PARTIAL
                    failure_reason = "Crashed but didn't achieve code execution"
                    suggestions.extend([
                        "Crash achieved - good progress!",
                        "Check if crash address is controllable",
                        "Verify ROP chain gadget addresses",
                    ])

            # Check for shell marker (indicating code execution)
            elif config.shell_marker in stdout_str:
                status = VerificationStatus.SUCCESS
                goal_achieved = True
                if payload.goal in [ExploitGoal.SHELL, ExploitGoal.CODE_EXECUTION]:
                    goal_achieved = True

            # Check for expected output
            elif payload.expected_output and payload.expected_output in stdout_str:
                if payload.goal == ExploitGoal.INFO_LEAK:
                    status = VerificationStatus.SUCCESS
                    goal_achieved = True
                else:
                    status = VerificationStatus.PARTIAL

            # Normal exit
            elif exit_code == 0:
                status = VerificationStatus.FAILED
                failure_reason = "Program exited normally (no crash)"
                suggestions.extend([
                    "Payload may be too short - increase buffer overflow size",
                    "Check if the vulnerable code path is being triggered",
                    "Verify input reaches the vulnerable function",
                ])

            else:
                status = VerificationStatus.FAILED
                failure_reason = f"Program exited with code {exit_code}"
                suggestions.append("Unexpected exit - review error output")

            return VerificationResult(
                exploit_id=payload.exploit_id,
                status=status,
                goal=payload.goal,
                goal_achieved=goal_achieved,
                attempts=attempt,
                execution_time_ms=execution_time,
                exit_code=exit_code,
                stdout=stdout_str,
                stderr=stderr_str,
                crash_info=crash_info,
                failure_reason=failure_reason,
                improvement_suggestions=suggestions,
                binary_hash=binary_hash,
            )

        finally:
            # Cleanup sandbox
            try:
                shutil.rmtree(sandbox_dir, ignore_errors=True)
            except Exception:
                pass

    def _extract_crash_address(self, stderr: str) -> Optional[int]:
        """Extract crash address from error output."""
        import re

        # Common patterns for crash addresses
        patterns = [
            r"at address 0x([0-9a-fA-F]+)",
            r"Segmentation fault at ([0-9a-fA-F]+)",
            r"SIGSEGV.*0x([0-9a-fA-F]+)",
            r"Illegal instruction at ([0-9a-fA-F]+)",
            r"ip\s*=\s*0x([0-9a-fA-F]+)",
            r"rip\s*=\s*0x([0-9a-fA-F]+)",
            r"eip\s*=\s*0x([0-9a-fA-F]+)",
        ]

        for pattern in patterns:
            match = re.search(pattern, stderr, re.IGNORECASE)
            if match:
                try:
                    return int(match.group(1), 16)
                except ValueError:
                    pass

        return None

    def _calculate_hash(self, file_path: str) -> str:
        """Calculate SHA256 hash of a file."""
        try:
            with open(file_path, "rb") as f:
                return hashlib.sha256(f.read()).hexdigest()[:16]
        except Exception:
            return "unknown"

    def _create_error_result(
        self,
        payload: ExploitPayload,
        error: str,
        suggestions: List[str],
        attempt: int = 1,
        binary_hash: str = "",
    ) -> VerificationResult:
        """Create an error result."""
        return VerificationResult(
            exploit_id=payload.exploit_id,
            status=VerificationStatus.ERROR,
            goal=payload.goal,
            goal_achieved=False,
            attempts=attempt,
            execution_time_ms=0,
            exit_code=None,
            stdout="",
            stderr="",
            crash_info=None,
            failure_reason=error,
            improvement_suggestions=suggestions,
            binary_hash=binary_hash,
        )

    async def verify_rop_chain(
        self,
        target_binary: str,
        rop_payload: bytes,
        buffer_offset: int,
        canary: Optional[bytes] = None,
    ) -> VerificationResult:
        """
        Verify a ROP chain exploit.

        Args:
            target_binary: Path to target binary
            rop_payload: The ROP chain payload
            buffer_offset: Offset to return address
            canary: Stack canary value if needed

        Returns:
            Verification result
        """
        # Build full payload
        payload_data = b"A" * buffer_offset

        if canary:
            payload_data += canary
            payload_data += b"B" * 8  # Saved RBP

        payload_data += rop_payload

        exploit_payload = ExploitPayload(
            exploit_id=f"rop_{hashlib.md5(rop_payload).hexdigest()[:8]}",
            target_binary=target_binary,
            payload_data=payload_data,
            goal=ExploitGoal.CODE_EXECUTION,
            delivery_method="stdin",
        )

        return await self.verify_exploit(exploit_payload)

    async def iterative_refinement(
        self,
        payload: ExploitPayload,
        max_iterations: int = 5,
        offset_adjustment_range: int = 64,
    ) -> Tuple[VerificationResult, ExploitPayload]:
        """
        Iteratively refine an exploit payload.

        Tries adjusting offsets and other parameters to achieve success.

        Args:
            payload: Initial exploit payload
            max_iterations: Maximum refinement iterations
            offset_adjustment_range: Range for offset adjustments

        Returns:
            Tuple of (best result, refined payload)
        """
        best_result = None
        best_payload = payload

        # Initial verification
        result = await self.verify_exploit(payload)
        best_result = result

        if result.goal_achieved:
            return result, payload

        # Try offset adjustments if we got a crash
        if result.status == VerificationStatus.PARTIAL:
            logger.info("Partial success - trying offset adjustments")

            for offset_delta in range(-offset_adjustment_range, offset_adjustment_range + 1, 8):
                if offset_delta == 0:
                    continue

                # Adjust payload length
                if offset_delta > 0:
                    adjusted_data = payload.payload_data + b"\x00" * offset_delta
                else:
                    adjusted_data = payload.payload_data[:offset_delta] if len(payload.payload_data) > abs(offset_delta) else payload.payload_data

                adjusted_payload = ExploitPayload(
                    exploit_id=f"{payload.exploit_id}_adj{offset_delta:+d}",
                    target_binary=payload.target_binary,
                    payload_data=adjusted_data,
                    goal=payload.goal,
                    delivery_method=payload.delivery_method,
                    arguments=payload.arguments,
                    environment=payload.environment,
                )

                result = await self.verify_exploit(adjusted_payload, VerificationConfig(max_attempts=1))

                if result.goal_achieved:
                    logger.info(f"Success with offset adjustment {offset_delta:+d}")
                    return result, adjusted_payload

                if result.status == VerificationStatus.PARTIAL:
                    if best_result is None or best_result.status != VerificationStatus.PARTIAL:
                        best_result = result
                        best_payload = adjusted_payload

        return best_result, best_payload

    def get_statistics(self) -> Dict[str, Any]:
        """Get verification statistics."""
        return {
            "total_verifications": self._verification_count,
            "successful_verifications": self._success_count,
            "success_rate": (
                self._success_count / self._verification_count
                if self._verification_count > 0
                else 0.0
            ),
            "workspace": self.workspace_dir,
        }

    def cleanup(self):
        """Cleanup workspace directory."""
        try:
            shutil.rmtree(self.workspace_dir, ignore_errors=True)
        except Exception as e:
            logger.warning(f"Cleanup failed: {e}")


# =============================================================================
# Convenience Functions
# =============================================================================

# Global service instance
_verification_service: Optional[ExploitVerificationService] = None


def get_verification_service() -> ExploitVerificationService:
    """Get global verification service instance."""
    global _verification_service
    if _verification_service is None:
        _verification_service = ExploitVerificationService()
    return _verification_service


async def verify_exploit(
    target_binary: str,
    payload_data: bytes,
    goal: str = "crash",
    delivery_method: str = "stdin",
) -> VerificationResult:
    """
    Convenience function to verify an exploit.

    Args:
        target_binary: Path to target binary
        payload_data: The exploit payload bytes
        goal: Exploitation goal (crash, code_execution, shell)
        delivery_method: How to deliver payload (stdin, file, argv)

    Returns:
        VerificationResult
    """
    service = get_verification_service()

    payload = ExploitPayload(
        exploit_id=hashlib.md5(payload_data).hexdigest()[:12],
        target_binary=target_binary,
        payload_data=payload_data,
        goal=ExploitGoal(goal),
        delivery_method=delivery_method,
    )

    return await service.verify_exploit(payload)


async def verify_and_refine(
    target_binary: str,
    payload_data: bytes,
    goal: str = "crash",
    max_iterations: int = 5,
) -> Tuple[VerificationResult, bytes]:
    """
    Convenience function to verify and iteratively refine an exploit.

    Returns:
        Tuple of (result, refined_payload_data)
    """
    service = get_verification_service()

    payload = ExploitPayload(
        exploit_id=hashlib.md5(payload_data).hexdigest()[:12],
        target_binary=target_binary,
        payload_data=payload_data,
        goal=ExploitGoal(goal),
        delivery_method="stdin",
    )

    result, refined_payload = await service.iterative_refinement(
        payload,
        max_iterations=max_iterations,
    )

    return result, refined_payload.payload_data
