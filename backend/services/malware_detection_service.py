"""
Enhanced Malware Detection Service

Comprehensive detection using:
1. YARA rule matching
2. Packer/crypter detection
3. C2 beacon detection
4. Persistence mechanism enumeration
5. Privilege escalation detection
6. Lateral movement detection
7. AI-driven classification
"""

import hashlib
import logging
import math
import os
import re
from collections import Counter
from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional, Set, Tuple

logger = logging.getLogger(__name__)


# ============================================================================
# Data Classes
# ============================================================================

@dataclass
class YARAMatch:
    """YARA rule match result."""
    rule_name: str
    namespace: str
    tags: List[str]
    strings: List[Dict]  # [{"offset": 0x1234, "identifier": "$string1", "data": "..."}]
    meta: Dict[str, Any]


@dataclass
class PackerInfo:
    """Packer detection result."""
    is_packed: bool
    packer_name: Optional[str] = None
    confidence: float = 0.0
    entropy: float = 0.0
    section_entropy: Dict[str, float] = field(default_factory=dict)
    indicators: List[str] = field(default_factory=list)


@dataclass
class C2Beacon:
    """C2 beacon detection result."""
    detected: bool
    beacon_type: Optional[str] = None  # http, https, dns, tcp, custom
    server_address: Optional[str] = None
    server_port: Optional[int] = None
    interval_seconds: Optional[float] = None
    jitter: Optional[float] = None  # Timing variance
    protocol_indicators: List[str] = field(default_factory=list)
    confidence: float = 0.0


@dataclass
class PersistenceMechanism:
    """Persistence mechanism detection."""
    mechanism_type: str  # registry, service, scheduled_task, startup_folder, etc.
    location: str
    value: Optional[str] = None
    mitre_technique: str = "T1547"
    severity: str = "high"


@dataclass
class PrivilegeEscalation:
    """Privilege escalation detection."""
    technique: str  # dll_hijacking, token_manipulation, uac_bypass, etc.
    target: Optional[str] = None
    mitre_technique: str = "T1068"
    indicators: List[str] = field(default_factory=list)


@dataclass
class LateralMovement:
    """Lateral movement detection."""
    technique: str  # pass_the_hash, rdp, wmi, psexec, etc.
    target_host: Optional[str] = None
    credentials_used: bool = False
    mitre_technique: str = "T1021"


@dataclass
class DetectionResult:
    """Comprehensive detection result."""
    # YARA matches
    yara_matches: List[YARAMatch] = field(default_factory=list)

    # Packer detection
    packer_info: Optional[PackerInfo] = None

    # C2 detection
    c2_beacons: List[C2Beacon] = field(default_factory=list)

    # Advanced techniques
    persistence_mechanisms: List[PersistenceMechanism] = field(default_factory=list)
    privilege_escalations: List[PrivilegeEscalation] = field(default_factory=list)
    lateral_movements: List[LateralMovement] = field(default_factory=list)

    # Classification
    is_malicious: bool = False
    malware_family: Optional[str] = None
    malware_categories: List[str] = field(default_factory=list)
    confidence_score: float = 0.0
    threat_score: int = 0


# ============================================================================
# YARA Rules (Embedded)
# ============================================================================

YARA_RULES = """
rule Ransomware_Generic {
    meta:
        description = "Generic ransomware detection"
        author = "VRAgent"
        severity = "critical"
        mitre = "T1486"
    strings:
        $encrypt1 = "CryptEncrypt" nocase
        $encrypt2 = "CryptAcquireContext" nocase
        $file1 = "FindFirstFile" nocase
        $file2 = "FindNextFile" nocase
        $ransom1 = "bitcoin" nocase
        $ransom2 = "decrypt" nocase
        $ransom3 = "ransom" nocase
        $ext1 = ".encrypted"
        $ext2 = ".locked"
        $ext3 = ".crypted"
    condition:
        (2 of ($encrypt*)) and (2 of ($file*)) and (1 of ($ransom*) or 1 of ($ext*))
}

rule Trojan_RAT_Generic {
    meta:
        description = "Generic Remote Access Trojan"
        author = "VRAgent"
        severity = "high"
        mitre = "T1219"
    strings:
        $net1 = "WSAStartup"
        $net2 = "connect"
        $net3 = "send"
        $net4 = "recv"
        $cmd1 = "cmd.exe"
        $cmd2 = "powershell"
        $screen1 = "GetDC"
        $screen2 = "BitBlt"
        $keylog1 = "GetAsyncKeyState"
        $keylog2 = "SetWindowsHookEx"
    condition:
        (3 of ($net*)) and (1 of ($cmd*)) and (1 of ($screen*) or 1 of ($keylog*))
}

rule Backdoor_PersistenceRegistry {
    meta:
        description = "Backdoor with registry persistence"
        author = "VRAgent"
        severity = "high"
        mitre = "T1547.001"
    strings:
        $reg1 = "RegOpenKeyEx" nocase
        $reg2 = "RegSetValueEx" nocase
        $reg3 = "SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run" nocase
        $reg4 = "SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\RunOnce" nocase
        $net1 = "InternetOpen"
        $net2 = "HttpSendRequest"
    condition:
        ($reg1 and $reg2) and (1 of ($reg3, $reg4)) and (1 of ($net*))
}

rule Infostealer_Credentials {
    meta:
        description = "Information stealer targeting credentials"
        author = "VRAgent"
        severity = "high"
        mitre = "T1555"
    strings:
        $cred1 = "password" nocase
        $cred2 = "credential" nocase
        $cred3 = "login" nocase
        $browser1 = "Chrome"
        $browser2 = "Firefox"
        $browser3 = "Edge"
        $file1 = "CryptUnprotectData"
        $file2 = "sqlite3"
    condition:
        (2 of ($cred*)) and (1 of ($browser*)) and (1 of ($file*))
}

rule Cryptominer {
    meta:
        description = "Cryptocurrency miner"
        author = "VRAgent"
        severity = "medium"
        mitre = "T1496"
    strings:
        $pool1 = "stratum+tcp://"
        $pool2 = "pool."
        $coin1 = "monero"
        $coin2 = "bitcoin"
        $coin3 = "ethereum"
        $miner1 = "xmrig"
        $miner2 = "cgminer"
        $miner3 = "nicehash"
    condition:
        (1 of ($pool*)) and (1 of ($coin*) or 1 of ($miner*))
}

rule ProcessInjection {
    meta:
        description = "Process injection techniques"
        author = "VRAgent"
        severity = "high"
        mitre = "T1055"
    strings:
        $inject1 = "VirtualAllocEx"
        $inject2 = "WriteProcessMemory"
        $inject3 = "CreateRemoteThread"
        $inject4 = "QueueUserAPC"
        $inject5 = "SetThreadContext"
        $inject6 = "NtMapViewOfSection"
    condition:
        (3 of ($inject*))
}

rule AntiAnalysis {
    meta:
        description = "Anti-analysis techniques"
        author = "VRAgent"
        severity = "medium"
        mitre = "T1027"
    strings:
        $debug1 = "IsDebuggerPresent"
        $debug2 = "CheckRemoteDebuggerPresent"
        $debug3 = "NtQueryInformationProcess"
        $vm1 = "VirtualBox"
        $vm2 = "VMware"
        $vm3 = "QEMU"
        $vm4 = "Xen"
        $sandbox1 = "sample"
        $sandbox2 = "sandbox"
        $sandbox3 = "malware"
    condition:
        (2 of ($debug*)) or (2 of ($vm*)) or (2 of ($sandbox*))
}

rule Worm_NetworkSpread {
    meta:
        description = "Worm with network spreading capability"
        author = "VRAgent"
        severity = "critical"
        mitre = "T1210"
    strings:
        $net1 = "NetShareEnum"
        $net2 = "NetUserEnum"
        $net3 = "WNetAddConnection"
        $file1 = "CopyFile"
        $smb1 = "\\\\\\\\%s\\\\ADMIN$"
        $smb2 = "\\\\\\\\%s\\\\C$"
    condition:
        (2 of ($net*)) and $file1 and (1 of ($smb*))
}
"""


# ============================================================================
# Enhanced Malware Detection Service
# ============================================================================

class MalwareDetectionService:
    """
    Comprehensive malware detection with multiple techniques.
    """

    def __init__(self):
        self.yara_rules = None
        self._init_yara()

    def _init_yara(self):
        """Initialize YARA rules."""
        try:
            import yara
            self.yara_rules = yara.compile(source=YARA_RULES)
            logger.info("YARA rules loaded successfully")
        except ImportError:
            logger.warning("YARA not installed. Run: pip install yara-python")
        except Exception as e:
            logger.error(f"Failed to load YARA rules: {e}")

    # ========================================================================
    # YARA Scanning
    # ========================================================================

    def scan_with_yara(self, file_path: str) -> List[YARAMatch]:
        """
        Scan file with YARA rules.

        Args:
            file_path: Path to file

        Returns:
            List of YARA matches
        """
        if not self.yara_rules:
            logger.warning("YARA rules not available")
            return []

        try:
            matches = []
            yara_matches = self.yara_rules.match(file_path)

            for match in yara_matches:
                strings = []
                for string_match in match.strings:
                    strings.append({
                        "offset": string_match[0],
                        "identifier": string_match[1],
                        "data": string_match[2].decode('utf-8', errors='ignore')
                    })

                matches.append(YARAMatch(
                    rule_name=match.rule,
                    namespace=match.namespace,
                    tags=match.tags,
                    strings=strings,
                    meta=match.meta
                ))

            logger.info(f"YARA scan found {len(matches)} matches")
            return matches

        except Exception as e:
            logger.error(f"YARA scan failed: {e}")
            return []

    # ========================================================================
    # Packer Detection
    # ========================================================================

    def detect_packer(self, file_path: str, sections: List[Dict]) -> PackerInfo:
        """
        Detect if binary is packed/encrypted.

        Args:
            file_path: Path to binary
            sections: PE/ELF sections

        Returns:
            PackerInfo with detection results
        """
        logger.info("Detecting packer")

        # Calculate file entropy
        entropy = self._calculate_entropy(file_path)

        # Calculate per-section entropy
        section_entropy = {}
        for section in sections:
            name = section.get("name", "unknown")
            data = section.get("data", b"")
            if data:
                section_entropy[name] = self._calculate_entropy_bytes(data)

        # Check entropy threshold
        is_packed = entropy > 7.0
        packer_name = None
        confidence = 0.0
        indicators = []

        if is_packed:
            indicators.append(f"High entropy: {entropy:.2f}")

        # Detect specific packers by section names
        packer_signatures = {
            "UPX": ["UPX0", "UPX1", "UPX!"],
            "VMProtect": [".vmp0", ".vmp1", ".vmp2"],
            "Themida": [".themida", ".winlice"],
            "ASPack": [".aspack", ".adata"],
            "PECompact": [".pec1", ".pec2"],
            "Armadillo": [".adata", ".rsrc"],
            "Enigma": [".enigma1", ".enigma2"],
            "Obsidium": [".obsidium"],
            "Molebox": [".mbox"],
            "ExeShield": [".exeshield"]
        }

        section_names = [s.get("name", "").lower() for s in sections]
        for packer, signatures in packer_signatures.items():
            if any(sig.lower() in "".join(section_names) for sig in signatures):
                packer_name = packer
                confidence = 0.9
                indicators.append(f"Section signature match: {packer}")
                break

        # Generic packer detection heuristics
        if not packer_name and is_packed:
            # Check for small number of imports (typical of packed files)
            # Check for high entropy in executable sections
            # Check for unusual entry point

            packer_name = "Unknown"
            confidence = 0.6
            indicators.append("Generic packer heuristics")

        logger.info(f"Packer detection: {packer_name if is_packed else 'Not packed'} (confidence: {confidence})")

        return PackerInfo(
            is_packed=is_packed,
            packer_name=packer_name,
            confidence=confidence,
            entropy=entropy,
            section_entropy=section_entropy,
            indicators=indicators
        )

    def _calculate_entropy(self, file_path: str) -> float:
        """Calculate Shannon entropy of file."""
        try:
            with open(file_path, 'rb') as f:
                data = f.read()
            return self._calculate_entropy_bytes(data)
        except Exception as e:
            logger.error(f"Failed to calculate entropy: {e}")
            return 0.0

    def _calculate_entropy_bytes(self, data: bytes) -> float:
        """Calculate Shannon entropy of bytes."""
        if not data:
            return 0.0

        # Count byte frequencies
        counter = Counter(data)
        length = len(data)

        # Calculate entropy
        entropy = 0.0
        for count in counter.values():
            probability = count / length
            entropy -= probability * math.log2(probability)

        return entropy

    # ========================================================================
    # C2 Beacon Detection
    # ========================================================================

    def detect_c2_beacon(self, network_connections: List[Dict], api_calls: List[Dict]) -> List[C2Beacon]:
        """
        Detect C2 beacons from network activity.

        Args:
            network_connections: List of network connections
            api_calls: List of API calls

        Returns:
            List of detected C2 beacons
        """
        logger.info("Detecting C2 beacons")
        beacons = []

        if not network_connections:
            return beacons

        # Group connections by destination
        connection_groups: Dict[Tuple[str, int], List[float]] = {}
        for conn in network_connections:
            ip = conn.get("ip")
            port = conn.get("port")
            timestamp = conn.get("timestamp", 0)

            if ip and port:
                key = (ip, port)
                if key not in connection_groups:
                    connection_groups[key] = []
                connection_groups[key].append(timestamp)

        # Analyze each destination for beacon patterns
        for (ip, port), timestamps in connection_groups.items():
            if len(timestamps) < 3:
                continue

            # Calculate intervals
            intervals = [timestamps[i+1] - timestamps[i] for i in range(len(timestamps)-1)]

            # Check for regular beaconing (low variance in intervals)
            if len(intervals) >= 2:
                avg_interval = sum(intervals) / len(intervals)
                variance = sum((x - avg_interval) ** 2 for x in intervals) / len(intervals)
                std_dev = math.sqrt(variance)
                jitter = std_dev / avg_interval if avg_interval > 0 else 1.0

                # Low jitter indicates beaconing
                if jitter < 0.3:  # Less than 30% variance
                    # Determine protocol
                    beacon_type = "https" if port == 443 else "http" if port == 80 else "tcp"

                    # Check for DNS beaconing
                    if port == 53:
                        beacon_type = "dns"

                    beacon = C2Beacon(
                        detected=True,
                        beacon_type=beacon_type,
                        server_address=ip,
                        server_port=port,
                        interval_seconds=avg_interval / 1000.0 if avg_interval < 100000 else avg_interval,
                        jitter=jitter,
                        protocol_indicators=[f"Regular interval: {avg_interval:.0f}ms"],
                        confidence=1.0 - jitter
                    )
                    beacons.append(beacon)
                    logger.warning(f"C2 beacon detected: {ip}:{port} (interval: {avg_interval:.0f}ms, jitter: {jitter:.2f})")

        # Check for DNS tunneling
        dns_queries = [call for call in api_calls if "DNSQuery" in call.get("api", "") or "getaddrinfo" in call.get("api", "")]
        if len(dns_queries) > 20:
            # High volume of DNS queries may indicate DNS tunneling
            beacon = C2Beacon(
                detected=True,
                beacon_type="dns",
                protocol_indicators=["High DNS query volume"],
                confidence=0.7
            )
            beacons.append(beacon)
            logger.warning("Potential DNS tunneling detected")

        return beacons

    # ========================================================================
    # Persistence Detection
    # ========================================================================

    def detect_persistence(self, registry_modified: List[Dict], files_created: List[str], api_calls: List[Dict]) -> List[PersistenceMechanism]:
        """
        Detect persistence mechanisms.

        Args:
            registry_modified: Registry modifications
            files_created: Files created
            api_calls: API calls

        Returns:
            List of detected persistence mechanisms
        """
        logger.info("Detecting persistence mechanisms")
        mechanisms = []

        # Registry persistence
        persistence_keys = [
            ("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run", "T1547.001"),
            ("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnce", "T1547.001"),
            ("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon", "T1547.004"),
            ("SYSTEM\\CurrentControlSet\\Services", "T1543.003"),
        ]

        for reg_mod in registry_modified:
            key = reg_mod.get("key", "")
            value_name = reg_mod.get("value_name", "")
            value_data = reg_mod.get("value_data", "")

            for persistence_key, mitre_id in persistence_keys:
                if persistence_key.lower() in key.lower():
                    mechanisms.append(PersistenceMechanism(
                        mechanism_type="registry",
                        location=f"{key}\\{value_name}",
                        value=str(value_data),
                        mitre_technique=mitre_id,
                        severity="high"
                    ))
                    logger.warning(f"Registry persistence detected: {key}")

        # Startup folder persistence
        startup_folders = [
            "\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup",
            "\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Startup"
        ]

        for file_path in files_created:
            for startup_folder in startup_folders:
                if startup_folder.lower() in file_path.lower():
                    mechanisms.append(PersistenceMechanism(
                        mechanism_type="startup_folder",
                        location=file_path,
                        mitre_technique="T1547.001",
                        severity="high"
                    ))
                    logger.warning(f"Startup folder persistence detected: {file_path}")

        # Service creation
        service_apis = ["CreateService", "CreateServiceW", "CreateServiceA"]
        for api_call in api_calls:
            api_name = api_call.get("api", "")
            if any(sa in api_name for sa in service_apis):
                mechanisms.append(PersistenceMechanism(
                    mechanism_type="service",
                    location="Service creation",
                    mitre_technique="T1543.003",
                    severity="high"
                ))
                logger.warning("Service creation persistence detected")

        # Scheduled task
        schtasks_patterns = ["schtasks", "at.exe", "Register-ScheduledTask"]
        for api_call in api_calls:
            cmd_line = str(api_call.get("args", ""))
            if any(pattern in cmd_line.lower() for pattern in schtasks_patterns):
                mechanisms.append(PersistenceMechanism(
                    mechanism_type="scheduled_task",
                    location="Scheduled task creation",
                    mitre_technique="T1053.005",
                    severity="high"
                ))
                logger.warning("Scheduled task persistence detected")

        return mechanisms

    # ========================================================================
    # Privilege Escalation Detection
    # ========================================================================

    def detect_privilege_escalation(self, api_calls: List[Dict], files_accessed: List[str]) -> List[PrivilegeEscalation]:
        """
        Detect privilege escalation attempts.

        Args:
            api_calls: API calls
            files_accessed: Files accessed

        Returns:
            List of detected privilege escalation attempts
        """
        logger.info("Detecting privilege escalation")
        escalations = []

        # Token manipulation
        token_apis = ["OpenProcessToken", "AdjustTokenPrivileges", "DuplicateTokenEx", "ImpersonateLoggedOnUser"]
        for api_call in api_calls:
            api_name = api_call.get("api", "")
            if any(ta in api_name for ta in token_apis):
                escalations.append(PrivilegeEscalation(
                    technique="token_manipulation",
                    mitre_technique="T1134",
                    indicators=[api_name]
                ))
                logger.warning(f"Token manipulation detected: {api_name}")

        # UAC bypass attempts
        uac_bypass_patterns = [
            "eventvwr.exe",
            "fodhelper.exe",
            "sdclt.exe",
            "computerdefaults.exe"
        ]

        for file_path in files_accessed:
            lower_path = file_path.lower()
            for pattern in uac_bypass_patterns:
                if pattern in lower_path:
                    escalations.append(PrivilegeEscalation(
                        technique="uac_bypass",
                        target=file_path,
                        mitre_technique="T1548.002",
                        indicators=[pattern]
                    ))
                    logger.warning(f"UAC bypass detected: {file_path}")

        # DLL hijacking
        dll_patterns = ["version.dll", "uxtheme.dll", "dwmapi.dll", "cryptbase.dll"]
        for file_path in files_accessed:
            lower_path = file_path.lower()
            for dll in dll_patterns:
                if dll in lower_path and "\\windows\\system32\\" not in lower_path:
                    escalations.append(PrivilegeEscalation(
                        technique="dll_hijacking",
                        target=file_path,
                        mitre_technique="T1574.001",
                        indicators=[dll]
                    ))
                    logger.warning(f"DLL hijacking detected: {file_path}")

        return escalations

    # ========================================================================
    # Lateral Movement Detection
    # ========================================================================

    def detect_lateral_movement(self, network_connections: List[Dict], api_calls: List[Dict]) -> List[LateralMovement]:
        """
        Detect lateral movement attempts.

        Args:
            network_connections: Network connections
            api_calls: API calls

        Returns:
            List of detected lateral movement attempts
        """
        logger.info("Detecting lateral movement")
        movements = []

        # SMB/Admin shares
        smb_ports = [139, 445]
        for conn in network_connections:
            port = conn.get("port")
            ip = conn.get("ip")
            if port in smb_ports:
                movements.append(LateralMovement(
                    technique="smb",
                    target_host=ip,
                    mitre_technique="T1021.002"
                ))
                logger.warning(f"SMB lateral movement detected: {ip}:{port}")

        # RDP
        rdp_ports = [3389]
        for conn in network_connections:
            port = conn.get("port")
            ip = conn.get("ip")
            if port in rdp_ports:
                movements.append(LateralMovement(
                    technique="rdp",
                    target_host=ip,
                    mitre_technique="T1021.001"
                ))
                logger.warning(f"RDP lateral movement detected: {ip}:{port}")

        # WMI
        wmi_apis = ["CoCreateInstance", "IWbemServices"]
        for api_call in api_calls:
            api_name = api_call.get("api", "")
            if any(wmi in api_name for wmi in wmi_apis):
                movements.append(LateralMovement(
                    technique="wmi",
                    mitre_technique="T1047"
                ))
                logger.warning("WMI lateral movement detected")

        # PsExec-like behavior
        psexec_indicators = ["ADMIN$", "IPC$", "CreateService"]
        cmd_lines = [str(call.get("args", "")) for call in api_calls]
        if any(indicator in " ".join(cmd_lines) for indicator in psexec_indicators):
            movements.append(LateralMovement(
                technique="psexec",
                mitre_technique="T1021.002"
            ))
            logger.warning("PsExec-like lateral movement detected")

        return movements

    # ========================================================================
    # Comprehensive Analysis
    # ========================================================================

    def analyze(
        self,
        file_path: str,
        sections: List[Dict],
        api_calls: List[Dict],
        network_connections: List[Dict],
        registry_modified: List[Dict],
        files_accessed: List[str],
        files_created: List[str]
    ) -> DetectionResult:
        """
        Perform comprehensive malware detection.

        Args:
            file_path: Path to binary
            sections: PE/ELF sections
            api_calls: Captured API calls
            network_connections: Network connections
            registry_modified: Registry modifications
            files_accessed: Files accessed
            files_created: Files created

        Returns:
            DetectionResult with all findings
        """
        logger.info(f"Starting comprehensive analysis of {file_path}")

        result = DetectionResult()

        # YARA scanning
        result.yara_matches = self.scan_with_yara(file_path)

        # Packer detection
        result.packer_info = self.detect_packer(file_path, sections)

        # C2 beacon detection
        result.c2_beacons = self.detect_c2_beacon(network_connections, api_calls)

        # Persistence detection
        result.persistence_mechanisms = self.detect_persistence(registry_modified, files_created, api_calls)

        # Privilege escalation detection
        result.privilege_escalations = self.detect_privilege_escalation(api_calls, files_accessed)

        # Lateral movement detection
        result.lateral_movements = self.detect_lateral_movement(network_connections, api_calls)

        # Classification
        result.is_malicious = self._classify(result)
        result.malware_family = self._identify_family(result)
        result.malware_categories = self._categorize(result)
        result.confidence_score = self._calculate_confidence(result)
        result.threat_score = self._calculate_threat_score(result)

        logger.info(f"Analysis complete. Malicious: {result.is_malicious}, Threat score: {result.threat_score}")
        return result

    def _classify(self, result: DetectionResult) -> bool:
        """Classify if binary is malicious."""
        # Malicious if any critical indicators
        if result.yara_matches:
            return True

        if result.c2_beacons:
            return True

        if len(result.persistence_mechanisms) > 0:
            return True

        if len(result.privilege_escalations) > 0:
            return True

        if result.packer_info and result.packer_info.is_packed and result.packer_info.entropy > 7.5:
            return True

        return False

    def _identify_family(self, result: DetectionResult) -> Optional[str]:
        """Identify malware family from YARA matches."""
        for match in result.yara_matches:
            if "Ransomware" in match.rule_name:
                return "ransomware"
            elif "RAT" in match.rule_name or "Trojan" in match.rule_name:
                return "trojan"
            elif "Backdoor" in match.rule_name:
                return "backdoor"
            elif "Infostealer" in match.rule_name:
                return "infostealer"
            elif "Cryptominer" in match.rule_name:
                return "cryptominer"
            elif "Worm" in match.rule_name:
                return "worm"

        # Infer from behaviors
        if result.c2_beacons:
            return "trojan"
        elif result.packer_info and result.packer_info.is_packed:
            return "packed_malware"

        return None

    def _categorize(self, result: DetectionResult) -> List[str]:
        """Categorize malware based on behaviors."""
        categories = []

        if result.yara_matches:
            for match in result.yara_matches:
                if "Ransomware" in match.rule_name:
                    categories.append("ransomware")
                elif "Infostealer" in match.rule_name:
                    categories.append("infostealer")
                elif "Cryptominer" in match.rule_name:
                    categories.append("cryptominer")

        if result.c2_beacons:
            categories.append("trojan")

        if result.persistence_mechanisms:
            categories.append("persistent")

        if result.lateral_movements:
            categories.append("worm")

        return list(set(categories))

    def _calculate_confidence(self, result: DetectionResult) -> float:
        """Calculate detection confidence."""
        score = 0.0

        # YARA matches contribute heavily
        if result.yara_matches:
            score += 0.4

        # C2 beacons
        if result.c2_beacons:
            score += 0.3

        # Persistence
        if result.persistence_mechanisms:
            score += 0.2

        # Packer
        if result.packer_info and result.packer_info.is_packed:
            score += 0.1

        return min(score, 1.0)

    def _calculate_threat_score(self, result: DetectionResult) -> int:
        """Calculate threat score (0-100)."""
        score = 0

        # YARA matches (0-30 points)
        score += min(len(result.yara_matches) * 10, 30)

        # C2 beacons (0-25 points)
        score += min(len(result.c2_beacons) * 25, 25)

        # Persistence (0-20 points)
        score += min(len(result.persistence_mechanisms) * 10, 20)

        # Privilege escalation (0-15 points)
        score += min(len(result.privilege_escalations) * 15, 15)

        # Lateral movement (0-10 points)
        score += min(len(result.lateral_movements) * 10, 10)

        return min(score, 100)
