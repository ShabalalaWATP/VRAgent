from typing import List, Optional, Literal

from sqlalchemy.orm import Session

from backend import models
from backend.core.config import settings
from backend.core.logging import get_logger

logger = get_logger(__name__)

# Exploit analysis mode settings
FULL_ANALYSIS_THRESHOLD = 15  # Use full analysis if <= this many high/critical findings
MAX_FINDINGS_FOR_LLM = 5  # Max individual LLM calls in full mode
MAX_CODE_SNIPPET_LENGTH = 2000  # Truncate code snippets
MAX_PROMPT_LENGTH = 4000  # Total prompt size limit

# Analysis modes
AnalysisMode = Literal["full", "summary", "auto"]

# Pre-built exploit templates for common vulnerabilities (no LLM needed)
EXPLOIT_TEMPLATES = {
    "eval": {
        "title": "Code Injection via eval()",
        "narrative": "The use of eval() with untrusted input allows arbitrary code execution. An attacker can inject malicious Python/JavaScript code through user-controlled input that reaches this eval() call.",
        "preconditions": "Attacker must be able to control input that flows into eval()",
        "impact": "Full code execution in the application context, potential RCE",
        "poc_outline": "1. Identify user input reaching eval()\n2. Inject payload: __import__('os').system('id')\n3. Verify command execution",
        "mitigation": "Remove eval() entirely. Use ast.literal_eval() for safe parsing, or implement a whitelist-based parser.",
    },
    "exec": {
        "title": "Code Injection via exec()",
        "narrative": "Similar to eval(), exec() executes arbitrary code. Any user-controlled data reaching exec() enables full code injection.",
        "preconditions": "User input must flow to exec() parameter",
        "impact": "Arbitrary code execution, potential server compromise",
        "poc_outline": "1. Trace data flow to exec()\n2. Inject: exec('import os; os.system(\"whoami\")')\n3. Confirm execution",
        "mitigation": "Eliminate exec() usage. Use safe alternatives like predefined functions or sandboxed execution.",
    },
    "shell=true": {
        "title": "Command Injection via shell=True",
        "narrative": "Using shell=True in subprocess calls enables shell metacharacter injection. Attackers can append commands using ; | & or other shell operators.",
        "preconditions": "User input concatenated into shell command string",
        "impact": "OS command execution, lateral movement, data exfiltration",
        "poc_outline": "1. Find user input in command string\n2. Inject: '; cat /etc/passwd'\n3. Verify command chaining works",
        "mitigation": "Use shell=False with argument list. Validate and sanitize all inputs. Consider shlex.quote().",
    },
    "sql": {
        "title": "SQL Injection Vulnerability",
        "narrative": "Direct string concatenation in SQL queries allows attackers to manipulate query logic, extract data, or modify the database.",
        "preconditions": "User input directly embedded in SQL string",
        "impact": "Data breach, authentication bypass, data manipulation, potential RCE via xp_cmdshell",
        "poc_outline": "1. Test input with single quote: '\n2. Try UNION SELECT: ' UNION SELECT username,password FROM users--\n3. Extract sensitive data",
        "mitigation": "Use parameterized queries or ORM. Never concatenate user input into SQL strings.",
    },
    "xss": {
        "title": "Cross-Site Scripting (XSS)",
        "narrative": "Unsanitized user input rendered in HTML enables script injection. Attackers can steal session cookies, perform actions as the user, or redirect to phishing sites.",
        "preconditions": "User input reflected in page without encoding",
        "impact": "Session hijacking, credential theft, malware distribution",
        "poc_outline": "1. Inject: <script>alert(document.cookie)</script>\n2. Or: <img src=x onerror=alert(1)>\n3. Verify script execution",
        "mitigation": "HTML-encode all output. Use Content-Security-Policy headers. Implement input validation.",
    },
    "secret": {
        "title": "Hardcoded Secret Exposure",
        "narrative": "Credentials or API keys committed to source code can be extracted by anyone with repository access, including via leaked git history.",
        "preconditions": "Access to source code or git history",
        "impact": "Unauthorized access to external services, data breach, financial loss",
        "poc_outline": "1. Search git history: git log -p | grep -i password\n2. Use extracted credentials\n3. Access protected resources",
        "mitigation": "Remove secrets from code. Use environment variables or secret management (Vault, AWS Secrets Manager). Rotate compromised credentials immediately.",
    },
    "path_traversal": {
        "title": "Path Traversal / Directory Traversal",
        "narrative": "User-controlled file paths without validation allow reading or writing arbitrary files using ../ sequences.",
        "preconditions": "User input used in file path operations",
        "impact": "Read sensitive files (/etc/passwd, config files), potential RCE via file upload",
        "poc_outline": "1. Request: ?file=../../../etc/passwd\n2. Check for file contents in response\n3. Escalate to write if possible",
        "mitigation": "Validate paths against whitelist. Use os.path.basename() and resolve canonical paths. Implement chroot or sandboxing.",
    },
    "password": {
        "title": "Hardcoded Password Detected",
        "narrative": "Passwords embedded in source code can be extracted by anyone with access to the codebase, including from git history even after removal.",
        "preconditions": "Access to source code repository",
        "impact": "Unauthorized access to systems/accounts, privilege escalation, data breach",
        "poc_outline": "1. Extract password from source\n2. Identify associated service/account\n3. Attempt authentication",
        "mitigation": "Use environment variables or secret management. Rotate all exposed credentials immediately.",
    },
    "rand": {
        "title": "Weak Random Number Generation",
        "narrative": "Use of predictable random functions (rand, Math.random, etc.) for security purposes allows attackers to predict tokens, session IDs, or cryptographic values.",
        "preconditions": "Application uses weak RNG for security-sensitive operations",
        "impact": "Session prediction, token forgery, cryptographic weakness",
        "poc_outline": "1. Analyze RNG usage context\n2. Predict or brute-force generated values\n3. Exploit predictable tokens",
        "mitigation": "Use cryptographically secure RNG: secrets module (Python), crypto.randomBytes (Node.js), SecureRandom (Java).",
    },
    "md5": {
        "title": "Weak Cryptographic Hash (MD5)",
        "narrative": "MD5 is cryptographically broken and unsuitable for security purposes. Collisions can be generated and rainbow tables exist for common passwords.",
        "preconditions": "MD5 used for password hashing or integrity verification",
        "impact": "Password cracking, hash collision attacks, integrity bypass",
        "poc_outline": "1. Capture MD5 hash\n2. Use rainbow tables or hashcat\n3. Recover plaintext or generate collision",
        "mitigation": "Use bcrypt/argon2 for passwords, SHA-256/SHA-3 for integrity. Never use MD5 for security.",
    },
    "sha1": {
        "title": "Weak Cryptographic Hash (SHA-1)",
        "narrative": "SHA-1 has known collision vulnerabilities and is deprecated for security use. Practical collision attacks have been demonstrated.",
        "preconditions": "SHA-1 used for signatures or integrity",
        "impact": "Digital signature forgery, certificate attacks",
        "poc_outline": "1. Identify SHA-1 usage\n2. Apply known collision techniques if applicable\n3. Forge signatures or bypass checks",
        "mitigation": "Migrate to SHA-256 or SHA-3. Update certificates and signing processes.",
    },
    "deserialization": {
        "title": "Insecure Deserialization",
        "narrative": "Deserializing untrusted data can lead to remote code execution, denial of service, or authentication bypass depending on the framework.",
        "preconditions": "Application deserializes user-controlled data",
        "impact": "Remote code execution, DoS, authentication bypass",
        "poc_outline": "1. Identify deserialization entry point\n2. Craft malicious serialized payload (ysoserial, pickle exploits)\n3. Achieve code execution",
        "mitigation": "Avoid deserializing untrusted data. Use safe formats (JSON). Implement integrity checks.",
    },
    "xxe": {
        "title": "XML External Entity (XXE) Injection",
        "narrative": "XML parsers that process external entities can be exploited to read local files, perform SSRF, or cause denial of service.",
        "preconditions": "Application parses XML with external entity processing enabled",
        "impact": "File disclosure, SSRF, DoS, potential RCE",
        "poc_outline": "1. Submit XML with external entity: <!DOCTYPE foo [<!ENTITY xxe SYSTEM 'file:///etc/passwd'>]>\n2. Reference &xxe; in document\n3. Observe file contents",
        "mitigation": "Disable DTDs and external entities in XML parser. Use defusedxml (Python) or similar safe parsers.",
    },
    "ssrf": {
        "title": "Server-Side Request Forgery (SSRF)",
        "narrative": "Application makes HTTP requests to user-controlled URLs, allowing access to internal services, cloud metadata, or external attacks.",
        "preconditions": "User input controls URL in server-side HTTP request",
        "impact": "Access internal services, cloud credential theft, port scanning",
        "poc_outline": "1. Provide URL: http://169.254.169.254/latest/meta-data/\n2. Or: http://localhost:8080/admin\n3. Access restricted resources",
        "mitigation": "Whitelist allowed domains. Block internal IP ranges. Use URL parsing and validation.",
    },
    "csrf": {
        "title": "Cross-Site Request Forgery (CSRF)",
        "narrative": "Missing CSRF protection allows attackers to trick authenticated users into performing unintended actions via malicious websites.",
        "preconditions": "User is authenticated, no CSRF token validation",
        "impact": "Account takeover, unauthorized actions, data modification",
        "poc_outline": "1. Create malicious HTML form targeting vulnerable endpoint\n2. Host on attacker site\n3. Trick victim into visiting",
        "mitigation": "Implement CSRF tokens. Use SameSite cookie attribute. Verify Origin/Referer headers.",
    },
    "prototype": {
        "title": "Prototype Pollution",
        "narrative": "JavaScript prototype pollution allows attackers to inject properties into Object.prototype, affecting all objects and potentially leading to RCE or privilege escalation.",
        "preconditions": "User input merged into objects without sanitization",
        "impact": "Property injection, authentication bypass, potential RCE",
        "poc_outline": "1. Submit: __proto__.isAdmin=true\n2. Or: constructor.prototype.isAdmin=true\n3. Check if property affects application logic",
        "mitigation": "Use Object.create(null) for dictionaries. Sanitize keys. Use Map instead of objects.",
    },
    "buffer": {
        "title": "Buffer Overflow Vulnerability",
        "narrative": "Writing beyond buffer boundaries corrupts memory, potentially allowing code execution, crashes, or information disclosure.",
        "preconditions": "Application processes untrusted input without bounds checking",
        "impact": "Remote code execution, denial of service, information leak",
        "poc_outline": "1. Identify buffer size\n2. Send oversized input\n3. Analyze crash for exploitability",
        "mitigation": "Use safe functions (strncpy, snprintf). Enable compiler protections (ASLR, stack canaries). Use memory-safe languages.",
    },
    "format": {
        "title": "Format String Vulnerability",
        "narrative": "User input in printf-style format strings allows reading/writing memory through format specifiers like %n, %x, %s.",
        "preconditions": "User input passed as format string argument",
        "impact": "Information disclosure, arbitrary memory write, code execution",
        "poc_outline": "1. Input: %x%x%x%x to leak stack\n2. Use %n to write to memory\n3. Overwrite return address or GOT",
        "mitigation": "Never use user input as format string. Always use printf('%s', user_input).",
    },
    "null": {
        "title": "Null Pointer Dereference",
        "narrative": "Dereferencing null pointers causes crashes and denial of service. In some cases, memory mapping at address 0 can enable exploitation.",
        "preconditions": "Null pointer can be triggered via specific input",
        "impact": "Denial of service, potential code execution",
        "poc_outline": "1. Identify input causing null pointer\n2. Trigger crash\n3. Analyze for further exploitation",
        "mitigation": "Add null checks. Use static analysis. Enable compiler warnings for null dereference.",
    },
    "regex": {
        "title": "Regular Expression Denial of Service (ReDoS)",
        "narrative": "Poorly constructed regex patterns can exhibit exponential backtracking, causing CPU exhaustion with crafted input.",
        "preconditions": "Vulnerable regex processes user input",
        "impact": "Denial of service, resource exhaustion",
        "poc_outline": "1. Identify regex pattern\n2. Craft input with repetitive patterns (e.g., 'aaaaaaaaaaaaaaaaaaaaaaaaaaaa!')\n3. Observe CPU spike/hang",
        "mitigation": "Use regex linters. Implement timeouts. Use RE2 or other safe regex engines.",
    },
    "ldap": {
        "title": "LDAP Injection",
        "narrative": "User input in LDAP queries without escaping allows filter manipulation, potentially bypassing authentication or extracting data.",
        "preconditions": "User input used in LDAP filter construction",
        "impact": "Authentication bypass, information disclosure",
        "poc_outline": "1. Input: *)(uid=*))(|(uid=*\n2. Modify filter logic\n3. Bypass authentication or enumerate users",
        "mitigation": "Use parameterized LDAP queries. Escape special characters. Validate input strictly.",
    },
    "nosql": {
        "title": "NoSQL Injection",
        "narrative": "Injection in NoSQL queries (MongoDB, etc.) allows query manipulation, data extraction, or authentication bypass using operators like $gt, $ne.",
        "preconditions": "User input directly used in NoSQL query objects",
        "impact": "Data breach, authentication bypass",
        "poc_outline": "1. Submit: {\"$gt\": \"\"}\n2. Or: {\"$ne\": null}\n3. Bypass conditions or extract data",
        "mitigation": "Use query builders. Validate input types strictly. Sanitize object keys.",
    },
    # === ADDITIONAL VULNERABILITY TYPES FOR COMPREHENSIVE COVERAGE ===
    
    # Authentication & Session Issues
    "auth_bypass": {
        "title": "Authentication Bypass",
        "narrative": "Weak or missing authentication controls allow unauthorized access to protected resources or functions.",
        "preconditions": "Application has authentication flaws or missing checks",
        "impact": "Unauthorized access, privilege escalation, account takeover",
        "poc_outline": "1. Identify protected endpoints\n2. Access without credentials or with forged tokens\n3. Bypass authentication checks",
        "mitigation": "Implement proper authentication. Use established frameworks. Add authorization checks to all sensitive endpoints.",
    },
    "session": {
        "title": "Session Management Vulnerabilities",
        "narrative": "Weak session handling allows session hijacking, fixation, or prediction attacks.",
        "preconditions": "Application uses weak session identifiers or insecure transmission",
        "impact": "Account takeover, session hijacking, unauthorized access",
        "poc_outline": "1. Analyze session token entropy\n2. Check for session fixation\n3. Test session timeout and invalidation",
        "mitigation": "Use secure, random session tokens. Regenerate on auth. Set secure cookie flags (HttpOnly, Secure, SameSite).",
    },
    "jwt": {
        "title": "JWT Security Issues",
        "narrative": "JSON Web Token vulnerabilities including algorithm confusion, weak secrets, or missing validation.",
        "preconditions": "Application uses JWT for authentication/authorization",
        "impact": "Token forgery, authentication bypass, privilege escalation",
        "poc_outline": "1. Decode JWT payload\n2. Try algorithm=none attack\n3. Brute force weak secrets\n4. Test signature verification",
        "mitigation": "Use strong secrets. Validate algorithm explicitly. Check all claims. Use asymmetric keys for production.",
    },
    
    # Input Validation
    "header_injection": {
        "title": "HTTP Header Injection",
        "narrative": "User input in HTTP headers enables response splitting, cache poisoning, or session fixation attacks.",
        "preconditions": "User input included in HTTP response headers",
        "impact": "Cache poisoning, XSS via headers, session fixation",
        "poc_outline": "1. Inject CRLF: %0d%0a\n2. Add malicious headers\n3. Perform response splitting",
        "mitigation": "Sanitize all header values. Reject newlines in user input. Use framework header APIs.",
    },
    "template": {
        "title": "Server-Side Template Injection (SSTI)",
        "narrative": "User input in template engines can execute arbitrary code. Affects Jinja2, Twig, Freemarker, etc.",
        "preconditions": "User input rendered directly in server-side templates",
        "impact": "Remote code execution, server compromise",
        "poc_outline": "1. Test: {{7*7}} or ${7*7}\n2. Identify template engine\n3. Use engine-specific RCE payload",
        "mitigation": "Never pass user input to template render. Use sandboxed templates. Implement strict input validation.",
    },
    "log_injection": {
        "title": "Log Injection / Log Forging",
        "narrative": "User input written to logs without sanitization allows log forgery, injection of fake entries, or exploitation of log viewers.",
        "preconditions": "User input logged without sanitization",
        "impact": "Log manipulation, exploit log analysis tools, hide attacks",
        "poc_outline": "1. Inject newlines and fake log entries\n2. Test ANSI escape sequences\n3. Try Log4Shell-style payloads",
        "mitigation": "Sanitize log inputs. Encode special characters. Use structured logging.",
    },
    
    # Memory Safety (C/C++)
    "use_after_free": {
        "title": "Use-After-Free Vulnerability",
        "narrative": "Memory accessed after being freed can lead to code execution, crashes, or information disclosure.",
        "preconditions": "Memory management error in C/C++ code",
        "impact": "Remote code execution, denial of service, information disclosure",
        "poc_outline": "1. Identify freed memory access\n2. Trigger reallocation with controlled data\n3. Exploit dangling pointer",
        "mitigation": "Use smart pointers (C++). Set pointers to NULL after free. Use memory sanitizers in testing.",
    },
    "double_free": {
        "title": "Double-Free Vulnerability",
        "narrative": "Freeing memory twice corrupts heap metadata, potentially enabling arbitrary write or code execution.",
        "preconditions": "Memory freed multiple times",
        "impact": "Heap corruption, code execution, denial of service",
        "poc_outline": "1. Identify double-free condition\n2. Manipulate heap layout\n3. Achieve arbitrary write primitive",
        "mitigation": "Set pointers to NULL after free. Use smart pointers. Run with address sanitizer.",
    },
    "integer_overflow": {
        "title": "Integer Overflow/Underflow",
        "narrative": "Arithmetic operations exceeding integer bounds cause unexpected values, leading to buffer overflows or logic errors.",
        "preconditions": "Arithmetic on user-controlled integers without bounds checking",
        "impact": "Buffer overflow, logic bypass, denial of service",
        "poc_outline": "1. Identify integer operation\n2. Provide values near MAX_INT or 0\n3. Trigger wraparound behavior",
        "mitigation": "Use safe integer libraries. Check bounds before operations. Use larger integer types.",
    },
    "race_condition": {
        "title": "Race Condition / TOCTOU",
        "narrative": "Time-of-check to time-of-use race conditions allow attackers to manipulate state between security check and operation.",
        "preconditions": "Security check and operation are non-atomic",
        "impact": "Privilege escalation, security bypass, data corruption",
        "poc_outline": "1. Identify check-then-use pattern\n2. Win race with rapid requests or symlink attacks\n3. Bypass security check",
        "mitigation": "Use atomic operations. Lock resources. Avoid filesystem races with O_NOFOLLOW.",
    },
    "uninitialized": {
        "title": "Uninitialized Memory Usage",
        "narrative": "Reading uninitialized memory can leak sensitive data or cause unpredictable behavior.",
        "preconditions": "Code path reads memory before initialization",
        "impact": "Information disclosure, undefined behavior, crashes",
        "poc_outline": "1. Trigger code path with uninitialized read\n2. Observe leaked data or crash\n3. Exploit for information disclosure",
        "mitigation": "Initialize all variables. Use compiler warnings. Enable memory sanitizers.",
    },
    
    # Cryptography
    "weak_cipher": {
        "title": "Weak Encryption Algorithm",
        "narrative": "Use of deprecated encryption algorithms (DES, RC4, ECB mode) enables cryptographic attacks.",
        "preconditions": "Application uses weak encryption for sensitive data",
        "impact": "Data decryption, confidentiality breach",
        "poc_outline": "1. Identify encryption algorithm\n2. Apply known attacks (brute force for DES, biases for RC4)\n3. Decrypt protected data",
        "mitigation": "Use AES-256-GCM or ChaCha20-Poly1305. Avoid ECB mode. Use authenticated encryption.",
    },
    "insecure_tls": {
        "title": "Insecure TLS/SSL Configuration",
        "narrative": "Weak TLS versions (SSLv3, TLS 1.0) or cipher suites enable protocol attacks and decryption.",
        "preconditions": "Application accepts weak TLS configurations",
        "impact": "Man-in-the-middle attacks, traffic decryption",
        "poc_outline": "1. Scan TLS configuration\n2. Identify weak protocols/ciphers\n3. Perform downgrade or known attacks (BEAST, POODLE)",
        "mitigation": "Require TLS 1.2+. Disable weak ciphers. Use modern cipher suites. Enable HSTS.",
    },
    "hardcoded_key": {
        "title": "Hardcoded Cryptographic Key",
        "narrative": "Encryption keys embedded in source code can be extracted, compromising all encrypted data.",
        "preconditions": "Access to source code or binary",
        "impact": "Complete compromise of encrypted data, authentication bypass",
        "poc_outline": "1. Extract key from source/binary\n2. Decrypt protected data\n3. Forge authenticated tokens",
        "mitigation": "Use key management systems. Derive keys from secure sources. Never commit keys to repositories.",
    },
    
    # Information Disclosure
    "info_disclosure": {
        "title": "Sensitive Information Disclosure",
        "narrative": "Application exposes sensitive data through error messages, debug info, or improper access controls.",
        "preconditions": "Application reveals sensitive information",
        "impact": "Data breach, aids further attacks, compliance violations",
        "poc_outline": "1. Trigger error conditions\n2. Examine responses for stack traces, paths, versions\n3. Use disclosed info for targeted attacks",
        "mitigation": "Use generic error messages. Disable debug mode in production. Implement proper access controls.",
    },
    "directory_listing": {
        "title": "Directory Listing Enabled",
        "narrative": "Web server directory listing exposes file structure, backup files, and potentially sensitive resources.",
        "preconditions": "Web server has directory listing enabled",
        "impact": "Information disclosure, discovery of sensitive files",
        "poc_outline": "1. Access directory URLs without index file\n2. Browse exposed files\n3. Find backups, configs, or source code",
        "mitigation": "Disable directory listing. Add index files. Implement proper access controls.",
    },
    
    # Denial of Service
    "resource_exhaustion": {
        "title": "Resource Exhaustion / DoS",
        "narrative": "Application allows unbounded resource consumption leading to denial of service.",
        "preconditions": "Application processes unbounded user input",
        "impact": "Service unavailability, resource exhaustion",
        "poc_outline": "1. Identify resource-intensive operations\n2. Send large/many requests\n3. Exhaust CPU, memory, or connections",
        "mitigation": "Implement rate limiting. Set resource limits. Use timeouts. Validate input sizes.",
    },
    "zip_bomb": {
        "title": "Zip Bomb / Decompression Attack",
        "narrative": "Malicious compressed files expand to enormous sizes, exhausting disk space or memory.",
        "preconditions": "Application extracts user-uploaded archives",
        "impact": "Denial of service, disk exhaustion",
        "poc_outline": "1. Create nested/recursive compressed file\n2. Upload to application\n3. Exhaust resources during extraction",
        "mitigation": "Limit extraction size. Check compression ratio. Extract to isolated environments.",
    },
    
    # File Operations
    "file_upload": {
        "title": "Unrestricted File Upload",
        "narrative": "Insufficient validation of uploaded files allows execution of malicious code or overwriting critical files.",
        "preconditions": "Application accepts file uploads without proper validation",
        "impact": "Remote code execution, defacement, data destruction",
        "poc_outline": "1. Upload webshell with allowed extension bypass\n2. Access uploaded file\n3. Execute commands",
        "mitigation": "Validate file types server-side. Store outside webroot. Rename uploaded files. Scan for malware.",
    },
    "symlink": {
        "title": "Symbolic Link Attack",
        "narrative": "Following symbolic links allows reading or writing files outside intended directories.",
        "preconditions": "Application follows symlinks in user-controlled paths",
        "impact": "Arbitrary file read/write, privilege escalation",
        "poc_outline": "1. Create symlink to sensitive file\n2. Access through application\n3. Read /etc/passwd or write to config",
        "mitigation": "Use O_NOFOLLOW flag. Validate real paths. Avoid operations on symlinks.",
    },
    
    # Go-specific (gosec)
    "gosec_subprocess": {
        "title": "Go Subprocess Security Issue",
        "narrative": "Unsafe subprocess execution in Go code may allow command injection.",
        "preconditions": "User input reaches exec.Command or similar",
        "impact": "Command injection, remote code execution",
        "poc_outline": "1. Identify user input in command\n2. Inject shell metacharacters\n3. Execute arbitrary commands",
        "mitigation": "Use exec.Command with separate arguments. Never use shell expansion. Validate inputs.",
    },
    "gosec_crypto": {
        "title": "Go Weak Cryptography",
        "narrative": "Use of weak cryptographic functions in Go (MD5, SHA1, weak random).",
        "preconditions": "Application uses weak crypto for security operations",
        "impact": "Cryptographic weakness, token prediction",
        "poc_outline": "1. Identify weak crypto usage\n2. Apply appropriate attack\n3. Crack hashes or predict values",
        "mitigation": "Use crypto/sha256, crypto/rand. Avoid md5, sha1 for security purposes.",
    },
    
    # Java-specific (SpotBugs)
    "java_injection": {
        "title": "Java Injection Vulnerability",
        "narrative": "Various injection vulnerabilities in Java code including EL injection, OGNL injection, etc.",
        "preconditions": "User input reaches expression evaluation",
        "impact": "Remote code execution, data access",
        "poc_outline": "1. Identify expression language usage\n2. Inject malicious expressions\n3. Achieve code execution",
        "mitigation": "Sanitize inputs. Disable expression evaluation on user data. Use parameterized queries.",
    },
    "java_xxe": {
        "title": "Java XXE Vulnerability",
        "narrative": "XML processing in Java without disabling external entities enables XXE attacks.",
        "preconditions": "Application parses XML with default settings",
        "impact": "File disclosure, SSRF, denial of service",
        "poc_outline": "1. Submit XML with external entity\n2. Reference entity in document\n3. Exfiltrate data",
        "mitigation": "Disable DTDs: factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true)",
    },
    
    # Insecure Configuration
    "cors": {
        "title": "Insecure CORS Configuration",
        "narrative": "Overly permissive Cross-Origin Resource Sharing allows unauthorized cross-origin requests.",
        "preconditions": "Application has misconfigured CORS headers",
        "impact": "Data theft from authenticated users, CSRF-like attacks",
        "poc_outline": "1. Check Access-Control-Allow-Origin header\n2. Create malicious page on attacker domain\n3. Steal data from authenticated requests",
        "mitigation": "Whitelist specific origins. Never use * with credentials. Validate Origin header.",
    },
    "open_redirect": {
        "title": "Open Redirect Vulnerability",
        "narrative": "User-controlled redirect URLs enable phishing attacks by redirecting users to malicious sites.",
        "preconditions": "Redirect URL controllable via user input",
        "impact": "Phishing, credential theft, malware distribution",
        "poc_outline": "1. Identify redirect parameter\n2. Set to external URL: ?redirect=https://evil.com\n3. Trick users into visiting malicious site",
        "mitigation": "Whitelist allowed redirect destinations. Use relative URLs. Validate against trusted domains.",
    },
    "clickjacking": {
        "title": "Clickjacking / UI Redressing",
        "narrative": "Missing X-Frame-Options allows embedding site in iframes for clickjacking attacks.",
        "preconditions": "Application can be framed, has sensitive actions",
        "impact": "Unauthorized actions, data theft",
        "poc_outline": "1. Create page that iframes target\n2. Overlay invisible buttons\n3. Trick user into clicking",
        "mitigation": "Set X-Frame-Options: DENY. Use Content-Security-Policy frame-ancestors. Implement frame-busting.",
    },
}


def _get_template_for_finding(finding: models.Finding) -> Optional[dict]:
    """Check if a finding matches a pre-built template."""
    summary_lower = finding.summary.lower()
    details_str = str(finding.details).lower() if finding.details else ""
    finding_type = (finding.type or "").lower()
    combined = summary_lower + " " + details_str + " " + finding_type
    
    # Direct key matches
    for key, template in EXPLOIT_TEMPLATES.items():
        if key in combined:
            return template
    
    # Additional pattern matching for common vulnerabilities
    patterns = {
        "password": ["password", "credential", "hardcoded", "passwd", "b105", "b106", "b107"],
        "secret": ["api_key", "apikey", "secret", "token", "private_key", "b104"],
        "sql": ["sql injection", "sqli", "query injection", "b608"],
        "xss": ["cross-site scripting", "xss", "script injection", "reflected", "b320"],
        "eval": ["eval(", "evaluate", "code injection", "b307"],
        "exec": ["exec(", "system(", "popen(", "command injection", "os.system", "subprocess", "b602", "b603", "b604", "b605", "b606", "b607"],
        "shell=true": ["shell=true", "shell injection", "b604"],
        "buffer": ["buffer overflow", "stack overflow", "heap overflow", "out of bounds", "cwe-120", "cwe-122", "cwe-131"],
        "format": ["format string", "printf", "sprintf"],
        "null": ["null pointer", "nullptr", "null dereference", "nullderef", "cwe-476"],
        "md5": ["md5", "weak hash", "b303", "b324"],
        "sha1": ["sha1", "sha-1", "b303"],
        "rand": ["random", "rand()", "math.random", "insecure random", "pseudo-random", "b311"],
        "deserialization": ["deserialize", "unpickle", "unserialize", "yaml.load", "b301", "b506"],
        "xxe": ["xxe", "xml external", "external entity", "b313", "b314", "b318", "b319", "b320"],
        "ssrf": ["ssrf", "server-side request", "b310"],
        "csrf": ["csrf", "cross-site request forgery"],
        "prototype": ["prototype pollution", "__proto__"],
        "path_traversal": ["path traversal", "directory traversal", "../", "lfi", "rfi", "b108"],
        "regex": ["redos", "regex dos", "catastrophic backtracking"],
        "ldap": ["ldap injection"],
        "nosql": ["nosql injection", "mongodb injection"],
        # Additional common scanner patterns
        "exec": ["os.popen", "subprocess.call", "subprocess.run", "subprocess.popen", "commands."],
        "sql": ["execute(", "executemany(", "cursor.execute", "raw(", ".extra(", ".raw("],
        "xss": ["mark_safe", "safestring", "|safe", "dangerouslysetinnerhtml"],
        "secret": ["aws_access_key", "aws_secret", "github_token", "slack_token", "stripe"],
        "deserialization": ["pickle.load", "cpickle", "shelve", "marshal.load", "yaml.load", "yaml.unsafe"],
    }
    
    for template_key, keywords in patterns.items():
        for keyword in keywords:
            if keyword in combined:
                return EXPLOIT_TEMPLATES.get(template_key)
    
    # Check finding type
    if finding.type == "secret":
        return EXPLOIT_TEMPLATES["secret"]
    
    return None


def _build_prompt(finding: models.Finding, code_snippet: str) -> str:
    """Build the prompt for exploitability analysis with length limits."""
    # Truncate code snippet to save tokens
    truncated_code = code_snippet[:MAX_CODE_SNIPPET_LENGTH]
    if len(code_snippet) > MAX_CODE_SNIPPET_LENGTH:
        truncated_code += "\n... (truncated)"
    
    prompt = (
        "You are a security analyst. Given the finding details and code snippet, provide a concise analysis:\n"
        "1. How an attacker could exploit this (2-3 sentences)\n"
        "2. Key preconditions required\n"
        "3. Potential impact\n"
        "4. One mitigation recommendation\n\n"
        "Do not provide runnable exploit code. Be concise.\n\n"
        f"Finding: {finding.summary}\n"
        f"Severity: {finding.severity}\n"
        f"File: {finding.file_path}\n"
        f"Code:\n{truncated_code}"
    )
    
    # Enforce total prompt length
    return prompt[:MAX_PROMPT_LENGTH]


async def call_gemini(prompt: str) -> str:
    """
    Call Gemini API for exploitability analysis using the new google-genai SDK.
    
    Args:
        prompt: The analysis prompt to send
        
    Returns:
        Generated narrative or fallback message
    """
    if not settings.gemini_api_key:
        logger.debug("Gemini API key not configured, returning stub narrative")
        return "Gemini API key not configured. This is a stubbed exploitability narrative."
    
    try:
        from google import genai
        
        client = genai.Client(api_key=settings.gemini_api_key)
        
        response = client.models.generate_content(
            model=settings.gemini_model_id,
            contents=prompt
        )
        
        if response and response.text:
            logger.debug("Successfully generated exploitability narrative")
            return response.text
        
        logger.warning("Gemini returned no content")
        return "No exploitability narrative generated - no content returned."
        
    except ImportError:
        logger.error("google-genai package not installed. Run: pip install google-genai")
        return "google-genai package not installed. Please install it."
    except Exception as e:
        logger.error(f"Gemini API error: {e}")
        return f"Failed to contact Gemini: {str(e)}. Provide manual analysis based on finding details."


async def generate_exploit_scenarios(
    db: Session, 
    report: models.Report, 
    mode: AnalysisMode = "auto"
) -> List[models.ExploitScenario]:
    """
    Generate exploitability scenarios for high/critical findings in a report.
    
    Modes:
    - "full": Individual exploit scenarios for each finding (uses templates + limited LLM)
    - "summary": Single executive summary of all findings (1 LLM call) + templates for all
    - "auto": Automatically selects based on finding count (<=20 = full, >20 = summary)
    
    Args:
        db: Database session
        report: Report model to generate scenarios for
        mode: Analysis mode - "full", "summary", or "auto"
        
    Returns:
        List of created ExploitScenario models
    """
    findings = (
        db.query(models.Finding)
        .filter(models.Finding.scan_run_id == report.scan_run_id)
        .filter(models.Finding.severity.in_(["high", "critical"]))
        .all()
    )
    
    # Sort by severity (critical first)
    findings.sort(key=lambda f: 0 if f.severity == "critical" else 1)
    
    # Auto-select mode based on finding count
    if mode == "auto":
        mode = "full" if len(findings) <= FULL_ANALYSIS_THRESHOLD else "summary"
    
    logger.info(f"Processing {len(findings)} high/critical findings in '{mode}' mode")
    
    scenarios: List[models.ExploitScenario] = []
    
    # Generate executive summary first if in summary mode
    if mode == "summary" and findings:
        summary_scenario = await _generate_executive_summary(db, report, findings)
        if summary_scenario:
            scenarios.append(summary_scenario)
    
    # Generate individual scenarios (templates only in summary mode, templates+LLM in full mode)
    individual_scenarios = await _generate_individual_scenarios(
        db, report, findings, use_llm=(mode == "full")
    )
    scenarios.extend(individual_scenarios)
    
    db.commit()
    logger.info(f"Generated {len(scenarios)} exploit scenarios for report {report.id} (mode: {mode})")
    return scenarios


async def _generate_executive_summary(
    db: Session, 
    report: models.Report, 
    findings: List[models.Finding]
) -> Optional[models.ExploitScenario]:
    """
    Generate a single executive summary analyzing all findings together.
    Uses just 1 LLM call regardless of finding count.
    """
    if not settings.gemini_api_key:
        logger.debug("Gemini API key not configured, skipping executive summary")
        return None
    
    # Build summary of findings for the prompt
    critical_count = sum(1 for f in findings if f.severity == "critical")
    high_count = sum(1 for f in findings if f.severity == "high")
    
    # Group findings by type/category
    finding_types = {}
    for f in findings:
        # Try to categorize by common patterns
        category = _categorize_finding(f)
        if category not in finding_types:
            finding_types[category] = []
        finding_types[category].append(f)
    
    # Build a concise summary for the prompt
    findings_summary = []
    for category, cat_findings in sorted(finding_types.items(), key=lambda x: -len(x[1])):
        sample = cat_findings[0]
        findings_summary.append(
            f"- {category}: {len(cat_findings)} findings (e.g., {sample.file_path}: {sample.summary[:80]})"
        )
    
    prompt = f"""You are an elite red team operator writing an exploit development summary.

The codebase has {len(findings)} high/critical security findings:
- Critical: {critical_count}
- High: {high_count}

Vulnerability categories found:
{chr(10).join(findings_summary[:15])}

Write an exploit development summary using this EXACT format:

**Overall Exploitability Assessment**
Rate as CRITICAL/HIGH/MEDIUM exploitability with 1-2 sentence justification.

**Attack Chain Priority**
1. **First target** - Why this is the best entry point
2. **Second target** - What to chain next
3. **Third target** - How to escalate

**Recommended Exploit Development Order**
• **Immediate** - Exploits that can be developed in hours
• **Short-term** - Exploits requiring days of development
• **Advanced** - Complex chains requiring significant effort

**Key Attack Surfaces**
• Surface 1 - Brief description
• Surface 2 - Brief description
• Surface 3 - Brief description

FORMATTING RULES:
- Use **bold** for headers and key terms
- Use numbered lists (1. 2. 3.) for ordered steps
- Use bullet points (•) for unordered lists
- Be specific about vulnerability types and exploitation techniques
- Think like a hacker, no remediation advice"""

    summary_text = await call_gemini(prompt)
    
    # Create exploit development summary as a special scenario
    scenario = models.ExploitScenario(
        report_id=report.id,
        finding_id=None,  # Not tied to a specific finding
        severity="critical",  # Mark as critical to appear first
        title="Exploit Development Summary",
        narrative=summary_text,
        preconditions="This is an overall exploitability assessment for red team planning.",
        impact=f"Analysis covers {critical_count} critical and {high_count} high severity findings across multiple attack vectors.",
        poc_outline="See individual vulnerability type scenarios below for specific exploitation techniques.",
        mitigation_notes="Focus on high-value targets first. Chain vulnerabilities for maximum impact.",
    )
    db.add(scenario)
    return scenario


def _categorize_finding(finding: models.Finding) -> str:
    """Categorize a finding into a high-level category for summarization."""
    summary_lower = finding.summary.lower()
    details_str = str(finding.details).lower() if finding.details else ""
    combined = summary_lower + " " + details_str
    
    categories = {
        "Command Injection": ["exec", "system", "popen", "shell", "command", "subprocess"],
        "SQL Injection": ["sql", "query", "execute"],
        "Cross-Site Scripting (XSS)": ["xss", "script", "cross-site"],
        "Hardcoded Secrets": ["password", "secret", "api_key", "credential", "token"],
        "Insecure Cryptography": ["md5", "sha1", "weak", "crypto", "random", "rand"],
        "Path Traversal": ["path", "directory", "traversal", "../"],
        "Deserialization": ["pickle", "deserialize", "yaml.load", "unserialize"],
        "XML/XXE": ["xml", "xxe", "entity"],
        "Buffer Overflow": ["buffer", "overflow", "bounds"],
        "Code Injection": ["eval", "code injection"],
        "SSRF": ["ssrf", "request forgery"],
        "Authentication Issues": ["auth", "login", "session"],
    }
    
    for category, keywords in categories.items():
        for keyword in keywords:
            if keyword in combined:
                return category
    
    return "Other Security Issues"


def _extract_rule_id(finding: models.Finding) -> Optional[str]:
    """Extract a rule ID from finding details for grouping similar issues."""
    if not finding.details:
        return None
    
    details = finding.details if isinstance(finding.details, dict) else {}
    
    # Try common rule ID fields from different scanners
    rule_id = (
        details.get("rule_id") or
        details.get("ruleId") or
        details.get("check_id") or
        details.get("checkId") or
        details.get("test_id") or
        details.get("testId") or
        details.get("code") or  # Bandit uses 'code' sometimes
        details.get("id")
    )
    
    if rule_id:
        return str(rule_id).strip()
    
    # Try to extract from message/summary patterns like "[B101]" or "CWE-123"
    import re
    summary = finding.summary or ""
    
    # Match patterns like B101, B602, CWE-123, G101, etc.
    patterns = [
        r'\b([BG]\d{3})\b',  # Bandit (B101) and gosec (G101)
        r'\b(CWE-\d+)\b',  # CWE identifiers
        r'\b(S\d{4})\b',  # SonarQube rules
        r'\b(security/[a-z-]+)\b',  # ESLint security plugin
    ]
    
    for pattern in patterns:
        match = re.search(pattern, summary, re.IGNORECASE)
        if match:
            return match.group(1).upper()
    
    return None


def _format_rule_title(rule_id: str) -> str:
    """Format a rule ID into a human-readable title."""
    # Known rule prefixes
    prefixes = {
        "B": "Bandit",
        "G": "Gosec", 
        "S": "SonarQube",
        "CWE": "CWE",
    }
    
    for prefix, name in prefixes.items():
        if rule_id.startswith(prefix):
            return f"{name} {rule_id}"
    
    # Clean up rule IDs like "security/detect-eval-with-expression"
    if "/" in rule_id:
        parts = rule_id.split("/")
        return parts[-1].replace("-", " ").title()
    
    return rule_id


def _format_type_title(type_name: str) -> str:
    """Format a finding type into a human-readable title."""
    type_titles = {
        "sast": "Static Analysis Security",
        "secret": "Secret Detection",
        "dependency": "Dependency Vulnerability",
        "code_smell": "Code Quality",
        "vulnerability": "Security Vulnerability",
        "bug": "Potential Bug",
        "semgrep": "Semgrep",
        "bandit": "Bandit",
        "eslint": "ESLint",
        "gosec": "Gosec",
        "spotbugs": "SpotBugs",
        "clangtidy": "Clang-Tidy",
    }
    
    return type_titles.get(type_name.lower(), type_name.replace("_", " ").title())


def _create_catchall_scenario(
    db: Session,
    report: models.Report,
    findings: List[models.Finding],
    title: str,
    use_llm: bool = False
) -> Optional[models.ExploitScenario]:
    """Create a catch-all scenario for ungrouped findings."""
    if not findings:
        return None
    
    severities = {"critical": 4, "high": 3, "medium": 2, "low": 1, "info": 0}
    highest_severity = max(findings, key=lambda f: severities.get(f.severity, 0)).severity
    
    all_files = list(set(f.file_path for f in findings if f.file_path))
    files_str = ", ".join(all_files[:5])
    if len(all_files) > 5:
        files_str += f" (+{len(all_files) - 5} more)"
    
    # Build narrative from sample findings
    sample_summaries = list(set(f.summary for f in findings[:3]))
    sample_text = "\n".join(f"- {s[:100]}..." if len(s) > 100 else f"- {s}" for s in sample_summaries)
    
    narrative = f"**{len(findings)} instances found** across the codebase.\n\n"
    narrative += f"**Sample issues:**\n{sample_text}\n\n"
    narrative += "Manual review recommended to assess exploitability and impact."
    
    scenario = models.ExploitScenario(
        report_id=report.id,
        finding_id=findings[0].id,
        severity=highest_severity,
        title=title,
        narrative=narrative,
        preconditions="Review access requirements and attack surface.",
        impact=f"Severity: {highest_severity}. Affected files: {files_str}",
        poc_outline="Manual security testing recommended based on finding type.",
        mitigation_notes="Apply secure coding practices. Consult documentation for specific remediation guidance.",
    )
    db.add(scenario)
    return scenario


async def _generate_individual_scenarios(
    db: Session,
    report: models.Report,
    findings: List[models.Finding],
    use_llm: bool = False
) -> List[models.ExploitScenario]:
    """
    Generate exploit scenarios GROUPED BY VULNERABILITY CATEGORY.
    Creates only ONE scenario per category to avoid duplicates.
    """
    scenarios: List[models.ExploitScenario] = []
    llm_calls_made = 0
    
    # Define category groupings - map template keys to broader categories
    CATEGORY_GROUPS = {
        # Code Injection (group eval, exec, shell together)
        "code_injection": {
            "keys": ["eval", "exec", "shell=true", "template", "gosec_subprocess"],
            "title": "Code Injection Vulnerabilities",
            "narrative": "Multiple code injection vectors found allowing arbitrary code execution. These include eval(), exec(), shell command injection, and template injection.",
            "preconditions": "Attacker must control input that flows to code execution functions",
            "impact": "Full code execution in application context, potential server compromise, lateral movement",
            "poc_outline": "1. Identify user input reaching eval()/exec()/shell\n2. Inject payload: __import__('os').system('whoami')\n3. For shell: inject '; cat /etc/passwd'\n4. For SSTI: {{7*7}} or ${T(java.lang.Runtime).exec('id')}",
            "mitigation": "Remove eval()/exec() entirely. Use shell=False with argument lists. Never render user input in templates.",
        },
        # Secrets (group password, secret, api keys, hardcoded keys)
        "secrets": {
            "keys": ["secret", "password", "hardcoded_key", "jwt"],
            "title": "Hardcoded Credentials & Secrets",
            "narrative": "Credentials, API keys, tokens, and cryptographic keys are embedded in source code. These can be extracted by anyone with repository access.",
            "preconditions": "Access to source code or git history",
            "impact": "Unauthorized access to systems/services, data breach, privilege escalation, financial loss",
            "poc_outline": "1. Search code: grep -r 'password\\|secret\\|api_key\\|token'\n2. Check git history: git log -p | grep -i password\n3. For JWT: decode token, try algorithm=none attack\n4. Use extracted credentials to access services",
            "mitigation": "Use environment variables or secret management (Vault, AWS Secrets Manager). Rotate all exposed credentials immediately.",
        },
        # SQL/NoSQL Injection
        "injection_db": {
            "keys": ["sql", "nosql", "ldap"],
            "title": "Database Injection Vulnerabilities", 
            "narrative": "Injection vulnerabilities in database queries (SQL, NoSQL, LDAP) allow attackers to manipulate query logic, extract data, or bypass authentication.",
            "preconditions": "User input directly embedded in query string",
            "impact": "Data breach, authentication bypass, data manipulation, potential RCE",
            "poc_outline": "1. SQL: ' OR '1'='1' --\n2. NoSQL: {\"$ne\": null}\n3. LDAP: *)(uid=*))(|(uid=*\n4. Extract or bypass authentication",
            "mitigation": "Use parameterized queries, ORM, or query builders. Never concatenate user input into queries.",
        },
        # XSS and Client-Side
        "client_side": {
            "keys": ["xss", "csrf", "clickjacking", "open_redirect", "prototype"],
            "title": "Client-Side Vulnerabilities",
            "narrative": "Client-side vulnerabilities including XSS, CSRF, clickjacking, and open redirects that target application users.",
            "preconditions": "User interaction or victim visiting malicious page",
            "impact": "Session hijacking, credential theft, unauthorized actions, phishing",
            "poc_outline": "1. XSS: <script>alert(document.cookie)</script>\n2. CSRF: Create form auto-submitting to target\n3. Open redirect: ?url=https://evil.com\n4. Clickjacking: iframe with overlay",
            "mitigation": "HTML-encode output. Implement CSRF tokens. Set X-Frame-Options. Validate redirect URLs.",
        },
        # SSRF and Network
        "network": {
            "keys": ["ssrf", "cors", "insecure_tls", "header_injection"],
            "title": "Network & Request Vulnerabilities",
            "narrative": "Server-side request forgery, insecure CORS, TLS issues, and header injection enabling access to internal resources or traffic interception.",
            "preconditions": "User input controls URLs or headers in server requests",
            "impact": "Access internal services, cloud credential theft, man-in-the-middle attacks",
            "poc_outline": "1. SSRF: http://169.254.169.254/latest/meta-data/\n2. Internal: http://localhost:8080/admin\n3. Header injection: inject CRLF sequences",
            "mitigation": "Whitelist allowed domains. Require TLS 1.2+. Validate all header values.",
        },
        # Path/File Operations
        "file_ops": {
            "keys": ["path_traversal", "file_upload", "symlink", "directory_listing"],
            "title": "File Operation Vulnerabilities",
            "narrative": "Path traversal, unrestricted file upload, and symlink attacks enabling unauthorized file access or code execution.",
            "preconditions": "User input used in file operations",
            "impact": "Read sensitive files, write malicious files, achieve RCE via webshell",
            "poc_outline": "1. Path traversal: ../../../etc/passwd\n2. File upload: upload .php/.jsp webshell\n3. Symlink: create symlink to sensitive file",
            "mitigation": "Validate paths against whitelist. Validate uploaded file types server-side. Don't follow symlinks.",
        },
        # Crypto weaknesses
        "crypto": {
            "keys": ["md5", "sha1", "rand", "weak_cipher", "gosec_crypto"],
            "title": "Weak Cryptography",
            "narrative": "Use of broken cryptographic algorithms (MD5, SHA1, DES, RC4) or weak random number generation enabling attacks on data confidentiality and integrity.",
            "preconditions": "Application uses weak crypto for security-sensitive operations",
            "impact": "Password cracking, hash collisions, token prediction, traffic decryption",
            "poc_outline": "1. MD5/SHA1: Use rainbow tables or hashcat\n2. Weak RNG: Analyze and predict generated values\n3. Weak cipher: Apply known cryptanalytic attacks",
            "mitigation": "Use bcrypt/argon2 for passwords. SHA-256+ for integrity. AES-GCM for encryption. secrets module for random.",
        },
        # Deserialization
        "deserial": {
            "keys": ["deserialization"],
            "title": "Insecure Deserialization",
            "narrative": "Deserializing untrusted data can lead to remote code execution. Python pickle, Java ObjectInputStream, PHP unserialize, and YAML are common vectors.",
            "preconditions": "Application deserializes user-controlled data",
            "impact": "Remote code execution, denial of service, authentication bypass",
            "poc_outline": "1. Identify deserialization entry point\n2. Craft malicious payload (ysoserial for Java, pickle exploit for Python)\n3. Send payload and achieve code execution",
            "mitigation": "Avoid deserializing untrusted data. Use safe formats (JSON). Implement integrity checks.",
        },
        # XXE and XML
        "xml": {
            "keys": ["xxe", "java_xxe"],
            "title": "XML Processing Vulnerabilities",
            "narrative": "XML parsers with external entity processing enabled can be exploited to read local files, perform SSRF, or cause denial of service.",
            "preconditions": "Application parses XML with external entity processing enabled",
            "impact": "File disclosure, SSRF, denial of service, potential RCE",
            "poc_outline": "1. Submit: <!DOCTYPE foo [<!ENTITY xxe SYSTEM 'file:///etc/passwd'>]>\n2. Reference &xxe; in document\n3. For blind XXE: use out-of-band channels",
            "mitigation": "Disable DTDs and external entities. Use defusedxml (Python), XMLConstants.FEATURE_SECURE_PROCESSING (Java).",
        },
        # Memory Safety (C/C++)
        "memory": {
            "keys": ["buffer", "format", "use_after_free", "double_free", "null", "integer_overflow", "uninitialized"],
            "title": "Memory Safety Vulnerabilities",
            "narrative": "Memory corruption vulnerabilities including buffer overflows, use-after-free, format strings, and integer overflows in native code.",
            "preconditions": "Application written in C/C++ processes untrusted input",
            "impact": "Remote code execution, denial of service, information disclosure",
            "poc_outline": "1. Buffer overflow: send oversized input\n2. Format string: inject %x%x%n\n3. Use-after-free: trigger reallocation\n4. Integer overflow: provide MAX_INT values",
            "mitigation": "Use safe functions (strncpy, snprintf). Enable ASLR/stack canaries. Use memory sanitizers. Consider memory-safe languages.",
        },
        # Authentication/Session
        "auth": {
            "keys": ["auth_bypass", "session"],
            "title": "Authentication & Session Issues",
            "narrative": "Authentication bypass, weak session management, and access control vulnerabilities allowing unauthorized access.",
            "preconditions": "Application has authentication/session handling flaws",
            "impact": "Unauthorized access, account takeover, privilege escalation",
            "poc_outline": "1. Test for missing auth on endpoints\n2. Analyze session token entropy\n3. Check for session fixation\n4. Test privilege escalation",
            "mitigation": "Implement proper authentication. Use established frameworks. Regenerate sessions on auth. Set secure cookie flags.",
        },
        # DoS
        "dos": {
            "keys": ["regex", "resource_exhaustion", "zip_bomb", "race_condition"],
            "title": "Denial of Service Vulnerabilities",
            "narrative": "Resource exhaustion, ReDoS, zip bombs, and race conditions that can cause service unavailability.",
            "preconditions": "Application processes unbounded user input",
            "impact": "Service unavailability, resource exhaustion",
            "poc_outline": "1. ReDoS: craft exponential regex input\n2. Zip bomb: upload nested compressed file\n3. Race condition: rapid concurrent requests",
            "mitigation": "Implement rate limiting. Set resource limits. Use timeouts. Validate input sizes. Use atomic operations.",
        },
        # Information Disclosure
        "info_leak": {
            "keys": ["info_disclosure", "log_injection"],
            "title": "Information Disclosure",
            "narrative": "Exposure of sensitive information through error messages, logs, debug output, or improper access controls.",
            "preconditions": "Application reveals sensitive information",
            "impact": "Data breach, aids further attacks, compliance violations",
            "poc_outline": "1. Trigger error conditions\n2. Check for stack traces, paths, versions\n3. Inject into logs to forge entries",
            "mitigation": "Use generic error messages. Disable debug in production. Sanitize log inputs.",
        },
        # Java-specific
        "java": {
            "keys": ["java_injection"],
            "title": "Java-Specific Vulnerabilities",
            "narrative": "Java-specific issues including EL injection, OGNL injection, and expression language vulnerabilities.",
            "preconditions": "Java application evaluates user-controlled expressions",
            "impact": "Remote code execution, data access",
            "poc_outline": "1. EL injection: ${T(java.lang.Runtime).exec('id')}\n2. OGNL: (#cmd='id').(#rt=@java.lang.Runtime@getRuntime().exec(#cmd))",
            "mitigation": "Disable expression evaluation on user data. Sanitize inputs. Use latest framework versions.",
        },
    }
    
    # Group findings by category
    category_findings: dict[str, List[models.Finding]] = {}
    uncategorized: List[models.Finding] = []
    
    for finding in findings:
        template_key = _get_template_key_for_finding(finding)
        if template_key:
            # Find which category this template key belongs to
            found_category = None
            for cat_name, cat_info in CATEGORY_GROUPS.items():
                if template_key in cat_info["keys"]:
                    found_category = cat_name
                    break
            
            if found_category:
                if found_category not in category_findings:
                    category_findings[found_category] = []
                category_findings[found_category].append(finding)
            else:
                # Template exists but not in a category group - use template directly
                if template_key not in category_findings:
                    category_findings[template_key] = []
                category_findings[template_key].append(finding)
        else:
            uncategorized.append(finding)
    
    # Create ONE scenario per category
    for cat_key, cat_findings in category_findings.items():
        if cat_key in CATEGORY_GROUPS:
            cat_info = CATEGORY_GROUPS[cat_key]
            title = cat_info["title"]
            narrative = cat_info["narrative"]
            preconditions = cat_info["preconditions"]
            impact = cat_info["impact"]
            poc_outline = cat_info["poc_outline"]
            mitigation = cat_info["mitigation"]
        else:
            # Use individual template
            template = EXPLOIT_TEMPLATES.get(cat_key, {})
            title = template.get("title", f"Security Issue: {cat_key}")
            narrative = template.get("narrative", "Security vulnerability requiring review.")
            preconditions = template.get("preconditions", "Review access requirements.")
            impact = template.get("impact", "Impact depends on context.")
            poc_outline = template.get("poc_outline", "Manual testing recommended.")
            mitigation = template.get("mitigation", "Apply secure coding practices.")
        
        # Find highest severity
        severities = {"critical": 4, "high": 3, "medium": 2, "low": 1, "info": 0}
        highest_severity = max(cat_findings, key=lambda f: severities.get(f.severity, 0)).severity
        
        # List affected files
        all_files = list(set(f.file_path for f in cat_findings))
        files_str = ", ".join(all_files[:5])
        if len(all_files) > 5:
            files_str += f" (+{len(all_files) - 5} more)"
        
        # Add instance count to narrative
        if len(cat_findings) > 1:
            narrative = f"**{len(cat_findings)} instances found** across the codebase.\n\n{narrative}"
        
        scenario = models.ExploitScenario(
            report_id=report.id,
            finding_id=cat_findings[0].id,
            severity=highest_severity,
            title=title,
            narrative=narrative,
            preconditions=preconditions,
            impact=impact + f"\n\nAffected files: {files_str}",
            poc_outline=poc_outline,
            mitigation_notes=mitigation,
        )
        db.add(scenario)
        scenarios.append(scenario)
    
    # Handle uncategorized findings with multi-level catch-all grouping
    if uncategorized:
        # LEVEL 1: Try to group by rule_id from details (most specific)
        rule_groups: dict[str, List[models.Finding]] = {}
        still_uncategorized: List[models.Finding] = []
        
        for finding in uncategorized:
            rule_id = _extract_rule_id(finding)
            if rule_id:
                if rule_id not in rule_groups:
                    rule_groups[rule_id] = []
                rule_groups[rule_id].append(finding)
            else:
                still_uncategorized.append(finding)
        
        # LEVEL 2: Group remaining by finding.type (scanner type like 'sast', 'secret', etc.)
        type_groups: dict[str, List[models.Finding]] = {}
        final_uncategorized: List[models.Finding] = []
        
        for finding in still_uncategorized:
            if finding.type:
                type_key = finding.type.lower().strip()
                if type_key not in type_groups:
                    type_groups[type_key] = []
                type_groups[type_key].append(finding)
            else:
                final_uncategorized.append(finding)
        
        # LEVEL 3: Final catch-all - group remaining by keyword category
        keyword_groups: dict[str, List[models.Finding]] = {}
        for finding in final_uncategorized:
            cat = _categorize_finding(finding)
            if cat not in keyword_groups:
                keyword_groups[cat] = []
            keyword_groups[cat].append(finding)
        
        # Create scenarios for rule-based groups
        for rule_id, rule_findings in rule_groups.items():
            scenario = _create_catchall_scenario(
                db, report, rule_findings, 
                title=f"Security Issue: {_format_rule_title(rule_id)}",
                use_llm=use_llm and llm_calls_made < MAX_FINDINGS_FOR_LLM
            )
            if scenario:
                scenarios.append(scenario)
                if use_llm and llm_calls_made < MAX_FINDINGS_FOR_LLM:
                    llm_calls_made += 1
        
        # Create scenarios for type-based groups
        for type_name, type_findings in type_groups.items():
            scenario = _create_catchall_scenario(
                db, report, type_findings,
                title=f"{_format_type_title(type_name)} Issues",
                use_llm=use_llm and llm_calls_made < MAX_FINDINGS_FOR_LLM
            )
            if scenario:
                scenarios.append(scenario)
                if use_llm and llm_calls_made < MAX_FINDINGS_FOR_LLM:
                    llm_calls_made += 1
        
        # Create scenarios for keyword-based groups
        for cat_name, cat_findings in keyword_groups.items():
            scenario = _create_catchall_scenario(
                db, report, cat_findings,
                title=cat_name,
                use_llm=use_llm and llm_calls_made < MAX_FINDINGS_FOR_LLM
            )
            if scenario:
                scenarios.append(scenario)
                if use_llm and llm_calls_made < MAX_FINDINGS_FOR_LLM:
                    llm_calls_made += 1
    
    logger.info(f"Generated {len(scenarios)} grouped exploit scenarios ({llm_calls_made} LLM calls)")
    return scenarios


def _get_template_key_for_finding(finding: models.Finding) -> Optional[str]:
    """Get the template key (not title) for a finding."""
    summary_lower = finding.summary.lower()
    details_str = str(finding.details).lower() if finding.details else ""
    finding_type = (finding.type or "").lower()
    combined = summary_lower + " " + details_str + " " + finding_type
    
    # Check each template key
    for key in EXPLOIT_TEMPLATES.keys():
        if key in combined:
            return key
    
    # Comprehensive pattern matching for all scanners and vulnerability types
    patterns = {
        # === INJECTION VULNERABILITIES ===
        "sql": [
            "sql injection", "sqli", "query injection", "b608", 
            "sql_injection", "cwe-89", "execute(", "executemany(",
            "cursor.execute", "raw(", ".extra(", ".raw(",
            "sql_injection_hibernate", "sql_injection_jpa", "sql_injection_jdbc",
        ],
        "xss": [
            "cross-site scripting", "xss", "script injection", "reflected", "b320",
            "xss_servlet", "xss_jsp", "cwe-79", "mark_safe", "safestring", 
            "|safe", "dangerouslysetinnerhtml", "v-html", "innerhtml",
            "xss_request_wrapper", "no-unsanitized",
        ],
        "eval": [
            "eval(", "evaluate", "code injection", "b307",
            "detect-eval-with-expression", "no-eval", "no-implied-eval",
            "new function(", "setinterval(", "settimeout(",
        ],
        "exec": [
            "exec(", "system(", "popen(", "command injection", "os.system",
            "subprocess", "b602", "b603", "b604", "b605", "b606", "b607",
            "command_injection", "cwe-78", "os.popen", "commands.",
            "detect-child-process", "child_process", "spawn(", "execfile",
            "g204",  # gosec subprocess
        ],
        "shell=true": ["shell=true", "shell injection", "b604", "shell=1"],
        "template": [
            "template injection", "ssti", "jinja", "twig", "freemarker",
            "server-side template", "mako", "velocity", "thymeleaf",
        ],
        "ldap": ["ldap injection", "ldap_injection", "cwe-90"],
        "nosql": ["nosql injection", "mongodb injection", "$where", "$gt", "$ne"],
        "header_injection": ["header injection", "crlf", "response splitting", "http splitting"],
        "log_injection": ["log injection", "log forging", "log4j", "log4shell", "jndi"],
        
        # === AUTHENTICATION & SESSION ===
        "password": [
            "password", "credential", "hardcoded", "passwd", "b105", "b106", "b107",
            "default password", "weak password",
        ],
        "secret": [
            "api_key", "apikey", "secret", "token", "private_key", "b104",
            "aws_access_key", "aws_secret", "github_token", "slack_token",
            "stripe", "bearer", "authorization", "g101",  # gosec hardcoded
        ],
        "jwt": ["jwt", "json web token", "algorithm confusion", "none algorithm", "hs256", "rs256"],
        "session": ["session fixation", "session hijack", "session management", "cookie"],
        "auth_bypass": ["authentication bypass", "auth bypass", "broken auth", "missing auth"],
        "csrf": ["csrf", "cross-site request forgery", "no csrf", "missing csrf"],
        
        # === FILE & PATH VULNERABILITIES ===
        "path_traversal": [
            "path traversal", "directory traversal", "../", "lfi", "rfi", "b108",
            "path_traversal_in", "path_traversal_out", "cwe-22", "..\\",
            "detect-non-literal-fs-filename",
        ],
        "file_upload": ["file upload", "unrestricted upload", "webshell", "upload validation"],
        "symlink": ["symlink", "symbolic link", "link following", "toctou"],
        "directory_listing": ["directory listing", "directory browsing", "index of"],
        
        # === XML VULNERABILITIES ===
        "xxe": [
            "xxe", "xml external", "external entity", "b313", "b314", "b318", "b319", "b320",
            "xxe_saxparser", "xxe_document", "xxe_xmlreader", "cwe-611",
            "doctype", "entity", "dtd",
        ],
        
        # === NETWORK VULNERABILITIES ===
        "ssrf": [
            "ssrf", "server-side request", "request forgery", "b310",
            "url validation", "open url", "169.254.169.254",
        ],
        "open_redirect": ["open redirect", "redirect", "unvalidated redirect", "url redirect"],
        "cors": ["cors", "cross-origin", "access-control-allow", "origin validation"],
        "insecure_tls": [
            "tls", "ssl", "sslv3", "tls 1.0", "weak cipher", "certificate",
            "weak_trust_manager", "weak_hostname_verifier", "cwe-295",
        ],
        
        # === CRYPTOGRAPHY ===
        "md5": ["md5", "weak hash", "b303", "b324", "weak_message_digest_md5", "cwe-327"],
        "sha1": ["sha1", "sha-1", "b303", "weak_message_digest_sha1"],
        "rand": [
            "random", "rand()", "math.random", "insecure random", "pseudo-random", "b311",
            "cert-msc30-c", "cert-msc32-c", "cert-msc50-cpp", "detect-pseudorandombytes",
            "g404",  # gosec weak random
        ],
        "weak_cipher": ["des", "rc4", "ecb mode", "weak encryption", "blowfish", "3des"],
        "hardcoded_key": ["hardcoded key", "encryption key", "aes key", "private key embedded"],
        
        # === DESERIALIZATION ===
        "deserialization": [
            "deserialize", "unpickle", "unserialize", "yaml.load", "b301", "b506",
            "pickle.load", "cpickle", "shelve", "marshal.load", "yaml.unsafe",
            "object_deserialization", "java.io.objectinputstream", "readobject",
            "ysoserial", "gadget chain",
        ],
        
        # === MEMORY SAFETY (C/C++) ===
        "buffer": [
            "buffer overflow", "stack overflow", "heap overflow", "out of bounds",
            "cwe-120", "cwe-122", "cwe-131", "gets(", "strcpy", "strcat",
            "sprintf", "scanf", "memcpy", "array-bounds", "stack-buffer",
        ],
        "format": [
            "format string", "printf", "sprintf", "fprintf", "cwe-134",
            "format-security", "%n", "user-controlled format",
        ],
        "use_after_free": [
            "use-after-free", "use after free", "uaf", "cwe-416",
            "bugprone-use-after-move", "dangling pointer",
        ],
        "double_free": ["double-free", "double free", "cwe-415"],
        "null": [
            "null pointer", "nullptr", "null dereference", "nullderef", "cwe-476",
            "null-dereference", "npe",
        ],
        "integer_overflow": [
            "integer overflow", "integer underflow", "int overflow", "cwe-190",
            "bugprone-integer-division", "wraparound",
        ],
        "uninitialized": [
            "uninitialized", "uninit", "cwe-457", "uninitialized-memory",
            "maybe-uninitialized",
        ],
        "race_condition": [
            "race condition", "toctou", "time-of-check", "cwe-362",
            "data race", "concurrent", "threading",
        ],
        
        # === DENIAL OF SERVICE ===
        "regex": [
            "redos", "regex dos", "catastrophic backtracking", "detect-unsafe-regex",
            "exponential regex", "regular expression dos",
        ],
        "resource_exhaustion": [
            "resource exhaustion", "dos", "denial of service", "memory exhaustion",
            "cpu exhaustion", "infinite loop", "bugprone-infinite-loop",
        ],
        "zip_bomb": ["zip bomb", "decompression bomb", "zip slip", "archive"],
        
        # === INFORMATION DISCLOSURE ===
        "info_disclosure": [
            "information disclosure", "info leak", "sensitive data", "stack trace",
            "debug", "verbose error", "exception", "cwe-200",
        ],
        
        # === UI SECURITY ===
        "clickjacking": ["clickjacking", "x-frame-options", "frame-ancestors", "ui redress"],
        "prototype": ["prototype pollution", "__proto__", "constructor.prototype"],
        
        # === SCANNER-SPECIFIC RULE IDs ===
        # Bandit (Python) - B1xx to B7xx
        "secret": ["b100", "b101", "b102", "b103", "b104", "b105", "b106", "b107", "b108"],
        "exec": ["b601", "b602", "b603", "b604", "b605", "b606", "b607", "b609", "b610"],
        "deserialization": ["b301", "b302", "b303", "b304", "b305", "b306", "b307", "b308"],
        "xxe": ["b313", "b314", "b315", "b316", "b317", "b318", "b319", "b320", "b321"],
        "rand": ["b311", "b312"],
        "sql": ["b608"],
        "ssrf": ["b310"],
        
        # Gosec (Go) - G1xx to G6xx
        "gosec_subprocess": ["g201", "g202", "g203", "g204"],
        "gosec_crypto": ["g401", "g402", "g403", "g404", "g405", "g406"],
        "sql": ["g201", "g202"],
        "path_traversal": ["g304", "g305"],
        "xxe": ["g303"],
        
        # SpotBugs (Java)
        "java_injection": ["el_injection", "ognl_injection", "seam_log_injection"],
        "java_xxe": ["xxe_saxparser", "xxe_document", "xxe_xmlreader", "xxe_xpathexpr"],
        
        # ESLint (JavaScript)
        "eval": ["detect-eval", "no-eval", "no-implied-eval", "no-new-func"],
        "exec": ["detect-child-process", "child_process"],
        "path_traversal": ["detect-non-literal-fs-filename"],
        "regex": ["detect-unsafe-regex"],
        "prototype": ["detect-object-injection"],
        
        # Clang-Tidy (C/C++) - cert-*, bugprone-*
        "buffer": [
            "cert-str34-c", "bugprone-not-null-terminated-result",
            "bugprone-sizeof-container", "bugprone-sizeof-expression",
        ],
        "rand": ["cert-msc30-c", "cert-msc32-c", "cert-msc50-cpp", "cert-msc51-cpp"],
        "use_after_free": ["bugprone-use-after-move"],
        "race_condition": ["cert-con36-c", "cert-con37-c"],
    }
    
    for key, keywords in patterns.items():
        for keyword in keywords:
            if keyword in combined:
                return key
    
    # Check finding type as fallback
    if finding.type == "secret":
        return "secret"
    if finding.type == "sast":
        return None  # Let it fall through to catch-all
    
    return None
